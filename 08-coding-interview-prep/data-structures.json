{
  "name": "Data Structures",
  "order": 2,
  "time": "",
  "helpRoom": "HelpJavaScript",
  "challenges": [
    {
      "id": "587d8253367417b2b2512c6a",
      "title": "Typed Arrays",
      "description": [
        "数组是一种 JavaScript 对象，它能存储各种数据类型的元素。",
        "<code>var complexArr = [1, 5, \"2\", \"Word\", {\"name\": \"James\"}];</code>",
        "通常浏览器会自动地为数组分配合适的内存空间，同时内存大小也会随着你增删元素而发生变化。",
        "然而，在一些对高性能有要求以及有不同数据类型的情况下，有时需要更精确地给一个数组分配内存空间。",
        "<dfn>Typed arrays</dfn>就是解决这类问题的一种方案。我们可以精确地给一个数组分配内存空间。如下列表说明了这种数组能够存放的数据类型以及不同数据类型所占据的字节数。",
        "<table class='table table-striped'><tr><th>类型</th><th>元素所占字节数</th></tr><tr><td><code>Int8Array</code></td><td>1</td></tr><tr><td><code>Uint8Array</code></td><td>1</td></tr><tr><td><code>Uint8ClampedArray</code></td><td>1</td></tr><tr><td><code>Int16Array</code></td><td>2</td></tr><tr><td><code>Uint16Array</code></td><td>2</td></tr><tr><td><code>Int32Array</code></td><td>4</td></tr><tr><td><code>Uint32Array</code></td><td>4</td></tr><tr><td><code>Float32Array</code></td><td>4</td></tr><tr><td><code>Float64Array</code></td><td>8</td></tr></table>",
        "有两种方式可以创这类数组。其中一种是直接创建，如下代码创建了一个长度为 3 的 <code>Int16Array</code>.",
        "<blockquote>var i8 = new Int16Array(3);<br>console.log(i8);<br>// Returns [0, 0, 0]</blockquote>",
        "我们也可以通过创建<dfn>buffer</dfn>的方式来决定一个数组要容纳多少元素。",
        "<strong>注意</strong><br>我们可以通过分配上面列出的多个 bytes 的倍数来创建一个和上方代码中一样的类型数组。",
        "<blockquote>// Create same Int16Array array differently<br>var byteSize = 6; // Needs to be multiple of 2<br>var buffer = new ArrayBuffer(byteSize);<br>var i8View = new Int16Array(buffer);<br>buffer.byteLength; // Returns 6<br>i8View.byteLength; // Returns 6<br>console.log(i8View); // Returns [0, 0, 0]</blockquote>",
        "<dfn>Buffers</dfn>是一类存储数据的特定类型对象。我们需要通过创建视图来访问这类对象，不能直接访问。",
        "<blockquote>i8View[0] = 42;<br>console.log(i8View); // Returns [42, 0, 0]</blockquote>",
        "<strong>注意</strong><br>Typed Arrays 并没有像<code>.pop()</code>或<code>.push()</code>这些一般数组拥有的方法。使用<code>Array.isArray()</code>方法对 Typed Arrays 做判断返回的是 fail ，而非 true。因为更加简洁，所以更便于简化 JavaScript 引擎去实现这类数组。",
        "<hr>",
        "先创建一个64个字节的<code>buffer</code>，再创建一个类型是<code>Int32Array</code>名称叫做<code>i32View</code>的视图。"
      ],
      "tests": [
        {
          "text": "<code>buffer</code>应该有 64 个字节的长度。",
          "testString": "assert(buffer.byteLength === 64, 'Your <code>buffer</code> should be 64 bytes large.');"
        },
        {
          "text": "<code>i32View</code>视图应该有 64 个字节的长度。",
          "testString": "assert(i32View.byteLength === 64, 'Your <code>i32View</code> view of your buffer should be 64 bytes large.');"
        },
        {
          "text": "<code>i32View</code>视图应该能容纳 16 个元素。",
          "testString": "assert(i32View.length === 16, 'Your <code>i32View</code> view of your buffer should be 16 elements long.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "var buffer = new ArrayBuffer(64);\nvar i32View = new Int32Array(buffer);"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var buffer;",
            "var i32View;"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8250367417b2b2512c5e",
      "title": "Learn how a Stack Works",
      "description": [
        "我们应该都熟悉桌上摆着一堆书的场景，也可能应该使用过文本编辑器的撤销功能，同样我们也点击过手机应用里面的返回键来回到上一个操作页面。",
        "这些场景是否有什么共同之处呢？他们都以某种方式存储了数据，我们都可以通过一些操作返回到之前的状态。",
        "最上层的书总是最后放上去的。如果我们拿走了最上面的书，我们看到的总是倒数第二本放上去的书。",
        "我们会发现上述例子都遵循“后进先出”这个原则。而我们会在代码中实现这种原则。",
        "我们将这种类型的数据存储方式称为“栈”。需要特别注意的是我们通常使用<code>push()</code>方法将 JavaScript 对象压入栈中，同时使用<code>pop()</code>方法将 JavaScript 对象弹出栈。",
        "<hr>",
        "现在我们以数组形式存储一些作业信息，<code>\"BIO12\"</code>位于栈底，而<code>\"PSY44\"</code>则处于栈顶。",
        "现在用上文提到的 JavaScript 方法来对这个数组做栈操作。移除栈顶元素<code>\"PSY44\"</code>，然后再往栈顶添加<code>\"CS50\"</code>元素。"
      ],
      "tests": [
        {
          "text": "<code>homeworkStack</code>应该包含4个元素。",
          "testString": "assert(homeworkStack.length === 4, '<code>homeworkStack</code> should only contain 4 elements.');"
        },
        {
          "text": "<code>homeworkStack</code>当中最后一个元素应该是<code>\"CS50\"</code>。",
          "testString": "assert(homeworkStack[3] === 'CS50', 'The last element in <code>homeworkStack</code> should be <code>\"CS50\"</code>.');"
        },
        {
          "text": "<code>homeworkStack</code>当中不存在<code>\"PSY44\"</code>元素。",
          "testString": "assert(homeworkStack.indexOf('PSY44') === -1, '<code>homeworkStack</code> should not contain <code>\"PSY44\"</code>.');"
        },
        {
          "text": "对于<code>homeworkStack</code>的命名不能有变动。",
          "testString": "assert(code.match(/=/g).length === 1 && /homeworkStack\\s*=\\s*\\[\"BIO12\"\\s*,\\s*\"HIS80\"\\s*,\\s*\"MAT122\"\\s*,\\s*\"PSY44\"\\]/.test(code), 'The initial declaration of the <code>homeworkStack</code> should not be changed.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var homeworkStack = [\"BIO12\",\"HIS80\",\"MAT122\",\"PSY44\"];",
            "// 请在本行下方输入代码",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8250367417b2b2512c5f",
      "title": "Create a Stack Class",
      "description": [
        "通过上一章内容我们了解了栈的概念，同时也学习了如何使用数组去表示一个栈。本章内容我们学习如何创建一个栈类。",
        "虽然我们可以使用数组来创建栈，但是有时我们需要控制栈拥有哪些方法。",
        "除了<code>push</code>和<code>pop</code>两个方法，栈还拥有其它一些很有效的方法。现在我们来给栈类添加<code>peek</code>, <code>isEmpty</code>以及<code>clear</code>这些方法。",
        "提示",
        "编写能够将元素压入栈顶的<code>push</code>方法，移除栈顶元素的<code>pop</code>方法，查看栈中第一个元素的<code>peek</code>方法，判断栈是否为空的<code>isEmpty</code>方法，以及清空栈内容所有元素的<code>clear</code>方法。",
        "通常栈类当中并没有这些方法，但是我们在右侧代码区为栈类添加了一个<code>print</code>方法，该方法会打印出集合。"
      ],
      "tests": [
        {
          "text": "你的<code>Stack</code>类应有<code>push</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.push === 'function')}()), 'Your <code>Stack</code> class should have a <code>push</code> method.');"
        },
        {
          "text": "你的<code>Stack</code>类应有<code>pop</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.pop === 'function')}()), 'Your <code>Stack</code> class should have a <code>pop</code> method.');"
        },
        {
          "text": "你的<code>Stack</code>类应有<code>peek</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.peek === 'function')}()), 'Your <code>Stack</code> class should have a <code>peek</code> method.');"
        },
        {
          "text": "你的<code>Stack</code>类应有<code>isEmpty</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.isEmpty === 'function')}()), 'Your <code>Stack</code> class should have a <code>isEmpty</code> method.');"
        },
        {
          "text": "你的<code>Stack</code>类应有<code>clear</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.clear === 'function')}()), 'Your <code>Stack</code> class should have a <code>clear</code> method.');"
        },
        {
          "text": "<code>peek</code>方法应该返回栈顶元素。",
          "testString": "assert((function(){var test = new Stack();  test.push('CS50'); return (test.peek() === 'CS50')}()), 'The <code>peek</code> method should return the top element of the stack');"
        },
        {
          "text": "<code>pop</code>方法应该移除栈顶元素并返回该元素。",
          "testString": "assert((function(){var test = new Stack(); test.push('CS50'); return (test.pop() === 'CS50');}()), 'The <code>pop</code> method should remove and return the top element of the stack');"
        },
        {
          "text": "当栈内没有元素时<code>isEmpty</code>方法返回true。",
          "testString": "assert((function(){var test = new Stack(); return test.isEmpty()}()), 'The <code>isEmpty</code> method should return true if a stack does not contain any elements');"
        },
        {
          "text": "<code>clear</code>移除栈内所有元素。",
          "testString": "assert((function(){var test = new Stack();  test.push('CS50'); test.clear(); return (test.isEmpty())}()), 'The <code>clear</code> method should remove all element from the stack');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Stack() { ",
            "    var collection = [];",
            "    this.print = function() {",
            "        console.log(collection);",
            "    };",
            "    // 在本行下方输入代码",
            "",
            "    // 在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8250367417b2b2512c60",
      "title": "Create a Queue Class",
      "description": [
        "如同栈一样，队列也是一系列元素的集合。但是与栈不同的是队列遵循的是 FIFO (First-In First-Out 先进先出) 原则。新增元素会被添加进队列尾部，队列中元素的移除是头部操作。",
        "我们可以使用数组像创建栈那样来创建队列，同时我们也希望控制队列中拥有哪些操作方法。",
        " enqueue 和 dequeue 是队列类当中两个最主要的方法。入队方法将元素推入队尾，而出队方法将队首元素移动并返回该元素。其它比较实用的方法有 front,size 以及 isEmpty 方法。",
        "提示",
        "编写 enqueue 方法，该方法将新元素推入队尾；编写 dequeue 方法，该方法移除并返回队首元素；编写 front 方法，该方法返回队首元素；编写 size 方法，该方法返回队列长度；编写 isEmpty 方法，该方法判断队列是否为空。"
      ],
      "tests": [
        {
          "text": "你的<code>Queue</code>类应该有<code>enqueue</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.enqueue === 'function')}()), 'Your <code>Queue</code> class should have a <code>enqueue</code> method.');"
        },
        {
          "text": "你的<code>Queue</code>类应该有<code>dequeue</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.dequeue === 'function')}()), 'Your <code>Queue</code> class should have a <code>dequeue</code> method.');"
        },
        {
          "text": "你的<code>Queue</code>类应该有<code>front</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.front === 'function')}()), 'Your <code>Queue</code> class should have a <code>front</code> method.');"
        },
        {
          "text": "你的<code>Queue</code>类应该有<code>size</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.size === 'function')}()), 'Your <code>Queue</code> class should have a <code>size</code> method.');"
        },
        {
          "text": "你的<code>Queue</code>类应该有<code>isEmpty</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.isEmpty === 'function')}()), 'Your <code>Queue</code> class should have an <code>isEmpty</code> method.');"
        },
        {
          "text": "<code>dequeue</code>方法应该移除并返回队首元素",
          "testString": "assert((function(){var test = new Queue();  test.enqueue('Smith'); return (test.dequeue() === 'Smith')}()), 'The <code>dequeue</code> method should remove and return the front element of the queue');"
        },
        {
          "text": "<code>front</code>方法应该返回队首元素",
          "testString": "assert((function(){var test = new Queue();  test.enqueue('Smith'); test.enqueue('John'); return (test.front() === 'Smith')}()), 'The <code>front</code> method should return value of the front element of the queue');"
        },
        {
          "text": "<code>size</code>方法应该返回队列长度。",
          "testString": "assert((function(){var test = new Queue();  test.enqueue('Smith'); return (test.size() === 1)}()), 'The <code>size</code> method should return the length of the queue');"
        },
        {
          "text": "当队列当中有元素时<code>isEmpty</code>方法应该返回<code>false</code>",
          "testString": "assert((function(){var test = new Queue();  test.enqueue('Smith'); return !(test.isEmpty())}()), 'The <code>isEmpty</code> method should return <code>false</code> if there are elements in the queue');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Queue () { ",
            "    var collection = [];",
            "    this.print = function() {",
            "        console.log(collection);",
            "    };",
            "    // 请在本行下方输入代码",
            "",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8255367417b2b2512c74",
      "title": "Create a Priority Queue Class",
      "description": [
        "在这次挑战中我们来创建优先队列。优先队列是一种特殊类型的队列，这种队列中会有额外的信息来说明队列中元素的优先次序。这种优先次序可以使用整型数据来表示。元素的优先级会直接影响到元素的出队顺序。如果一个优先级较高的元素比较低优先级的元素后入队，但是高优先级的元素会先出队列。",
        "举个栗子，现在有一个拥有 3 个元素的优先队列：",
        "<code>[[’kitten’, 2], [‘dog’, 2], [‘rabbit’, 2]]</code>",
        "元素当中的第二个值（一个整型数字）代表它的优先级。如果我们入队<code>[‘human’, 1]</code>这个优先级为<code>1</code>的元素（这里规定数字越小优先级越高），那么这个元素在本优先队列当中会第一个出队。新的集合如下：",
        "<code>[[‘human’, 1], [’kitten’, 2], [‘dog’, 2], [‘rabbit’, 2]]</code>.",
        "我们已经在代码编辑器当中编写了<code>PriorityQueue</code>。你需要添加一个<code>enqueue</code>方法，使用该方法入队的元素都带有优先级；添加一个移除元素的<code>dequeue</code>方法；添加能够返回队列中元素总数的<code>size</code>方法；添加能够返回队列头部元素的<code>front</code>方法；最后需要添加<code>isEmpty</code>方法，当队列为空时<code>isEmpty</code>方法返回<code>true</code>否则返回<code>false</code>。",
        "<code>enqueue</code>方法接收如上 (<code>['human', 1]</code>) 这种元素，其中数字<code>1</code>表示元素优先级。<code>dequeue</code>方法应该返回的是当前元素，无需返回它的优先级。"
      ],
      "tests": [
        {
          "text": "你的<code>Queue</code>类应该有<code>enqueue</code>方法。",
          "testString": "assert((function(){var test = new PriorityQueue();  return (typeof test.enqueue === 'function')}()), 'Your <code>Queue</code> class should have a <code>enqueue</code> method.');"
        },
        {
          "text": "你的<code>Queue</code>类应该有<code>dequeue</code>方法。",
          "testString": "assert((function(){var test = new PriorityQueue();  return (typeof test.dequeue === 'function')}()), 'Your <code>Queue</code> class should have a <code>dequeue</code> method.');"
        },
        {
          "text": "你的<code>Queue</code>类应该有<code>size</code>方法。",
          "testString": "assert((function(){var test = new PriorityQueue();  return (typeof test.size === 'function')}()), 'Your <code>Queue</code> class should have a <code>size</code> method.');"
        },
        {
          "text": "你的<code>Queue</code>类应该有<code>isEmpty</code>方法。",
          "testString": "assert((function(){var test = new PriorityQueue();  return (typeof test.isEmpty === 'function')}()), 'Your <code>Queue</code> class should have an <code>isEmpty</code> method.');"
        },
        {
          "text": "当元素出队和入队时你的优先队列应该使用<code>size</code>方法实时跟踪队列当中元素的数量。",
          "testString": "assert((function(){var test = new PriorityQueue(); test.enqueue(['David Brown', 2]); test.enqueue(['Jon Snow', 1]); var size1 = test.size(); test.dequeue(); var size2 = test.size(); test.enqueue(['A', 3]); test.enqueue(['B', 3]); test.enqueue(['C', 3]); return (size1 === 2 && size2 === 1 && test.size() === 4)}()), 'Your PriorityQueue should correctly keep track of the current number of items using the <code>size</code> method as items are enqueued and dequeued.');"
        },
        {
          "text": "当队列为空时<code>isEmpty</code>方法应该返回<code>true</code>。",
          "testString": "assert((function(){var test = new PriorityQueue(); test.enqueue(['A', 1]); test.enqueue(['B', 1]); test.dequeue(); var first = test.isEmpty(); test.dequeue(); return (!first && test.isEmpty()); }()), 'The <code>isEmpty</code> method should return <code>true</code> when the queue is empty.');"
        },
        {
          "text": "优先队列当中高优先级的元素应该先于低优先级的元素出队，同一优先级的元素则遵循先进先出的原则。",
          "testString": "assert((function(){var test = new PriorityQueue(); test.enqueue(['A', 5]); test.enqueue(['B', 5]); test.enqueue(['C', 5]); test.enqueue(['D', 3]); test.enqueue(['E', 1]); test.enqueue(['F', 7]); var result = []; result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); return result.join('') === 'EDABCF';}()), 'The priority queue should return items with a higher priority before items with a lower priority and return items in first-in-first-out order otherwise.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function PriorityQueue () { \n this.collection = []; \n this.printCollection = function(){ \n console.log(this.collection); \n }; \n this.size = function() { \n return this.collection.length; \n }; \n this.isEmpty = function() { \n return this.size() > 0 ? false : true; \n }; \n this.enqueue = function (newitem) {\n  if (this.isEmpty()) {\n    return this.collection.push(newitem);\n  }\n\n  this.collection = this.collection.reverse();\n  var found_index = this.collection.findIndex(function (item) {\n    return newitem[1] >= item[1];\n  });\n  if (found_index === -1) {\n    this.collection.push(newitem);\n  } else {\n    this.collection.splice(found_index, 0, newitem);\n  }\n  this.collection = this.collection.reverse();\n}; \n this.dequeue = function() { \n if (!this.isEmpty()) { \n return this.collection.shift()[0]; \n } else { \n return 'The queue is empty.' \n } \n }; \n }"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function PriorityQueue () {",
            "    this.collection = [];",
            "    this.printCollection = function() {",
            "      console.log(this.collection);",
            "    };",
            "    // 请在本行下方输入代码",
            "",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8255367417b2b2512c75",
      "title": "Create a Circular Queue",
      "description": [
        "在本次挑战中我们来创建一个循环队列。当往循环队列的尾部添加元素时新增的元素会覆盖队列当中起始位置的元素。这种数据结构在某些特定场合会有一些实际应用。比如循环队列可以用于流媒体服务，当队列满了以后新的媒体数据会从头部直接覆盖原有的数据。",
        "下面我们用数组来给你说明循环数组这个概念：",
        "<blockquote>[1, 2, 3, 4, 5]<br> ^Read @ 0<br> ^Write @ 0</blockquote>",
        "读和写两个操作都从<code>0</code>这个位置开始。现在队列获取了<code>a</code>, <code>b</code>, 以及<code>c</code>这 3 个数据。新队列显示如下：",
        "<blockquote>[a, b, c, 4, 5]<br> ^Read @ 0<br>       ^Write @ 3</blockquote>",
        "当读取头读取数据时，我们可以选择移除或者保留数据：",
        "<blockquote>[null, null, null, 4, 5]<br>                   ^Read @ 3<br>                   ^Write @ 3</blockquote>",
        "一旦写操作到达队列末尾时会从队列开头从新开始写入数据：",
        "<blockquote>[f, null, null, d, e]<br>                ^Read @ 3<br> ^Write @ 1</blockquote>",
        "虽然这种数据结构有着固定的内存空间，但是却能够处理空间大于该内存大小的文件。",
        "提示：",
        "在本次挑战中我们来实现一个循环队列。该循环队列应该有<code>enqueue</code>和<code>dequeue</code>这两个方法，通过这两个方法我们从队列中读取以及写入数据。这个类当中应该含有一个整型数据，我们通过这个数据来定义队列的长度。我们已经在编辑器当中为你写好了这个循环队列的初始版本。当你往队列当中插入数据时书写头需要前移一个位置，而如果书写头到达队列的末尾的话则需要回到队列头部重新开始写入操作。类似的，在进行出队操作时读取头也应该向前移动。书写头的位置不应该越过读取头（我们的类当中不允许发生一个数据未经读取就已经被覆盖的情况发生），同时读取头也不能越过已经写入的数据。",
        "此外，当成功入队一个元素时<code>enqueue</code>方法应该返回该入队元素，否则就要返回<code>null</code>。同样，当出队一个元素时该元素应该被返回，否则就应该返回<code>null</code>。"
      ],
      "tests": [
        {
          "text": "<code>enqueue</code>方法将元素添加进循环队列。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(591); var print = test.print(); return print[0] === 17 && print[1] === 32 && print[2] === 591; })(), 'The <code>enqueue</code> method adds items to the circular queue.');"
        },
        {
          "text": "入队元素不能越过读取头。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(591); test.enqueue(13); test.enqueue(25); test.enqueue(59); var print = test.print(); return print[0] === 17 && print[1] === 32 && print[2] === 591; })(), 'You cannot enqueue items past the read pointer.');"
        },
        {
          "text": "<code>dequeue</code>方法让元素出队。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(591); return test.dequeue() === 17 && test.dequeue() === 32 && test.dequeue() === 591; })(), 'The <code>dequeue</code> method dequeues items from the queue.');"
        },
        {
          "text": "一个元素出队之后该位置应该被重置为<code>null</code>。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(672); test.dequeue(); test.dequeue(); var print = test.print(); return print[0] === null && print[1] === null && print[2] === 672; })(), 'After an item is dequeued its position in the queue should be reset to <code>null</code>.');"
        },
        {
          "text": "尝试出队书写头时会返回<code>null</code>，同时不要越过书写头。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(591); return test.dequeue() === 17 && test.dequeue() === 32 && test.dequeue() === 591 && test.dequeue() === null && test.dequeue() === null && test.dequeue() === null && test.dequeue() === null && test.enqueue(100) === 100 && test.dequeue() === 100; })(), 'Trying to dequeue past the write pointer returns <code>null</code> and does not advance the write pointer.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "class CircularQueue { \n constructor(size) { \n this.queue = []; \n this.read = 0; \n this.write = 0; \n this.max = size - 1; \n while (size > 0) { \n this.queue.push(null); \n size--; \n } \n } \n print() { \n return this.queue; \n } \n enqueue(item) { \n if (this.queue[this.write] === null) { \n this.queue[this.write] = item; \n if (this.write === this.max) { \n this.write = 0; \n } else { \n this.write++; \n } \n return item; \n } \n return null; \n } \n dequeue() { \n if (this.queue[this.read] !== null) { \n var item = this.queue[this.read]; \n this.queue[this.read] = null; \n if (this.read === this.max) { \n this.read = 0; \n } else { \n this.read++; \n } \n return item; \n } else { \n return null; \n } \n } \n }"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "class CircularQueue {",
            "   constructor(size) {",
            "",
            "     this.queue = [];",
            "     this.read = 0;",
            "     this.write = 0;",
            "     this.max = size - 1;",
            "",
            "     while (size > 0) {",
            "        this.queue.push(null);",
            "        size--;",
            "     }",
            "",
            "   }",
            "",
            "   print() {",
            "     return this.queue;",
            "   }",
            "",
            "",
            "   enqueue(item) {",
            "    // 请在本行下方输入代码",
            "",
            "    // 请在本行上方输入代码",
            "   }",
            "",
            "   dequeue() {",
            "    // 请在本行下方输入代码",
            "",
            "    // 请在本行上方输入代码",
            "   }",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "8d1323c8c441eddfaeb5bdef",
      "title": "Create a Set Class",
      "description": [
        "在接下来的几个章节里面我们会通过创建一个函数来模拟 “集合” 这种数据结构。集合跟数组很类似，但是集合中元素具有唯一性。集合的典型应用是检查其中是否存在某一元素。这种应用可以通过对象来实现，举例如下：",
        "<blockquote>var set = new Object();<br>set.foo = true;<br>// See if foo exists in our set:<br>console.log(set.foo) // true</blockquote>",
        "在接下来的几个联系当中，我们会从零开始创建一个拥有完整特性的集合。",
        "在本次联系中，当中集合不存在某个元素时我们会将该元素添加进 set 集合当中，例子如下：",
        "<blockquote>this.add = function(element) {<br>  //some code to add value to the set<br>}</blockquote>",
        "当成功添加元素时函数会返回<code>true</code>，否则会返回<code>false</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>类应该具有<code>add</code>方法。",
          "testString": "assert((function(){var test = new Set(); return (typeof test.add === 'function')}()), 'Your <code>Set</code> class should have an <code>add</code> method.');"
        },
        {
          "text": "<code>add</code>方法不能添加重复值。",
          "testString": "assert((function(){var test = new Set(); test.add('a'); test.add('b'); test.add('a'); var vals = test.values(); return (vals[0] === 'a' && vals[1] === 'b' && vals.length === 2)}()), 'Your <code>add</code> method should not add duplicate values.');"
        },
        {
          "text": "当成功添加元素时<code>add</code>方法应该返回<code>true</code>。",
          "testString": "assert((function(){var test = new Set(); var result = test.add('a'); return (result != undefined) && (result === true);}()), 'Your <code>add</code> method should return <code>true</code> when a value has been successfully added.');"
        },
        {
          "text": "当添加重复元素时<code>add</code>方法应该返回<code>false</code>。",
          "testString": "assert((function(){var test = new Set(); test.add('a'); var result = test.add('a'); return (result != undefined) && (result === false);}()), 'Your <code>add</code> method should return <code>false</code> when a duplicate value is added.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false ",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8253367417b2b2512c6b",
      "title": "Remove from a Set",
      "description": [
        "在本次练习当中我们来为 set 集合创建一个 delete 函数。该函数应该被命名为<code>this.remove</code>。该函数接收一个值并判断该值在集合中是否存在，如何存在就从集合中移除该元素并返回 true 否则就返回 false 。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>类应该有<code>remove</code>方法。",
          "testString": "assert((function(){var test = new Set(); return (typeof test.remove === 'function')}()), 'Your <code>Set</code> class should have a <code>remove</code> method.');"
        },
        {
          "text": "<code>remove</code>方法应该只移除集合中存在的元素。",
          "testString": "assert.deepEqual((function(){var test = new Set(); test.add('a');test.add('b');test.remove('c'); return test.values(); })(), ['a', 'b'], 'Your <code>remove</code> method should only remove items that are present in the set.');"
        },
        {
          "text": "<code>remove</code>方法应该移除集合中的指定值。",
          "testString": "assert((function(){var test = new Set(); test.add('a');test.add('b');test.remove('a'); var vals = test.values(); return (vals[0] === 'b' && vals.length === 1)}()), 'Your <code>remove</code> method should remove the given item from the set.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false ",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会添加 element 元素到集合当中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "8d1923c8c441eddfaeb5bdef",
      "title": "Size of the Set",
      "description": [
        "在本次练习当中我们会为 Set 集合创建一个 size 函数。该函数应该被命名为<code>this.size</code>并该函数会返回集合的长度。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>类应该有<code>size</code>方法。",
          "testString": "assert((function(){var test = new Set(); return (typeof test.size === 'function')}()), 'Your <code>Set</code> class should have a <code>size</code> method.');"
        },
        {
          "text": "<code>size</code>应该返回集合中元素的个数。",
          "testString": "assert((function(){var test = new Set(); test.add('a');test.add('b');test.remove('a');return (test.size() === 1)}()), 'The <code>size</code> method should return the number of elements in the collection.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false ",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会添加 element 元素到集合当中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8253367417b2b2512c6c",
      "title": "Perform a Union on Two Sets",
      "description": [
        "在本次练习当中我们来合并两个集合当中的元素。我们会在<code>Set</code>数据结构当中创建<code>union</code>方法。该方法将<code>Set</code>作为参数并返回两个集合的合集，并且其中的元素具有唯一性。",
        "举个栗子，集合<code>setA = ['a','b','c']</code>和集合<code>setB = ['a','b','d','e']</code>合并之后的集合为：<code>setA.union(setB) = ['a', 'b', 'c', 'd', 'e']</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>类应该有<code>union</code>方法。",
          "testString": "assert((function(){var test = new Set(); return (typeof test.union === 'function')})(), 'Your <code>Set</code> class should have a <code>union</code> method.');"
        },
        {
          "text": "返回了正确的集合结果。",
          "testString": "assert((function(){var setA = new Set();  var setB = new Set();  setA.add('a');  setA.add('b');  setA.add('c');  setB.add('c');  setB.add('d');  var unionSetAB = setA.union(setB); var final = unionSetAB.values(); return (final.indexOf('a') !== -1 && final.indexOf('b') !== -1 && final.indexOf('c') !== -1 && final.indexOf('d') !== -1 && final.length === 4)})(), '返回了正确的集合结果。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};this.union = function(set) {var u = new Set();var c = this.values();var s = set.values();c.forEach(function(element){u.add(element);});s.forEach(function(element){u.add(element);});return u;};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会添加 element 元素到集合当中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "   // 该方法从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法返回集合长度",
            "    this.size = function() {",
            "        return collection.length;",
            "    };",
            "    // 请在本行下方输入代码",
            "",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8253367417b2b2512c6d",
      "title": "Perform an Intersection on Two Sets of Data",
      "description": [
        "在本次练习当中我们要计算出两个的并集。我们会在<code>Set</code>数据结构中写一个<code>intersection</code>方法。并集是两个或者多个 set 共同拥有的元素的集合。该方法应该接收<code>Set</code>作为参数并返回两个集合的并集。",
        "举个栗子，集合<code>setA = ['a','b','c']</code>和集合<code>setB = ['a','b','d','e']</code>的并集计算结果为：<code>setA.intersection(setB) = ['a', 'b']</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>类应该有<code>intersection</code>方法。",
          "testString": "assert(function(){var test = new Set(); return (typeof test.intersection === 'function')}, 'Your <code>Set</code> class should have a <code>intersection</code> method.');"
        },
        {
          "text": "返回了正确的集合结果。",
          "testString": "assert(function(){  var setA = new Set();  var setB = new Set();  setA.add('a');  setA.add('b');  setA.add('c');  setB.add('c');  setB.add('d');  var intersectionSetAB = setA.intersection(setB); return (intersectionSetAB.size() === 1 && intersectionSetAB.values()[0] === 'c')}, '返回了正确的集合结果。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};this.union = function(set) {var u = new Set();var c = this.values();var s = set.values();c.forEach(function(element){u.add(element);});s.forEach(function(element){u.add(element);});return u;};this.intersection = function(set) {var i = new Set();var c = this.values();c.forEach(function(element){if(s.has(element)) i.add(element);});};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "   // 该方法会添加 element 元素到集合当中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法返回集合长度",
            "    this.size = function() {",
            "        return collection.length;",
            "    };",
            "    // 该方法返回两个集合的并集",
            "    this.union = function(otherSet) {",
            "        var unionSet = new Set();",
            "        var firstSet = this.values();",
            "        var secondSet = otherSet.values();",
            "        firstSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        secondSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        return unionSet;",
            "    };",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8254367417b2b2512c6e",
      "title": "Perform a Difference on Two Sets of Data",
      "description": [
        "在本次练习当中我们来比较两个集合中元素的不同。我们在<code>Set</code>数据结构当中创建<code>difference</code>方法。两个集合差集的概念为：在第一个集合中存在而第二个集合不存在的元素的集合。该方法应该接收<code>Set</code>作为参数并且返回两个集合的差集。",
        "举个栗子，集合<code>setA = ['a','b','c']</code>与<code>setB = ['a','b','d','e']</code>的差集比较结果为：<code>setA.difference(setB) = ['c']</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>类应该有<code>difference</code>方法。",
          "testString": "assert(function(){var test = new Set(); return (typeof test.difference === 'function')}, 'Your <code>Set</code> class should have a <code>difference</code> method.');"
        },
        {
          "text": "返回了正确的集合结果。",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setA.add('b'); setA.add('c'); setB.add('c'); setB.add('d'); var differenceSetAB = setA.difference(setB); return (differenceSetAB.size() === 2) && (differenceSetAB.values() === [ 'a', 'b' ])}, '返回了正确的集合结果。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};this.union = function(set) {var u = new Set();var c = this.values();var s = set.values();c.forEach(function(element){u.add(element);});s.forEach(function(element){u.add(element);});return u;};this.intersection = function(set) {var i = new Set();var c = this.values();c.forEach(function(element){if(s.has(element)) i.add(element);});};this.difference = function(set) {var d = new Set();var c = this.values();c.forEach(function(e){if(!set.has(e)) d.add(e);});};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会添加 element 元素到集合当中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法返回集合长度",
            "    this.size = function() {",
            "        return collection.length;",
            "    };",
            "    // 该方法会返回两个集合的并集",
            "    this.union = function(otherSet) {",
            "        var unionSet = new Set();",
            "        var firstSet = this.values();",
            "        var secondSet = otherSet.values();",
            "        firstSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        secondSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        return unionSet;",
            "    };",
            "    // 该方法会返回两个集合的交集",
            "    this.intersection = function(otherSet) {",
            "        var intersectionSet = new Set();",
            "        var firstSet = this.values();",
            "        firstSet.forEach(function(e){",
            "            if(otherSet.has(e)){",
            "                intersectionSet.add(e);",
            "            }",
            "        });",
            "        return intersectionSet;",
            "    };",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8254367417b2b2512c6f",
      "title": "Perform a Subset Check on Two Sets of Data",
      "description": [
        "在本次练习中我们将对两个集合元素做子集测试。我们会为<code>Set</code>数据结构创建<code>subset</code>方法。第一个集合会与第二个集合做对比，如何第二个集合完全包含第一个集合该方法会返回 true 。",
        "举个栗子，假设有集合<code>setA = ['a','b']</code>与<code>setB = ['a','b','c','d']</code>，那么<code>setA.subset(setB)</code>的运算结果应该为<code>true</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>类应该有<code>union</code>方法。",
          "testString": "assert(function(){var test = new Set(); return (typeof test.subset === 'function')}, 'Your <code>Set</code> class should have a <code>union</code> method.');"
        },
        {
          "text": "第二个集合完全包含第一个集合。",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setB.add('b'); setB.add('c'); setB.add('a'); setB.add('d'); var subsetSetAB = setA.subset(setB);return (subsetSetAB === true)}, 'The first Set() was contained in the second Set');"
        },
        {
          "text": "<code>['a', 'b'].subset(['a', 'b', 'c', 'd'])</code>运算应该返回<code>true</code>\")",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setA.add('b'); setB.add('a'); setB.add('b'); setB.add('c'); setB.add('d'); var subsetSetAB = setA.subset(setB); return (subsetSetAB === true)}, \"<code>['a', 'b'].subset(['a', 'b', 'c', 'd'])</code> should return <code>true</code>\");"
        },
        {
          "text": "<code>['a', 'b', 'c'].subset(['a', 'b'])</code>运算应该返回<code>false</code>\")",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setA.add('b'); setA.add('c'); setB.add('a'); setB.add('b'); var subsetSetAB = setA.subset(setB); return (subsetSetAB === false)}, \"<code>['a', 'b', 'c'].subset(['a', 'b'])</code> should return <code>false</code>\");"
        },
        {
          "text": "<code>[].subset([])</code>运算应该返回<code>true</code>",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); var subsetSetAB = setA.subset(setB); return (subsetSetAB === true)}, '<code>[].subset([])</code> should return <code>true</code>');"
        },
        {
          "text": "<code>['a', 'b'].subset(['c', 'd'])</code>运算应该返回<code>false</code>\")",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setA.add('b'); setB.add('c'); setB.add('d'); var subsetSetAB = setA.subset(setB); return (subsetSetAB === false)}, \"<code>['a', 'b'].subset(['c', 'd'])</code> should return <code>false</code>\");"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};this.union = function(set) {var u = new Set();var c = this.values();var s = set.values();c.forEach(function(element){u.add(element);});s.forEach(function(element){u.add(element);});return u;};this.intersection = function(set) {var i = new Set();var c = this.values();c.forEach(function(element){if(s.has(element)) i.add(element);});};this.difference = function(set) {var d = new Set();var c = this.values();c.forEach(function(e){if(!set.has(e)) d.add(e);});};this.subset = function(set) {var isSubset = true;var c = this.values();c.forEach(function(e){if(!set.has(e)) isSubset = false;});return isSubset;};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会添加 element 元素到集合当中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法返回集合长度",
            "    this.size = function() {",
            "        return collection.length;",
            "    };",
            "    // 该方法会返回两个集合的并集",
            "    this.union = function(otherSet) {",
            "        var unionSet = new Set();",
            "        var firstSet = this.values();",
            "        var secondSet = otherSet.values();",
            "        firstSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        secondSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        return unionSet;",
            "    };",
            "    // 该方法会返回两个集合的交集",
            "    this.intersection = function(otherSet) {",
            "        var intersectionSet = new Set();",
            "        var firstSet = this.values();",
            "        firstSet.forEach(function(e){",
            "            if(otherSet.has(e)){",
            "                intersectionSet.add(e);",
            "            }",
            "        });",
            "        return intersectionSet;",
            "    };",
            "    // 该方法会返回两个集合的差集",
            "    this.difference = function(otherSet) {",
            "        var differenceSet = new Set();",
            "        var firstSet = this.values();",
            "        firstSet.forEach(function(e){",
            "            if(!otherSet.has(e)){",
            "                differenceSet.add(e);",
            "            }",
            "        });",
            "        return differenceSet;",
            "    };",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8254367417b2b2512c70",
      "title": "Create and Add to Sets in ES6",
      "description": [
        "现在我们已经通关了ES5，接下来我们要在ES6当中做一些类似的操作。这些操作会更加的简单。ES6当中的<code>Set</code>数据结构内置了很多以前需要自己主动编写方法。现在我们一起来看看这些方法：",
        "创建一个空 set ",
        "<code>var set = new Set();</code>",
        "创建带有一个值的 set ",
        "<code>var set = new Set(1);</code>",
        "通过数组参数来创建一个 set ",
        "<code>var set = new Set([1, 2, 3]);</code>",
        "创建好数组之后可以通过<code>add</code>方法添加元素：",
        "<blockquote>var set = new Set([1, 2, 3]);<br>set.add([4, 5, 6]);</blockquote>",
        "提醒一下，set 这种数据结构当中不允许出现重复元素：",
        "<blockquote>var set = new Set([1, 2, 3, 1, 2, 3]);<br>// set contains [1, 2, 3] only</blockquote>",
        "<hr>",
        "本次练习的返回结果应该是：<code>1, 2, 3, 'Taco', 'Cat', 'Awesome'</code>"
      ],
      "tests": [
        {
          "text": "<code>Set</code>应该只包含<code>1, 2, 3, Taco, Cat, Awesome</code>这些元素。",
          "testString": "assert(function(){var test = checkSet(); return (test.size == 6) && test.has(1) && test.has(2) && test.has(3) && test.has('Taco') && test.has('Cat') && test.has('Awesome');}, 'Your <code>Set</code> should only contain the values <code>1, 2, 3, Taco, Cat, Awesome</code>.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function checkSet(){var set = new Set([1,2,3,'Taco','Cat','Awesome']);\nreturn set;}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function checkSet() {",
            "  var set = new Set([1, 2, 3, 3, 2, 1, 2, 3, 1]);",
            "  // 请在本行下方输入代码",
            "  ",
            "  // 请在本行上方输入代码",
            "  console.log(set);",
            "  return set;",
            "}",
            "",
            "checkSet();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8254367417b2b2512c71",
      "title": "Remove items from a set in ES6",
      "description": [
        "现在练习使用code>delete</code>方法从 ES6 Set 当中移除元素。",
        "首先，创建一个 ES6 Set",
        "<code>var set = new Set([1,2,3]);</code>",
        "使用<code>delete</code>方法从 Set 当中移除一个元素。",
        "<blockquote>set.delete(1);<br>console.log([...set]) // should return [ 2, 3 ]<blockquote>",
        "<hr>",
        "现在创建一个拥有 1, 2, 3, 4, & 5 这些整数的 set 。移除元素 2 和 5 并返回该 set 。"
      ],
      "tests": [
        {
          "text": "Set 应该返回1, 3, & 4 。",
          "testString": "assert(function(){var test = checkSet(); return test.has(1) && test.has(3) && test.has(4) && test.size === 3}, 'Your Set should contain the values 1, 3, & 4');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function checkSet(){\nvar set = new Set([1,2,3,4,5]);\nset.delete(2);\nset.delete(5);\nreturn set;}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function checkSet(){",
            "   var set = //创建带有 1, 2, 3, 4, & 5 这 5 个整数的 set ",
            "   //移除 2 这个值",
            "   //移除 5 这个值",
            "   //返回 set ",
            "   return set;",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8255367417b2b2512c72",
      "title": "Use .has and .size on an ES6 Set",
      "description": [
        "现在我们来学习 ES6 Set 对象的 .has 和 .size 方法。",
        "首先，创建一个 ES6 Set ",
        "<code>var set = new Set([1,2,3]);</code>",
        " .has 方法会检查 set 当中是否有某个值。",
        "<code>var hasTwo = set.has(2);</code>",
        " .size 会返回 Set 的长度。",
        "<code>var howBig = set.size;</code>",
        "<hr>",
        "在本次练习当中我们会给 checkSet() 函数一个 array 和一个 value 。该函数应该根据传入的参数创建一个 ES6 set 。函数会检查该 set 中是否存在该 value 值，同时检测该 set 的长度。函数会以数组形式返回这两个检查结果。"
      ],
      "tests": [
        {
          "text": "<code>checkSet([4, 5, 6], 3)</code>应该返回 [ false, 3 ]",
          "testString": "assert(function(){var test = checkSet([4,5,6], 3); test === [ false, 3 ]}, '<code>checkSet([4, 5, 6], 3)</code> should return [ false, 3 ]');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function checkSet(arrToBeSet, checkValue){\nvar set = new Set(arrToBeSet);\nvar result = [\nset.has(checkValue),\nset.size\n];\nreturn result;\n}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function checkSet(arrToBeSet, checkValue){",
            "",
            "   // 请在本行下方输入代码",
            "",
            "   // 请在本行上方输入代码",
            "",
            "}",
            "",
            "checkSet([ 1, 2, 3], 2); // Should return [ true, 3 ]"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8255367417b2b2512c73",
      "title": "Use Spread and Notes for ES5 Set() Integration",
      "description": [
        "是否记得 ES6 当中的<code>...</code>操作符？",
        "<code>...</code>接收 ES6 当中的可迭代对象并将其转换为数组返回。",
        "现在我们来创建一个 Set并检验<code>...</code>操作符。",
        "<blockquote>var set = new Set([1,2,3]);<br>var setToArr = [...set]<br>console.log(setToArr) // returns [ 1, 2, 3 ]</blockquote>",
        "<hr>",
        "在本次练习当中我们给<code>checkSet</code>传递一个 set 对象。函数返回一个数组，该数组当中包含 Set 集合中所有值。",
        "现在我们已经学会了如何运用 ES6 <code>Set()</code>对象，继续加油！"
      ],
      "tests": [
        {
          "text": " Set 内的值正确返回了！",
          "testString": "assert(function(){var test = checkSet(new Set([1,2,3,4,5,6,7])); test === [ 1, 2, 3, 4, 5, 6, 7 ]}, 'Your Set was returned correctly!');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function checkSet(set){\nreturn [...set];}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function checkSet(set){",
            "   // 请在本行下方输入代码",
            "",
            "   // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "8d5823c8c441eddfaeb5bdef",
      "title": "Create a Map Data Structure",
      "description": [
        "在接下来的几个挑战会涉及到 map 和 hash 表这些知识点。Maps 是一种存储键值对的数据结构。map 也是一种 JavaScript 对象。Maps 是一种十分通用和有效的数据结构，我们在 Maps 当中通过 key 值能够很快速地获取对应的 value 值。",
        "提示：现在我们练习创建 map。JavaScript 对象本身提供了十分高效的 map 数据结构，我们在本次挑战当中写的一些方法只是作为提升练习。然而，JavaScript 对象本身只为我们提供了少量操作方法，如果我们想要自己定制一些方法该怎么办呢？",
        "现在我们使用 JavaScript 对象来模拟<code>Map</code>对象。现在我们在 Map 对象当中创建下列方法：",
        "<code>add</code>方法接收<code>key, value</code>作为参数并添加进 map 当中",
        "<code>remove</code>方法接收一个 key 值并移除对应的<code>key, value</code>",
        "<code>get</code>接收<code>key</code>值并返回对应的<code>value</code>值",
        "<code>has</code>方法根据某个值的存在情况返回相应的<code>boolean</code>值",
        "<code>values</code>方法以数组形式返回 map 当中所有的 value 值",
        "<code>size</code>方法返回 map 当中元素的个数",
        "<code>clear</code> empties the map"
      ],
      "tests": [
        {
          "text": "Map 数据结构存在。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; return (typeof test == 'object')})(), 'The Map data structure exists.');"
        },
        {
          "text": "Map 对象拥有 add, remove, get, has, values, clear, and size 这些方法。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; return (typeof test.add == 'function' && typeof test.remove == 'function' && typeof test.get == 'function' && typeof test.has == 'function' && typeof test.values == 'function' && typeof test.clear == 'function' && typeof test.size == 'function')})(), 'The Map object has the following methods: add, remove, get, has, values, clear, and size.');"
        },
        {
          "text": "add 方法添加元素到 map 当中。 ",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add(5,6); test.add(2,3); test.add(2,5); return (test.size() == 2)})(), 'The add method adds items to the map.');"
        },
        {
          "text": "当存在某个元素时 has 方法会返回 true 否则返回 false。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add('test','value'); return (test.has('test') && !test.has('false'))})(), 'The has method returns true for added items and false for absent items.');"
        },
        {
          "text": "get 方法接收 key 值作为参数并返回对应的 value 值。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add('abc','def'); return (test.get('abc') == 'def')})(), 'The get method accepts keys as input and returns the associated values.');"
        },
        {
          "text": "values 方法以数组形式返回 map 当中所有的 value 值。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add('a','b'); test.add('c','d'); test.add('e','f'); var vals = test.values(); return (vals.indexOf('b') != -1 && vals.indexOf('d') != -1 && vals.indexOf('f') != -1)})(), 'The values method returns all the values stored in the map as strings in an array.');"
        },
        {
          "text": "clear 方法清空 map 当中的元素，size 方法返回 map 当中元素的个数。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add('b','b'); test.add('c','d'); test.remove('asdfas'); var init = test.size(); test.clear(); return (init == 2 && test.size() == 0)})(), 'The clear method empties the map and the size method returns the number of items present in the map.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var Map = function() {",
            "  this.collection = {};",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825b367417b2b2512c8d",
      "title": "Create an ES6 JavaScript Map",
      "description": [
        "新版JavaScript给我们提供了内置的 Map 对象，该 Map 对象提供了大部分在上一次挑战中需要我们手动书写的内容。虽然与一般的 JavaScript 对象很类似，但是 Map 对象也提供了一些普通对象没有的方法。例如，ES6 Map 追溯刚刚添加进 Map 的元素顺序。下面是 Map 内置方法的一个概览：",
        "<code>.has(key)</code>根据 key 值存在与否返回 true 或 false ",
        "<code>.get(key)</code>返回 key 值对应的 value 值",
        "<code>.set(key, value)</code>设置一对新的 key,value 对",
        "<code>.delete(key)</code>移除一个 key,value 对",
        "<code>.clear()</code>移除所有的 key,value 对",
        "<code>.entries()</code>以数组形式返回所有 key 值，数组中元素的顺序以插入时的顺序为准",
        "<code>.values()</code>i以数组形式返回所有 value 值，数组中元素的顺序以插入时的顺序为准",
        "任务：定义一个 Map 对象并将其赋值给一个名称为 myMap 的变量。往 Map 对象当中添加键值对<code>freeCodeCamp</code>, <code>Awesome!</code>。"
      ],
      "tests": [
        {
          "text": "myMap 对象存在。",
          "testString": "assert(typeof myMap === 'object', 'The myMap object exists.');"
        },
        {
          "text": "myMap 包含键值对<code>freeCodeCamp</code>, <code>Awesome!</code>。",
          "testString": "assert(myMap.get('freeCodeCamp') === 'Awesome!', 'myMap contains the key value pair <code>freeCodeCamp</code>, <code>Awesome!</code>.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// 请在本行下方输入代码"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825b367417b2b2512c8e",
      "title": "Create a Hash Table",
      "description": [
        "在本次挑战中我们会学习 hash 表。就像我们之前学习的对象和 Map 一样，hash 通常用来实现关联数组或者匹配键值对。比如，可以用 JavaScript 对象来实现 hash 表（具体实现方式依赖于运行环境）。hash 表接收一个 key 值作为参数并将其数字化为一个确定的数字。该数字被当作与 value 值对应的 key 值存储到表当中。如果你想取得该 key 值的话，hashing 函数会接收 key 值作为参数经过运算之后返回同样的数字（该数字被用来取得关联的 value 值）。这种方式非常高效，平均时间复杂度为 O(n)。",
        "可以用数组来实现 hash 表，该数组拥有一个 hash 函数，该函数在指定的区间内生成一系列索引。在本方法中，数组的大小以及 hash 函数的选择很关键。例如，假如两个不同的 key 值通过 hash 函数产生了相同的值怎么办？这种情况我们叫做冲突。解决冲突的一种方式是将两对 key-value 都存储进该 index 当中。之后在存储元素的单元格当中逐个寻找。好的 hash 函数能够最小化冲突以保证查询效率。",
        "本课程我们不关注 hash 化或者 hash 表的实现细节，只是熟悉一下他们怎么运作。",
        "任务：现在我们来创建一个拥有基本功能的 hash 表。我们已经为你创建了一个简单的 hash 函数，当你传递一个值给该函数时它会返回一个 hash 化的值让你当作 key 值使用。将元素存储到 this.collection 对象当中，在其中创建 add,remove 以及 lookup 这三个方法。add 方法接收一个键值对参数并存储进 hash 表当中；remove 方法接收一个 key 值并移除对应的键值对；lookup 方法接收一个 key 值并返回对应的 value 值，如果 key 值不存在的话就返回 null。",
        "确保你的代码能处理发生冲突的情况！"
      ],
      "tests": [
        {
          "text": "该 HashTable 数据结构存在。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; return (typeof test === 'object')})(), 'The HashTable data structure exists.');"
        },
        {
          "text": "该 HashTable 拥有 add 方法。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; return ((typeof test.add) === 'function')})(), 'The HashTable has an add method.');"
        },
        {
          "text": "该 HashTable 拥有 remove 方法。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; return ((typeof test.remove) === 'function')})(), 'The HashTable has an remove method.');"
        },
        {
          "text": "该 HashTable 拥有 lookup 方法。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; return ((typeof test.lookup) === 'function')})(), 'The HashTable has an lookup method.');"
        },
        {
          "text": "add 方法添加 键值对到 HashTable 当中，lookup 方法根据传入 key 值返回对应的 value 值。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; test.add('key', 'value'); return (test.lookup('key') === 'value')})(), 'The add method adds key value pairs and the lookup method returns the values associated with a given key.');"
        },
        {
          "text": "remove 方法接收 key 值为参数并删除对应的键值对。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; test.add('key', 'value'); test.remove('key'); return (test.lookup('key') === null)})(), 'The remove method accepts a key as input and removes the associated key value pair.');"
        },
        {
          "text": "使用 hash 函数把元素添加进 HashTable。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; called = 0; test.add('key1','value1'); test.add('key2','value2'); test.add('key3','value3'); return (called === 3)})(), 'Items are added using the hash function.');"
        },
        {
          "text": "该 HashTable 解决了冲突。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; called = 0; test.add('key1','value1'); test.add('1key','value2'); test.add('ke1y','value3'); return (test.lookup('key1') === 'value1' && test.lookup('1key') == 'value2' && test.lookup('ke1y') == 'value3')})(), 'The hash table handles collisions.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var called = 0;",
            "var hash = (string) => {",
            "  called++;",
            "  var hash = 0;",
            "  for (var i = 0; i < string.length; i++) { hash += string.charCodeAt(i); }",
            "  return hash;",
            "};",
            "var HashTable = function() {",
            "  this.collection = {};",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [
            "  var called = 0;",
            "    var hash = (string) => {",
            "     called++;",
            "      var hash = 0;",
            "      for (var i = 0; i < string.length; i++) { hash += string.charCodeAt(i); };",
            "      return hash;",
            "    };"
          ],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c61",
      "title": "Work with Nodes in a Linked List",
      "description": [
        "另一个计算机科学当中比较常见的数据结构是链表。链表是一系列数据元素的线性集合，每个节点有一个指针指向下一个节点。链表中的每个节点由两部分组成：一个是<code>element</code>本身，还有一个指向下一个<code>node</code>的引用。",
        "想象你在一个舞队当中，你的手搭在下一个人身上，你后面人的手搭在你的身上。你可以看到你前面的人是谁，但是看不到再之前的人。一个节点就如同一个舞队当中的一个人：他们能够掌握行列当中自己和下一个人的信息，但是他们无法知道他们之前或者之后的人是谁。",
        "<hr>",
        "在代码编辑器当中我们已经创建了<code>Kitten</code>和<code>Puppy</code>两个节点，现在我们已经将<code>Kitten</code>节点和<code>Puppy</code>节点连接起来了。",
        "创建<code>Cat</code>和<code>Dog</code>两个节点并将他们连接到链表当中。"
      ],
      "tests": [
        {
          "text": "<code>Puppy</code>节点应该有指向<code>Cat</code>节点的引用。",
          "testString": "assert(Puppy.next.element === \"Cat\", 'Your <code>Puppy</code> node should have a reference to a <code>Cat</code> node.');"
        },
        {
          "text": "<code>Cat</code>节点应该有指向<code>Dog</code>节点的引用。",
          "testString": "assert(Cat.next.element === \"Dog\", 'Your <code>Cat</code> node should have a reference to a <code>Dog</code> node.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var Node = function(element){",
            "    this.element = element; ",
            "    this.next = null; ",
            "};",
            "var Kitten = new Node(\"Kitten\");",
            "var Puppy = new Node(\"Puppy\");",
            "",
            "Kitten.next = Puppy;",
            "// 请在本行下方输入代码",
            "",
            "// 测试代码",
            "console.log(Kitten.next);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c62",
      "title": "Create a Linked List Class",
      "description": [
        "现在我们来创建一个<code>linked list</code>类。每个链表都应该有<code>head</code>（表中第一个元素）和<code>length</code>（表中元素的个数）这样的基本属性。有时链表有<code>tail</code>这样表示表中最后一个元素的标识，但是本次练习我们只关注 head 和 length 这两个属性。无论何时我们往链表中添加了元素，<code>length</code>属性的数值都会加一。",
        "我们需要有一个能够添加元素进链表的操作，因此我们首先创建一个<code>add</code>方法。",
        "如果表为空，添加元素进链表会很简单：我们只需用<code>Node</code>类来创建一个元素，同时让<code>head</code>指向该元素。",
        "但是如果表中已经有元素了会是如何呢？如何添加元素到非空链表当中？回想一下，链表当中的每个元素都有一个<code>next</code>属性。为了添加新节点到表中我们需要找到表中最后一个节点，并让该节点的<code>next</code>指针指向新节点。（提示：链表当中最后一个元素的 next 指针指向 null。）",
        "<hr>",
        "写一个 add 方法，当添加第一个元素时让<code>head</code>指针指向该元素；之后，当在添加新元素时前一个节点的<code>next</code>属性都应该指向下一个元素。",
        "提示",
        "每当链表添加进新元素的时候<code>length</code>的数值都应该加一。"
      ],
      "tests": [
        {
          "text": "<code>LinkedList</code>应该有<code>add</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.add === 'function')}()), 'Your <code>LinkedList</code> class should have a <code>add</code> method.');"
        },
        {
          "text": "<code>LinkedList</code>当中的<code>head</code>指针应该指向表中第一个元素。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); return test.head().element === 'cat'}()), 'Your <code>LinkedList</code> class should assign <code>head</code> to the first node added.');"
        },
        {
          "text": "LinkedList</code>当中的节点应该有指针指向最新创建的节点。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); return test.head().next.element === 'dog'}()), 'The previous <code>node</code> in your <code>LinkedList</code> class should have reference to the newest node created.');"
        },
        {
          "text": "<code>size</code>代表<code>LinkedList</code>当中节点的数量。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); return test.size() === 2}()), 'The  <code>size</code> of your <code>LinkedList</code> class should equal the amount of nodes in the linked list.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.size = function(){",
            "    return length;",
            "  };",
            "",
            "  this.add = function(element){",
            "    // Only 请在本行下方输入代码",
            "",
            "    // Only 请在本行上方输入代码",
            "  };",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c63",
      "title": "Remove Elements from a Linked List",
      "description": [
        "链表当中下一个重要的方法是<code>remove</code>方法。该方法接收一个元素作为参数，随后在链表当中找到并移除该元素。",
        "当从链表当中移除掉一个节点之后，需要注意到我们并不只是从链表当中删除了一个元素。每个节点的<code>next</code>指针都会指向表中的下一个节点。当我们从链表当中移除了一个元素时，我们需要确保这个被移除节点的前一个节点的<code>next</code>指针指向被移除节点的下一个元素。",
        "这样解释可能比较抽象，因此我们再拿之前的康茄舞队的例子来说明。想象一下，康茄舞队当中在你正前方的人离开了队伍。这个离队的人也就不再会把手搭在他前一个人的身上，同时你的手也不可能搭在离队的那个人身上。接下来你需要向前走一步把你的手搭在前一个人的身上。",
        "如果我们移除的是头部元素，那么我们需要让<code>head</code>指针指向链表当中的第二个元素。",
        "<hr>",
        "编写<code>remove</code>方法，该方法接收一个元素作为参数并从链表当中移除该元素。",
        "提示",
        "每当<code>length</code> of the list should decrease by one every time an element is removed from the linked list."
      ],
      "tests": [
        {
          "text": "<code>LinkedList</code>应该又一个<code>remove</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.remove === 'function')}()), 'Your <code>LinkedList</code> class should have a <code>remove</code> method.');"
        },
        {
          "text": "当链表头部元素被移除时<code>remove</code>方法应该让<code>head</code>指针指向表中的第二个元素。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.remove('cat'); return test.head().element === 'dog'}()), 'Your <code>remove</code> method should reassign <code>head</code> to the second node when the first node is removed.');"
        },
        {
          "text": "每当元素被移除时<code>remove</code>方法应该让<code>length</code>减 1 。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.remove('cat'); return test.size() === 1})(), 'Your <code>remove</code> method should decrease the <code>length</code> of the linked list by one for every node removed.');"
        },
        {
          "text": "当一个元素被移除时<code>remove</code>方法应该让被移除元素的前一个元素的<code>next</code>指针指向被移除元素的下一个元素。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog');test.add('kitten'); test.remove('dog'); return test.head().next.element === 'kitten'})(), 'Your <code>remove</code> method should reassign the reference of the previous node of the removed node to the removed node&apos;s <code>next</code> reference.');"
        }
      ],
      "solutions": [
        "class Node {\n  constructor (element) {\n    this.element = element;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor () {\n    this._length = 0;\n    this._head = null;\n  }\n\n  head () {\n    return this._head;\n  }\n\n  size () {\n    return this._length;\n  }\n\n  add (element) {\n    const node = new Node(element);\n\n    if (this._head === null) {\n      this._head = node;\n    } else {\n      let current = this._head;\n\n      while (current.next !== null) {\n        current = current.next;\n      }\n\n      current.next = node; \n    }\n    \n    ++this._length;\n  }\n  \n  remove (element) {\n    if (this._head === null) return;\n    \n    let previous;\n    let current = this._head;\n    \n    while (current.next !== null && current.element !== element) {\n      previous = current;\n      current = current.next;\n    }\n    \n    if (previous) {\n      previous.next = current.next;\n    } else {\n      this._head = current.next;\n    }\n    \n    --this._length;\n  }\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){ ",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.size = function(){",
            "    return length;",
            "  };",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.add = function(element){",
            "    var node = new Node(element);",
            "    if(head === null){",
            "        head = node;",
            "    } else {",
            "        currentNode = head;",
            "",
            "        while(currentNode.next){",
            "            currentNode  = currentNode.next;",
            "        }",
            "",
            "        currentNode.next = node;",
            "    }",
            "",
            "    length++;",
            "  }; ",
            "",
            "  this.remove = function(element){",
            "    // Only 请在本行下方输入代码",
            "",
            "    // Only 请在本行上方输入代码",
            "  };",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c64",
      "title": "Search within a Linked List",
      "description": [
        "现在我们往链表当中添加一些更加实用的方法。例如我们可以像<code>Stack</code>和<code>Queue</code>一样设计一个判断链表是否为空的方法。",
        "我们也应该能够找到链表当中某一个具体的元素。通过学习这些数据结构我们能够积累很多经验。现在我们来创建一个<code>indexOf</code>方法，该方法接收一个<code>element</code>作为参数并返回该元素在链表当中的索引值。如果该元素不存在就返回<code>-1</code>。",
        "我们也可以编写一个方法来实现相反的功能：<code>elementAt</code>方法接收一个<code>index</code>作为索引值并返回对应位置的<code>element</code>。如果<code>element</code>没找到就返回<code>undefined</code>。",
        "<hr>",
        "编写<code>isEmpty</code>方法来判断链表是否为空，<code>indexOf</code>方法返回给定元素的<code>index</code>值，<code>elementAt</code>方法返回给定位置的<code>element</code>值。"
      ],
      "tests": [
        {
          "text": "、<code>LinkedList</code>应该有<code>indexOf</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.indexOf === 'function')}()), 'Your <code>LinkedList</code> class should have a <code>indexOf</code> method.');"
        },
        {
          "text": "<code>LinkedList</code>应该有<code>elementAt</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.elementAt === 'function')}()), 'Your <code>LinkedList</code> class should have a <code>elementAt</code> method.');"
        },
        {
          "text": "<code>size</code>方法应该返回链表的长度。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.size() === 3}()), 'Your <code>size</code> method should return the length of the linked list');"
        },
        {
          "text": "<code>indexOf</code>方法应该返回给定元素的索引值。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.indexOf('kitten') === 2}()), 'Your <code>indexOf</code> method should return the index of the given element.');"
        },
        {
          "text": "<code>elementAt</code>方法应该返回对应位置的元素值。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.elementAt(1) === 'dog'}()), 'Your <code>elementAt</code> method should return at element at a given index.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){ // {1} ",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.size = function() {",
            "    return length;",
            "  };",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.add = function(element){",
            "    var node = new Node(element);",
            "    if(head === null){",
            "        head = node;",
            "    } else {",
            "        currentNode = head;",
            "",
            "        while(currentNode.next){",
            "            currentNode  = currentNode.next;",
            "        }",
            "",
            "        currentNode.next = node;",
            "    }",
            "",
            "    length++;",
            "  }; ",
            "",
            "  this.remove = function(element){",
            "    var currentNode = head;",
            "    var previousNode;",
            "    if(currentNode.element === element){",
            "        head = currentNode.next;",
            "    } else {",
            "        while(currentNode.element !== element) {",
            "            previousNode = currentNode;",
            "            currentNode = currentNode.next;",
            "        }",
            "",
            "        previousNode.next = currentNode.next;",
            "    }",
            "",
            "    length --;",
            "  };",
            "",
            "  // 请在本行下方输入代码",
            "",
            "  // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c65",
      "title": "Remove Elements from a Linked List by Index",
      "description": [
        "在学习其他数据结构之前，我们再在链表里面做两个练习。",
        "我们来编写一个<code>removeAt</code>方法，该方法根据给定的<code>index</code>删除对应位置上的<code>element</code>。我们把这个方法命名为<code>removeAt(index)</code>。为了移除给定位置上的<code>element</code>，我们需要用一个数来记录在链表当中的移动位置。",
        "当遍历链表当中元素时，我们通常使用“哨兵”来指向代码当中正在进行比较的元素。在本例当中，我们从表的头部开始，设置<code>currentIndex</code>的初始值为<code>0</code>，当遍历过一个元素之后<code>currentIndex</code>的值增加一位。",
        "就像<code>remove(element)</code>方法一样，我们并不仅仅是使用 removeAt(index) 方法移除表中的元素。同时我们需要保证被移除元素的前一个元素的 next 指针需要指向被移除元素的下一个元素。",
        "<hr>",
        "编写<code>removeAt(index)</code>方法移除指定位置的节点，同时该方法需要返回被移除的节点。如果<code>index</code>的值为负数或者大于等于链表的长度，该方法应该返回<code>null</code>。",
        "提示",
        "记得跟踪<code>currentIndex</code>的数值变化。"
      ],
      "tests": [
        {
          "text": "链表应该拥有<code>removeAt</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.removeAt === 'function')}()), 'Your <code>LinkedList</code> class should have a <code>removeAt</code> method.');"
        },
        {
          "text": "使用<code>removeAt</code>方法之后链表的长度应该减短。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); test.removeAt(1); return test.size() === 2}()), 'Your <code>removeAt</code> method should reduce the <code>length</code> of the linked list');"
        },
        {
          "text": "<code>removeAt</code>应该返回被移除的那个节点。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten');  return test.removeAt(1) === 'dog'}()), 'Your <code>removeAt</code> method should also return the element of the removed node.');"
        },
        {
          "text": "如果 index 的值小于<code>0</code>，<code>removeAt</code>方法应该返回<code>null</code>。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten');  return (test.removeAt(-1) === null)}()), 'Your <code>removeAt</code> method should also return <code>null</code> if the given index is less than <code>0</code>');"
        },
        {
          "text": "如果 index 的值大于等于链表长度，<code>removeAt</code>方法应该返回<code>null</code>。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten');  return (test.removeAt(3) === null)}()), 'Your <code>removeAt</code> method should also return <code>null</code> if the given index is equal or more than the <code>length</code> of the linked list.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){ // {1} ",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.size = function(){",
            "    return length;",
            "  };",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.add = function(element){",
            "    var node = new Node(element);",
            "    if(head === null){",
            "        head = node;",
            "    } else {",
            "        currentNode = head;",
            "",
            "        while(currentNode.next){",
            "            currentNode  = currentNode.next;",
            "        }",
            "",
            "        currentNode.next = node;",
            "    }",
            "",
            "    length++;",
            "  }; ",
            "",
            "  this.remove = function(element){",
            "    var currentNode = head;",
            "    var previousNode;",
            "    if(currentNode.element === element){",
            "        head = currentNode.next;",
            "    } else {",
            "        while(currentNode.element !== element) {",
            "            previousNode = currentNode;",
            "            currentNode = currentNode.next;",
            "        }",
            "",
            "        previousNode.next = currentNode.next;",
            "    }",
            "",
            "    length --;",
            "  };",
            "",
            "  // Only 请在本行下方输入代码",
            "",
            "  // Only 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8252367417b2b2512c67",
      "title": "Add Elements at a Specific Index in a Linked List",
      "description": [
        "现在我们来创建一个 addAt(index,element) 方法，该方法在指定的位置添加一个元素。",
        "就像我们移除指定位置的元素一样，当我们遍历链表时需要跟踪 currentIndex 的数值变化。当 currentIndex 匹配到给定的 index 值时，我们需要让指定节点的前一个节点指向新添加的节点，之后我们需要让新添加的节点指向指定的节点。",
        "再拿康茄舞举例子，有一个新队员想加入舞队正中的位置。恰巧你就在队伍中央，因此你将手从前一个人的身上拿开了。而新加入的人则将他的手搭到了你先前搭的那个人的身上，之后你需要将你的手搭在新加入队伍的这个人身上。",
        "任务",
        "创建一个 addAt(index,element) 方法，该方法往指定位置添加元素。如果元素未能成功添加则返回 false 。",
        "提示",
        "记得检查 index 的值小于 0 以及大于等于链表长度的情况。"
      ],
      "tests": [
        {
          "text": "当传入的 index 的值为 0 时，<code>addAt</code>方法应该让<code>head</code>指针指向新加入的节点。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.addAt(0,'cat'); return test.head().element === 'cat'}()), 'Your <code>addAt</code> method should reassign <code>head</code> to the new node when the given index is 0.');"
        },
        {
          "text": "每新添加一个元素到链表当中时，<code>addAt</code>方法应该让链表的长度加 1 。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.addAt(0,'cat'); return test.size() === 3}()), 'Your <code>addAt</code> method should increase the length of the linked list by one for each new node added to the linked list.');"
        },
        {
          "text": "如果节点未能成功添加到链表当中，<code>addAt</code>方法应该返回<code>false</code>。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); return (test.addAt(4,'cat') === false); }()), 'Your <code>addAt</code> method should return <code>false</code> if a node was unable to be added.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.size = function(){",
            "    return length;",
            "  };",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.add = function(element){",
            "    var node = new Node(element);",
            "    if(head === null){",
            "        head = node;",
            "    } else {",
            "        currentNode = head;",
            "",
            "        while(currentNode.next){",
            "            currentNode  = currentNode.next;",
            "        }",
            "",
            "        currentNode.next = node;",
            "    }",
            "",
            "    length++;",
            "  }; ",
            "",
            "  // Only 请在本行下方输入代码",
            "",
            "  // Only 请在本行上方输入代码",
            "",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825a367417b2b2512c87",
      "title": "Create a Doubly Linked List",
      "description": [
        "之前我们创建的都是单向链表。现在我们来创建双向链表。就像名字所暗示的那样，双向链表拥有两个指针，一个指向前一个元素一个指向后一个元素。",
        "这种链表可以从两个方向遍历元素，但是因为每个节点都有两个指针所以这种链表会占据更多的空间。",
        "<hr>",
        "我们提供了一个<code>Node</code>来开始学习<code>DoublyLinkedList</code>。现在我们来给我们的双向链表添加<code>add</code>和<code>remove</code>方法。<code>add</code>方法应该添加指定元素到列表当中，而<code>remove</code>方法移除表中指定元素。",
        "当我们处理表中的边界元素时，比如移除移除表中头部或者尾部的元素时需要谨慎。而当试图从空表当中移除元素时应该返回<code>null</code>。"
      ],
      "tests": [
        {
          "text": "该双向链表存在。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (typeof test == 'object')})(), 'The DoublyLinkedList data structure exists.');"
        },
        {
          "text": "该双向链表有一个 add 方法。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.add == undefined) { return false; }; return (typeof test.add == 'function')})(), 'The DoublyLinkedList has a method called add.');"
        },
        {
          "text": "该双向链表有一个 remove 方法。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.remove == undefined) { return false; }; return (typeof test.remove == 'function')})(), 'The DoublyLinkedList has a method called remove.');"
        },
        {
          "text": "试图从空表当中移除元素时应该返回 null 。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (test.remove(100) == null); })(), 'Removing an item from an empty list returns null.');"
        },
        {
          "text": "add 方法添加元素当表当中。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(5); test.add(6); test.add(723); return (test.print().join('') == '56723'); })(), 'The add method adds items to the list.');"
        },
        {
          "text": "每个节点应该能指向前一个节点。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(50); test.add(68); test.add(73); return (test.printReverse().join('') == '736850'); })(), 'Each node keeps track of the previous node.');"
        },
        {
          "text": "表中第一个元素能够被移除。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(25); test.add(35); test.add(60); test.remove(25); return ( test.print().join('') == '3560' ) })(), 'The first item can be removed from the list.');"
        },
        {
          "text": "表中最后一个元素能够被移除。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(25); test.add(35); test.add(60); test.remove(60); return ( test.print().join('') == '2535' ) })(), 'The last item can be removed from the list.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var Node = function(data, prev) {",
            "  this.data = data;",
            "  this.prev = prev;",
            "  this.next = null;",
            "};",
            "var DoublyLinkedList = function() {",
            "  this.head = null;",
            "  this.tail = null;",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": [
            "DoublyLinkedList.prototype = {",
            "  print() {",
            "    if (this.head == null) {",
            "      return null;",
            "    } else {",
            "      var result = new Array();",
            "      var node = this.head;",
            "      while (node.next != null) {",
            "        result.push(node.data);",
            "        node = node.next;",
            "      };",
            "      result.push(node.data);",
            "      return result;",
            "    };",
            "  },",
            "  printReverse() {",
            "    if (this.tail == null) {",
            "      return null;",
            "    } else {",
            "      var result = new Array();",
            "      var node = this.tail;",
            "      while (node.prev != null) {",
            "        result.push(node.data);",
            "        node = node.prev;",
            "      };",
            "      result.push(node.data);",
            "      return result;",
            "    };",
            "  } ",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d825a367417b2b2512c88",
      "title": "Reverse a Doubly Linked List",
      "description": [
        "现在我们来为双向链表创建一个 reverse 方法，该方法反转列表当中的元素。一旦该方法执行之后 head 指针应该指向表尾部，tail 指针则指向表头部。如果我们从头到尾反转了一个链表的话，则新的链表的顺序和原表应该完全相反。当试图反转一个空表时，该方法应该返回 null 。"
      ],
      "tests": [
        {
          "text": "该双向链表存在。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (typeof test == 'object')})(), 'The DoublyLinkedList data structure exists.');"
        },
        {
          "text": "该双向链表有 add 方法。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.add == undefined) { return false; }; return (typeof test.add == 'function')})(), 'The DoublyLinkedList has a method called add.');"
        },
        {
          "text": "该双向链表有 reverse 方法。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.reverse == undefined) { return false; }; return (typeof test.reverse == 'function')})(), 'The DoublyLinkedList has a method called reverse.');"
        },
        {
          "text": "试图反转一个空表时会返回 null 。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (test.reverse() == null); })(), 'Reversing an empty list returns null.');"
        },
        {
          "text": "reverse 方法翻转整个表。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(58); test.add(61); test.add(32); test.reverse(); return (test.print().join('') == '326158'); })(), 'The reverse method reverses the list.');"
        },
        {
          "text": "当整个表被翻转之后，表中每个元素的 next 和 previous 指针都应该存在。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(11); test.add(22); test.add(33); test.reverse(); return (test.printReverse().join('') == '112233'); })(), 'The next and previous references are correctly maintained when a list is reversed.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var Node = function(data, prev) {",
            "  this.data = data;",
            "  this.prev = prev;",
            "  this.next = null;",
            "};",
            "var DoublyLinkedList = function() {",
            "  this.head = null;",
            "  this.tail = null;",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": [
            "DoublyLinkedList.prototype = {",
            "  add(data) {",
            "    if (this.head == null) {",
            "      this.head = new Node(data, null);",
            "      this.tail = this.head;",
            "    } else {",
            "      var node = this.head;",
            "      var prev = null;",
            "      while (node.next != null) {",
            "        prev = node;",
            "        node = node.next;",
            "      };",
            "      var newNode = new Node(data, node);",
            "      node.next = newNode;",
            "      this.tail = newNode;",
            "    };",
            "  },",
            "  print() {",
            "    if (this.head == null) {",
            "      return null;",
            "    } else {",
            "      var result = new Array();",
            "      var node = this.head;",
            "      while (node.next != null) {",
            "        result.push(node.data);",
            "        node = node.next;",
            "      };",
            "      result.push(node.data);",
            "      return result;",
            "    };",
            "  },",
            "  printReverse() {",
            "    if (this.tail == null) {",
            "      return null;",
            "    } else {",
            "      var result = new Array();",
            "      var node = this.tail;",
            "      while (node.prev != null) {",
            "        result.push(node.data);",
            "        node = node.prev;",
            "      };",
            "      result.push(node.data);",
            "      return result;",
            "    };",
            "  }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8256367417b2b2512c7a",
      "title": "Find the Minimum and Maximum Value in a Binary Search Tree",
      "description": [
        "This series of challenges will introduce the tree data structure. Trees are an important and versatile data structure in computer science. Of course, their name comes from the fact that when visualized they look much like the trees we are familiar with in the natural world. A tree data structure begins with one node, typically referred to as the root, and from here branches out to additional nodes, each of which may have more child nodes, and so on and so forth. The data structure is usually visualized with the root node at the top; you can think of it as a natural tree flipped upside down.",
        "First, let's describe some common terminology we will encounter with trees. The root node is the top of the tree. Data points in the tree are called nodes. Nodes with branches leading to other nodes are referred to as the parent of the node the branch leads to (the child). Other more complicated familial terms apply as you might expect. A subtree refers to all the descendants of a particular node, branches may be referred to as edges, and leaf nodes are nodes at the end of the tree that have no children. Finally, note that trees are inherently recursive data structures. That is, any children of a node are parents of their own subtree, and so on. The recursive nature of trees is important to understand when designing algorithms for common tree operations.",
        "To begin, we will discuss a particular type of a tree, the binary tree. In fact, we will actually discuss a particular binary tree, a binary search tree. Let's describe what this means. While the tree data structure can have any number of branches at a single node, a binary tree can only have two branches for every node. Furthermore, a binary search tree is ordered with respect to the child subtrees, such that the value of each node in the left subtree is less than or equal to the value of the parent node, and the value of each node in the right subtree is greater than or equal to the value of the parent node. It's very helpful to visualize this relationship in order to understand it better:",
        "<div style='width: 100%; display: flex; justify-content: center; align-items: center;'><img style='width: 100%; max-width: 350px;' src='https://user-images.githubusercontent.com/18563015/32136009-1e665d98-bbd6-11e7-9133-63184f9f9182.png'></div>",
        "Now this ordered relationship is very easy to see. Note that every value to the left of 8, the root node, is less than 8, and every value to the right is greater than 8. Also notice that this relationship applies to each of the subtrees as well. For example, the first left child is a subtree. 3 is the parent node, and it has exactly two child nodes &mdash; by the rules governing binary search trees, we know without even looking that the left child of this node (and any of its children) will be less than 3, and the right child (and any of its children) will be greater than 3 (but also less than the structure's root value), and so on.",
        "Binary search trees are very common and useful data structures because they provide logarithmic time in the average case for several common operations such as lookup, insertion, and deletion.",
        "Instructions: We'll start simple. We've defined the skeleton of a binary search tree structure here in addition to a function to create nodes for our tree. Observe that each node may have a left and right value. These will be assigned child subtrees if they exist. In our binary search tree, define two methods, <code>findMin</code> and <code>findMax</code>. These methods should return the minimum and maximum value held in the binary search tree (don't worry about adding values to the tree for now, we have added some in the background). If you get stuck, reflect on the invariant that must be true for binary search trees: each left subtree is less than or equal to its parent and each right subtree is greater than or equal to its parent. Let's also say that our tree can only store integer values. If the tree is empty, either method should return <code>null</code>."
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>findMin</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMin == 'function')})(), 'The binary search tree has a method called <code>findMin</code>.');"
        },
        {
          "text": "The binary search tree has a method called <code>findMax</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMax == 'function')})(), 'The binary search tree has a method called <code>findMax</code>.');"
        },
        {
          "text": "The <code>findMin</code> method returns the minimum value in the binary search tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMin !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.findMin() == 1; })(), 'The <code>findMin</code> method returns the minimum value in the binary search tree.');"
        },
        {
          "text": "The <code>findMax</code> method returns the maximum value in the binary search tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMax !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.findMax() == 87; })(), 'The <code>findMax</code> method returns the maximum value in the binary search tree.');"
        },
        {
          "text": "The <code>findMin</code> and <code>findMax</code> methods return <code>null</code> for an empty tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMin !== 'function') { return false; }; if (typeof test.findMax !== 'function') { return false; }; return (test.findMin() == null && test.findMax() == null) })(), 'The <code>findMin</code> and <code>findMax</code> methods return <code>null</code> for an empty tree.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8257367417b2b2512c7b",
      "title": "Add a New Element to a Binary Search Tree",
      "description": [
        "Now that we have an idea of the basics lets write a more complex method.",
        "In this challenge, we will create a method to add new values to our binary search tree. The method should be called <code>add</code> and it should accept an integer value to add to the tree. Take care to maintain the invariant of a binary search tree: the value in each left child should be less than or equal to the parent value, and the value in each right child should be greater than or equal to the parent value. Here, let's make it so our tree cannot hold duplicate values. If we try to add a value that already exists, the method should return <code>null</code>. Otherwise, if the addition is successful, <code>undefined</code> should be returned.",
        "Hint: trees are naturally recursive data structures!"
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>add</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.add == 'function')})(), 'The binary search tree has a method called <code>add</code>.');"
        },
        {
          "text": "The add method adds elements according to the binary search tree rules.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.add !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.isBinarySearchTree()); })(), 'The add method adds elements according to the binary search tree rules.');"
        },
        {
          "text": "Adding an element that already exists returns <code>null</code>",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.add !== 'function') { return false; }; test.add(4); return test.add(4) == null; })(), 'Adding an element that already exists returns <code>null</code>');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    isBinarySearchTree() {",
            "        if (this.root == null) {",
            "            return null;",
            "        } else {",
            "            var check = true;",
            "            function checkTree(node) {",
            "                if (node.left != null) {",
            "                    var left = node.left;",
            "                    if (left.value > node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(left);",
            "                    }",
            "                }",
            "                if (node.right != null) {",
            "                    var right = node.right;",
            "                    if (right.value < node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(right);",
            "                    };",
            "                };",
            "            };",
            "            checkTree(this.root);",
            "            return check;",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8257367417b2b2512c7c",
      "title": "Check if an Element is Present in a Binary Search Tree",
      "description": [
        "Now that we have a general sense of what a binary search tree is let's talk about it in a little more detail. Binary search trees provide logarithmic time for the common operations of lookup, insertion, and deletion in the average case, and linear time in the worst case. Why is this? Each of those basic operations requires us to find an item in the tree (or in the case of insertion to find where it should go) and because of the tree structure at each parent node we are branching left or right and effectively excluding half the size of the remaining tree. This makes the search proportional to the logarithm of the number of nodes in the tree, which creates logarithmic time for these operations in the average case.",
        "Ok, but what about the worst case? Well, consider constructing a tree from the following values, adding them left to right: <code>10</code>, <code>12</code>, <code>17</code>, <code>25</code>. Following our rules for a binary search tree, we will add <code>12</code> to the right of <code>10</code>, <code>17</code> to the right of this, and <code>25</code> to the right of this. Now our tree resembles a linked list and traversing it to find <code>25</code> would require us to traverse all the items in linear fashion. Hence, linear time in the worst case. The problem here is that the tree is unbalanced. We'll look a little more into what this means in the following challenges.",
        "Instructions: In this challenge, we will create a utility for our tree. Write a method <code>isPresent</code> which takes an integer value as input and returns a boolean value for the presence or absence of that value in the binary search tree."
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>isPresent</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.isPresent == 'function')})(), 'The binary search tree has a method called <code>isPresent</code>.');"
        },
        {
          "text": "The <code>isPresent</code> method correctly checks for the presence or absence of elements added to the tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isPresent !== 'function') { return false; }; test.add(4); test.add(7); test.add(411); test.add(452); return ( test.isPresent(452) && test.isPresent(411) && test.isPresent(7) && !test.isPresent(100) ); })(), 'The <code>isPresent</code> method correctly checks for the presence or absence of elements added to the tree.');"
        },
        {
          "text": "<code>isPresent</code> handles cases where the tree is empty.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isPresent !== 'function') { return false; }; return test.isPresent(5) == false; })(), '<code>isPresent</code> handles cases where the tree is empty.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {    ",
            "    this.root = null;",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8257367417b2b2512c7d",
      "title": "Find the Minimum and Maximum Height of a Binary Search Tree",
      "description": [
        "In the last challenge we described a scenario in which a tree could become unbalanced. To understand the concept of balance, let's take a look at another tree property: height. Height in a tree represents the distance from the root node to any given leaf node. Different paths in a highly branched tree structure may have different heights, but for a given tree there will be a minimum and maximum height. If the tree is balanced, these values will differ at most by one. This means that in a balanced tree, all the leaf nodes exist within the same level, or if they are not within the same level they are at most one level apart.",
        "The property of balance is important for trees because it is what determines the efficiency of tree operations. As we explained in the last challenge, we face worst case time complexity for heavily unbalanced trees. Self-balancing trees are commonly used to account for this issue in trees with dynamic data sets. Common examples of these include AVL trees, red-black trees, and B-trees. These trees all contain additional internal logic which re-balance the tree when insertions or deletions create a state of imbalance.",
        "Note: A similar property to height is depth, which refers to how far a given node is from the root node.",
        "Instructions: Write two methods for our binary tree: <code>findMinHeight</code> and <code>findMaxHeight</code>. These methods should return an integer value for the minimum and maximum height within a given binary tree, respectively. If the node is empty let's assign it a height of <code>-1</code> (that's the base case). Finally, add a third method <code>isBalanced</code> which returns <code>true</code> or <code>false</code> depending on whether the tree is balanced or not. You can use the first two methods you just wrote to determine this."
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>findMinHeight</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMinHeight == 'function')})(), 'The binary search tree has a method called <code>findMinHeight</code>.');"
        },
        {
          "text": "The binary search tree has a method called <code>findMaxHeight</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMaxHeight == 'function')})(), 'The binary search tree has a method called <code>findMaxHeight</code>.');"
        },
        {
          "text": "The binary search tree has a method called <code>isBalanced</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.isBalanced == 'function')})(), 'The binary search tree has a method called <code>isBalanced</code>.');"
        },
        {
          "text": "The <code>findMinHeight</code> method returns the minimum height of the tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMinHeight !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.findMinHeight() == 1); })(), 'The <code>findMinHeight</code> method returns the minimum height of the tree.');"
        },
        {
          "text": "The <code>findMaxHeight</code> method returns the maximum height of the tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMaxHeight !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.findMaxHeight() == 5); })(), 'The <code>findMaxHeight</code> method returns the maximum height of the tree.');"
        },
        {
          "text": "An empty tree returns a height of <code>-1</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMaxHeight !== 'function') { return false; }; return (test.findMaxHeight() == -1); })(), 'An empty tree returns a height of <code>-1</code>.');"
        },
        {
          "text": "The <code>isBalanced</code> method returns true if the tree is a balanced binary search tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isBalanced !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.isBalanced(); })(), 'The <code>isBalanced</code> method returns true if the tree is a balanced binary search tree.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8257367417b2b2512c7e",
      "title": "Use Depth First Search in a Binary Search Tree",
      "description": [
        "We know how to search a binary search tree for a specific value. But what if we just want to explore the entire tree? Or what if we don't have an ordered tree and we need to just search for a value? Here we will introduce some tree traversal methods which can be used to explore tree data structures. First up is depth-first search. In depth-first search, a given subtree is explored as deeply as possible before the search continues on to another subtree. There are three ways this can be done:",
        "In-order: Begin the search at the left-most node and end at the right-most node.",
        "Pre-order: Explore all the roots before the leaves.",
        "Post-order: Explore all the leaves before the roots.",
        "As you may guess, you may choose different search methods depending on what type of data your tree is storing and what you are looking for. For a binary search tree, an inorder traversal returns the nodes in sorted order.",
        "Instructions: Here we will create these three search methods on our binary search tree. Depth-first search is an inherently recursive operation which continues to explore further subtrees so long as child nodes are present. Once you understand this basic concept, you can simply rearrange the order in which you explore the nodes and subtrees to produce any of the three searches above. For example, in post-order search we would want to recurse all the way to a leaf node before we begin to return any of the nodes themselves, whereas in pre-order search we would want to return the nodes first, and then continue recursing down the tree.",
        "Define <code>inorder</code>, <code>preorder</code>, and <code>postorder</code> methods on our tree. Each of these methods should return an array of items which represent the tree traversal. Be sure to return the integer values at each node in the array, not the nodes themselves. Finally, return <code>null</code> if the tree is empty."
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>inorder</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.inorder == 'function')})(), 'The binary search tree has a method called <code>inorder</code>.');"
        },
        {
          "text": "The binary search tree has a method called <code>preorder</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.preorder == 'function')})(), 'The binary search tree has a method called <code>preorder</code>.');"
        },
        {
          "text": "The binary search tree has a method called <code>postorder</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.postorder == 'function')})(), 'The binary search tree has a method called <code>postorder</code>.');"
        },
        {
          "text": "The <code>inorder</code> method returns an array of the node values that result from an inorder traversal.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.inorder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.inorder().join('') == '012345678910'); })(), 'The <code>inorder</code> method returns an array of the node values that result from an inorder traversal.');"
        },
        {
          "text": "The <code>preorder</code> method returns an array of the node values that result from a preorder traversal.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.preorder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.preorder().join('') == '710325469810'); })(), 'The <code>preorder</code> method returns an array of the node values that result from a preorder traversal.');"
        },
        {
          "text": "The <code>postorder</code> method returns an array of the node values that result from a postorder traversal.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.postorder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.postorder().join('') == '024653181097'); })(), 'The <code>postorder</code> method returns an array of the node values that result from a postorder traversal.');"
        },
        {
          "text": "The <code>inorder</code> method returns <code>null</code> for an empty tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.inorder !== 'function') { return false; }; return (test.inorder() == null); })(), 'The <code>inorder</code> method returns <code>null</code> for an empty tree.');"
        },
        {
          "text": "The <code>preorder</code> method returns <code>null</code> for an empty tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.preorder !== 'function') { return false; }; return (test.preorder() == null); })(), 'The <code>preorder</code> method returns <code>null</code> for an empty tree.');"
        },
        {
          "text": "The <code>postorder</code> method returns <code>null</code> for an empty tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.postorder !== 'function') { return false; }; return (test.postorder() == null); })(), 'The <code>postorder</code> method returns <code>null</code> for an empty tree.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8258367417b2b2512c7f",
      "title": "Use Breadth First Search in a Binary Search Tree",
      "description": [
        "Here we will introduce another tree traversal method: breadth-first search. In contrast to the depth-first search methods from the last challenge, breadth-first search explores all the nodes in a given level within a tree before continuing on to the next level. Typically, queues are utilized as helper data structures in the design of breadth-first search algorithms.",
        "In this method, we start by adding the root node to a queue. Then we begin a loop where we dequeue the first item in the queue, add it to a new array, and then inspect both its child subtrees. If its children are not null, they are each enqueued. This process continues until the queue is empty.",
        "Instructions: Let's create a breadth-first search method in our tree called <code>levelOrder</code>. This method should return an array containing the values of all the tree nodes, explored in a breadth-first manner. Be sure to return the values in the array, not the nodes themselves. A level should be traversed from left to right. Next, let's write a similar method called <code>reverseLevelOrder</code> which performs the same search but in the reverse direction (right to left) at each level."
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>levelOrder</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.levelOrder == 'function')})(), 'The binary search tree has a method called <code>levelOrder</code>.');"
        },
        {
          "text": "The binary search tree has a method called <code>reverseLevelOrder</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.reverseLevelOrder == 'function')})(), 'The binary search tree has a method called <code>reverseLevelOrder</code>.');"
        },
        {
          "text": "The <code>levelOrder</code> method returns an array of the tree node values explored in level order.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.levelOrder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.levelOrder().join('') == '719038102546'); })(), 'The <code>levelOrder</code> method returns an array of the tree node values explored in level order.');"
        },
        {
          "text": "The <code>reverseLevelOrder</code> method returns an array of the tree node values explored in reverse level order.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.reverseLevelOrder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.reverseLevelOrder().join('') == '791108305264'); })(), 'The <code>reverseLevelOrder</code> method returns an array of the tree node values explored in reverse level order.');"
        },
        {
          "text": "The <code>levelOrder</code> method returns <code>null</code> for an empty tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.levelOrder !== 'function') { return false; }; return (test.levelOrder() == null); })(), 'The <code>levelOrder</code> method returns <code>null</code> for an empty tree.');"
        },
        {
          "text": "The <code>reverseLevelOrder</code> method returns <code>null</code> for an empty tree.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.reverseLevelOrder !== 'function') { return false; }; return (test.reverseLevelOrder() == null); })(), 'The <code>reverseLevelOrder</code> method returns <code>null</code> for an empty tree.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8258367417b2b2512c80",
      "title": "Delete a Leaf Node in a Binary Search Tree",
      "description": [
        "This is the first of three challenges where we will implement a more difficult operation in binary search trees: deletion. Deletion is difficult because removing nodes breaks links in the tree. These links must be carefully reestablished to ensure the binary tree structure is maintained. For some deletions, this means the tree must be rearranged. In general, you will encounter one of three cases when trying to delete a node:",
        "Leaf Node: The target to delete has zero children.",
        "One Child: The target to delete only has one child.",
        "Two Children: The target to delete has two child nodes.",
        "Removing a leaf node is easy, we simply remove it. Deleting a node with one child is also relatively easy, we simply remove it and link its parent to child of the node we deleted. Removing a node with two children is more difficult, however, because this creates two child nodes that need to be reconnected to the parent tree. We'll see how to deal with this case in the third challenge. Additionally, you need to be mindful of some edge cases when handling deletion. What if the tree is empty? What if the node to delete is the root node? What if there are only two elements in the tree? For now, let's handle the first case where we delete a leaf node.",
        "Instructions: Create a method on our binary tree called <code>remove</code>. We'll build the logic for our deletion operation in here. First, you'll want to create a function within remove that finds the node we are trying to delete in the current tree. If the node is not present in the tree, <code>remove</code> should return <code>null</code>. Now, if the target node is a leaf node with no children, then the parent reference to it should be set to <code>null</code>. This effectively deletes the node from the tree. To do this, you will have to keep track of the parent of the node we are trying to delete as well. It will also be useful to create a way to track the number of children the target node has, as this will determine which case our deletion falls under.",
        "We will handle the second and third cases in the next challenges. Good luck!"
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>remove</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function')})(), 'The binary search tree has a method called <code>remove</code>.');"
        },
        {
          "text": "Trying to remove an element that does not exist returns <code>null</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; return (test.remove(100) == null); })(), 'Trying to remove an element that does not exist returns <code>null</code>.');"
        },
        {
          "text": "If the root node has no children, deleting it sets the root to <code>null</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(500); test.remove(500); return (test.inorder() == null); })(), 'If the root node has no children, deleting it sets the root to <code>null</code>.');"
        },
        {
          "text": "The <code>remove</code> method removes leaf nodes from the tree",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(5); test.add(3); test.add(7); test.add(6); test.add(10); test.add(12); test.remove(3); test.remove(12); test.remove(10); return (test.inorder().join('') == '567'); })(), 'The <code>remove</code> method removes leaf nodes from the tree');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // case 1: target has no children, 请在本行下方输入代码",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    },",
            "    inorder: function() {",
            "        if (this.root == null) {",
            "          return null;",
            "        } else {",
            "          var result = new Array();",
            "          function traverseInOrder(node) {",
            "              if (node.left != null) {",
            "                  traverseInOrder(node.left);",
            "              };",
            "              result.push(node.value);",
            "              if (node.right != null) {",
            "                  traverseInOrder(node.right);",
            "              };",
            "          }",
            "          traverseInOrder(this.root);",
            "          return result;",
            "        };",
            "    },    ",
            "    isBinarySearchTree() {",
            "        if (this.root == null) {",
            "            return null;",
            "        } else {",
            "            var check = true;",
            "            function checkTree(node) {",
            "                if (node.left != null) {",
            "                    var left = node.left;",
            "                    if (left.value > node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(left);",
            "                    }",
            "                }",
            "                if (node.right != null) {",
            "                    var right = node.right;",
            "                    if (right.value < node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(right);",
            "                    };",
            "                };",
            "            };",
            "            checkTree(this.root);",
            "            return check;",
            "        }",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8258367417b2b2512c81",
      "title": "Delete a Node with One Child in a Binary Search Tree",
      "description": [
        "Now that we can delete leaf nodes let's move on to the second case: deleting a node with one child. For this case, say we have a tree with the following nodes 1 — 2 — 3 where 1 is the root. To delete 2, we simply need to make the right reference in 1 point to 3. More generally to delete a node with only one child, we make that node's parent reference the next node in the tree.",
        "Instructions: We've provided some code in our <code>remove</code> method that accomplishes the tasks from the last challenge. We find the target to delete and its parent and define the number of children the target node has. Let's add the next case here for target nodes with only one child. Here, we'll have to determine if the single child is a left or right branch in the tree and then set the correct reference in the parent to point to this node. In addition, let's account for the case where the target is the root node (this means the parent node will be <code>null</code>). Feel free to replace all the starter code with your own as long as it passes the tests."
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>remove</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function')})(), 'The binary search tree has a method called <code>remove</code>.');"
        },
        {
          "text": "Trying to remove an element that does not exist returns <code>null</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; return (test.remove(100) == null); })(), 'Trying to remove an element that does not exist returns <code>null</code>.');"
        },
        {
          "text": "If the root node has no children, deleting it sets the root to <code>null</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(500); test.remove(500); return (test.inorder() == null); })(), 'If the root node has no children, deleting it sets the root to <code>null</code>.');"
        },
        {
          "text": "The <code>remove</code> method removes leaf nodes from the tree",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(5); test.add(3); test.add(7); test.add(6); test.add(10); test.add(12); test.remove(3); test.remove(12); test.remove(10); return (test.inorder().join('') == '567'); })(), 'The <code>remove</code> method removes leaf nodes from the tree');"
        },
        {
          "text": "The <code>remove</code> method removes nodes with one child.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(-1); test.add(3); test.add(7); test.add(16); test.remove(16); test.remove(7); test.remove(3); return (test.inorder().join('') == '-1'); })(), 'The <code>remove</code> method removes nodes with one child.');"
        },
        {
          "text": "Removing the root in a tree with two nodes sets the second to be the root.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(15); test.add(27); test.remove(15); return (test.inorder().join('') == '27'); })(), 'Removing the root in a tree with two nodes sets the second to be the root.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "  this.value = value;",
            "  this.left = null;",
            "  this.right = null;",
            "}",
            "",
            "function BinarySearchTree() {",
            "  this.root = null;",
            "  this.remove = function(value) {",
            "    if (this.root === null) {",
            "      return null;",
            "    }",
            "    var target;",
            "    var parent = null;",
            "    // find the target value and its parent",
            "    (function findValue(node = this.root) {",
            "      if (value == node.value) {",
            "        target = node;",
            "      } else if (value < node.value && node.left !== null) {",
            "        parent = node;",
            "        return findValue(node.left);",
            "      } else if (value < node.value && node.left === null) {",
            "        return null;",
            "      } else if (value > node.value && node.right !== null) {",
            "        parent = node;",
            "        return findValue(node.right);",
            "      } else {",
            "        return null;",
            "      }",
            "    }).bind(this)();",
            "    if (target === null) {",
            "      return null;",
            "    }",
            "    // count the children of the target to delete",
            "    var children = (target.left !== null ? 1 : 0) + (target.right !== null ? 1 : 0);",
            "    // case 1: target has no children",
            "    if (children === 0) {",
            "      if (target == this.root) {",
            "        this.root = null;",
            "      }",
            "      else {",
            "        if (parent.left == target) {",
            "          parent.left = null;",
            "        } else {",
            "          parent.right = null;",
            "        }",
            "      }",
            "    }",
            "    // case 2: target has one child, 请在本行下方输入代码",
            "  };",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    },",
            "    inorder: function() {",
            "        if (this.root == null) {",
            "          return null;",
            "        } else {",
            "          var result = new Array();",
            "          function traverseInOrder(node) {",
            "              if (node.left != null) {",
            "                  traverseInOrder(node.left);",
            "              };",
            "              result.push(node.value);",
            "              if (node.right != null) {",
            "                  traverseInOrder(node.right);",
            "              };",
            "          }",
            "          traverseInOrder(this.root);",
            "          return result;",
            "        };",
            "    },    ",
            "    isBinarySearchTree() {",
            "        if (this.root == null) {",
            "            return null;",
            "        } else {",
            "            var check = true;",
            "            function checkTree(node) {",
            "                if (node.left != null) {",
            "                    var left = node.left;",
            "                    if (left.value > node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(left);",
            "                    }",
            "                }",
            "                if (node.right != null) {",
            "                    var right = node.right;",
            "                    if (right.value < node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(right);",
            "                    };",
            "                };",
            "            };",
            "            checkTree(this.root);",
            "            return check;",
            "        }",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8258367417b2b2512c82",
      "title": "Delete a Node with Two Children in a Binary Search Tree",
      "description": [
        "Removing nodes that have two children is the hardest case to implement. Removing a node like this produces two subtrees that are no longer connected to the original tree structure. How can we reconnect them? One method is to find the smallest value in the right subtree of the target node and replace the target node with this value. Selecting the replacement in this way ensures that it is greater than every node in the left subtree it becomes the new parent of but also less than every node in the right subtree it becomes the new parent of.",
        "Once this replacement is made the replacement node must be removed from the right subtree. Even this operation is tricky because the replacement may be a leaf or it may itself be the parent of a right subtree. If it is a leaf we must remove its parent's reference to it. Otherwise, it must be the right child of the target. In this case, we must replace the target value with the replacement value and make the target reference the replacement's right child.",
        "Instructions: Let's finish our <code>remove</code> method by handling the third case. We've provided some code again for the first two cases. Add some code now to handle target nodes with two children. Any edge cases to be aware of? What if the tree has only three nodes? Once you are finished this will complete our deletion operation for binary search trees. Nice job, this is a pretty hard problem!"
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>remove</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function')})(), 'The binary search tree has a method called <code>remove</code>.');"
        },
        {
          "text": "Trying to remove an element that does not exist returns <code>null</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function') ? (test.remove(100) == null) : false})(), 'Trying to remove an element that does not exist returns <code>null</code>.');"
        },
        {
          "text": "If the root node has no children, deleting it sets the root to <code>null</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; test.add(500); test.remove(500); return (typeof test.remove == 'function') ? (test.inorder() == null) : false})(), 'If the root node has no children, deleting it sets the root to <code>null</code>.');"
        },
        {
          "text": "The <code>remove</code> method removes leaf nodes from the tree",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; test.add(5); test.add(3); test.add(7); test.add(6); test.add(10); test.add(12); test.remove(3); test.remove(12); test.remove(10); return (typeof test.remove == 'function') ? (test.inorder().join('') == '567') : false})(), 'The <code>remove</code> method removes leaf nodes from the tree');"
        },
        {
          "text": "The <code>remove</code> method removes nodes with one child.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(-1); test.add(3); test.add(7); test.add(16); test.remove(16); test.remove(7); test.remove(3); return (test.inorder().join('') == '-1'); })(), 'The <code>remove</code> method removes nodes with one child.');"
        },
        {
          "text": "Removing the root in a tree with two nodes sets the second to be the root.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(15); test.add(27); test.remove(15); return (test.inorder().join('') == '27'); })(), 'Removing the root in a tree with two nodes sets the second to be the root.');"
        },
        {
          "text": "The <code>remove</code> method removes nodes with two children while maintaining the binary search tree structure.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(1); test.add(4); test.add(3); test.add(7); test.add(9); test.add(11); test.add(14); test.add(15); test.add(19); test.add(50); test.remove(9); if (!test.isBinarySearchTree()) { return false; }; test.remove(11); if (!test.isBinarySearchTree()) { return false; }; test.remove(14); if (!test.isBinarySearchTree()) { return false; }; test.remove(19); if (!test.isBinarySearchTree()) { return false; }; test.remove(3); if (!test.isBinarySearchTree()) { return false; }; test.remove(50); if (!test.isBinarySearchTree()) { return false; }; test.remove(15); if (!test.isBinarySearchTree()) { return false; }; return (test.inorder().join('') == '147'); })(), 'The <code>remove</code> method removes nodes with two children while maintaining the binary search tree structure.');"
        },
        {
          "text": "The root can be removed on a tree of three nodes.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(100); test.add(50); test.add(300); test.remove(100); return (test.inorder().join('') == 50300); })(), 'The root can be removed on a tree of three nodes.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "  this.value = value;",
            "  this.left = null;",
            "  this.right = null;",
            "}",
            "",
            "function BinarySearchTree() {",
            "  this.root = null;",
            "  this.remove = function(value) {",
            "    if (this.root === null) {",
            "      return null;",
            "    }",
            "    var target;",
            "    var parent = null;",
            "    // find the target value and its parent",
            "    (function findValue(node = this.root) {",
            "      if (value == node.value) {",
            "        target = node;",
            "      } else if (value < node.value && node.left !== null) {",
            "        parent = node;",
            "        return findValue(node.left);",
            "      } else if (value < node.value && node.left === null) {",
            "        return null;",
            "      } else if (value > node.value && node.right !== null) {",
            "        parent = node;",
            "        return findValue(node.right);",
            "      } else {",
            "        return null;",
            "      }",
            "    }).bind(this)();",
            "    if (target === null) {",
            "      return null;",
            "    }",
            "    // count the children of the target to delete",
            "    var children = (target.left !== null ? 1 : 0) + (target.right !== null ? 1 : 0);",
            "    // case 1: target has no children",
            "    if (children === 0) {",
            "      if (target == this.root) {",
            "        this.root = null;",
            "      }",
            "      else {",
            "        if (parent.left == target) {",
            "          parent.left = null;",
            "        } else {",
            "          parent.right = null;",
            "        }",
            "      }",
            "    }",
            "    // case 2: target has one child",
            "    else if (children == 1) {",
            "      var newChild = (target.left !== null) ? target.left : target.right;",
            "      if (parent === null) {",
            "        target.value = newChild.value;",
            "        target.left = null;",
            "        target.right = null;",
            "      } else if (newChild.value < parent.value) {",
            "        parent.left = newChild;",
            "      } else {",
            "        parent.right = newChild;",
            "      }",
            "      target = null;",
            "    }",
            "    // case 3: target has two children, 请在本行下方输入代码",
            "  };",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    },",
            "    inorder: function() {",
            "        if (this.root == null) {",
            "          return null;",
            "        } else {",
            "          var result = new Array();",
            "          function traverseInOrder(node) {",
            "              if (node.left != null) {",
            "                  traverseInOrder(node.left);",
            "              };",
            "              result.push(node.value);",
            "              if (node.right != null) {",
            "                  traverseInOrder(node.right);",
            "              };",
            "          }",
            "          traverseInOrder(this.root);",
            "          return result;",
            "        };",
            "    },    ",
            "    isBinarySearchTree() {",
            "        if (this.root == null) {",
            "            return null;",
            "        } else {",
            "            var check = true;",
            "            function checkTree(node) {",
            "                if (node.left != null) {",
            "                    var left = node.left;",
            "                    if (left.value > node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(left);",
            "                    }",
            "                }",
            "                if (node.right != null) {",
            "                    var right = node.right;",
            "                    if (right.value < node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(right);",
            "                    };",
            "                };",
            "            };",
            "            checkTree(this.root);",
            "            return check;",
            "        }",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8259367417b2b2512c83",
      "title": "Invert a Binary Tree",
      "description": [
        "Here will we create a function to invert a binary tree. Given a binary tree, we want to produce a new tree that is equivalently the mirror image of this tree. Running an inorder traversal on an inverted tree will explore the nodes in reverse order when compared to the inorder traversal of the original tree. Write a method to do this called <code>invert</code> on our binary tree. Calling this method should invert the current tree structure. Ideally, we would like to do this in-place in linear time. That is, we only visit each node once and we modify the existing tree structure as we go, without using any additional memory. Good luck!"
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>invert</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.invert == 'function')})(), 'The binary search tree has a method called <code>invert</code>.');"
        },
        {
          "text": "The <code>invert</code> method correctly inverts the tree structure.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.invert !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); test.invert(); return test.inorder().join('') == '877345348741'; })(), 'The <code>invert</code> method correctly inverts the tree structure.');"
        },
        {
          "text": "Inverting an empty tree returns <code>null</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.invert !== 'function') { return false; }; return (test.invert() == null); })(), 'Inverting an empty tree returns <code>null</code>.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    },",
            "    inorder: function() {",
            "        if (this.root == null) {",
            "          return null;",
            "        } else {",
            "          var result = new Array();",
            "          function traverseInOrder(node) {",
            "              if (node.left != null) {",
            "                  traverseInOrder(node.left);",
            "              };",
            "              result.push(node.value);",
            "              if (node.right != null) {",
            "                  traverseInOrder(node.right);",
            "              };",
            "          }",
            "          traverseInOrder(this.root);",
            "          return result;",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8259367417b2b2512c84",
      "title": "Create a Trie Search Tree",
      "description": [
        "Here we will move on from binary search trees and take a look at another type of tree structure called a trie. A trie is an ordered search tree commonly used to hold strings, or more generically associative arrays or dynamic datasets in which the keys are strings. They are very good at storing sets of data when many keys will have overlapping prefixes, for example, all the words in a dictionary.",
        "Unlike a binary tree, nodes are not associated with actual values. Instead, the path to a node represents a specific key. For instance, if we wanted to store the string code in a trie, we would have four nodes, one for each letter: c — o — d — e. Following that path through all these nodes will then create code as a string — that path is the key we stored. Then, if we wanted to add the string coding, it would share the first three nodes of code before branching away after the d. In this way, large datasets can be stored very compactly. In addition, search can be very quick because it is effectively limited to the length of the string you are storing. Furthermore, unlike binary trees a node can store any number of child nodes.",
        "As you might have guessed from the above example, some metadata is commonly stored at nodes that hold the end of a key so that on later traversals that key can still be retrieved. For instance, if we added codes in our example above we would need some way to know that the e in code represents the end of a key that was previously entered. Otherwise, this information would effectively be lost when we add codes.",
        "Instructions: Let's create a trie to store words. It will accept words through an add method and store these in a trie data structure. It will also allow us to query if a given string is a word with an isWord method, and retrieve all the words entered into the trie with a print method. isWord should return a boolean value and print should return an array of all these words as string values.",
        "In order for us to verify that this data structure is implemented correctly, we've provided a Node structure for each node in the tree. Each node will be an object with a keys property which is a JavaScript Map object. This will hold the individual letters that are valid keys of each node. We've also created an end property on the nodes that can be set to true if the node represents the termination of a word."
      ],
      "tests": [
        {
          "text": "The Trie has an add method.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; return (typeof test.add == 'function') }()), 'The Trie has an add method.');"
        },
        {
          "text": "The Trie has a print method.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; return (typeof test.print == 'function') }()), 'The Trie has a print method.');"
        },
        {
          "text": "The Trie has an isWord method.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; return (typeof test.isWord == 'function') }()), 'The Trie has an isWord method.');"
        },
        {
          "text": "The print method returns all items added to the trie as strings in an array.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; test.add('jump'); test.add('jumps'); test.add('jumped'); test.add('house'); test.add('mouse'); var added = test.print(); return (added.indexOf('jump') != -1 && added.indexOf('jumps') != -1 && added.indexOf('jumped') != -1 && added.indexOf('house') != -1 && added.indexOf('mouse') != -1 && added.length == 5); }()), 'The print method returns all items added to the trie as strings in an array.');"
        },
        {
          "text": "The isWord method returns true only for words added to the trie and false for all other words.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; test.add('hop'); test.add('hops'); test.add('hopped'); test.add('hoppy'); test.add('hope'); return (test.isWord('hop') && !test.isWord('ho') && test.isWord('hopped') && !test.isWord('hopp') && test.isWord('hoppy') && !test.isWord('hoping')); }()), 'The isWord method returns true only for words added to the trie and false for all other words.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "var Node = function() {",
            "  this.keys = new Map();",
            "  this.end = false;",
            "  this.setEnd = function() {",
            "    this.end = true;",
            "  };",
            "  this.isEnd = function() {",
            "    return this.end;",
            "  };",
            "};",
            "var Trie = function() {",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825a367417b2b2512c8a",
      "title": "Insert an Element into a Max Heap",
      "description": [
        "Now we will move on to another tree data structure, the binary heap. A binary heap is a partially ordered binary tree which satisfies the heap property. The heap property specifies a relationship between parent and child nodes. You may have a max heap, in which all parent nodes are greater than or equal to their child nodes, or a min heap, in which the reverse is true. Binary heaps are also complete binary trees. This means that all levels of the tree are fully filled and if the last level is partially filled it is filled from left to right.",
        "While binary heaps may be implemented as tree structures with nodes that contain left and right references, the partial ordering according to the heap property allows us to represent the heap with an array. The parent-children relationship is what we're interested in and with simple arithmetic we can compute the children of any parent and the parent of any child node.",
        "For instance, consider this array representation of a binary min heap:",
        "<code>[ 6, 22, 30, 37, 63, 48, 42, 76 ]</code>",
        "The root node is the first element, 6. Its children are 22 and 30. If we look at the relationship between the array indices of these values, for index i the children are 2 * i + 1 and 2 * i + 2. Similarly, the element at index 0 is the parent of these two children at indices 1 and 2. More generally, we can find the parent of a node at any index with the following: (i - 1) / 2. These patterns will hold true as the binary tree grows to any size. Finally, we can make a slight adjustment to make this arithmetic even easier by skipping the first element in the array. Doing this creates the following relationship for any element at a given index i:",
        "Example Array representation:",
        "<code>[ null, 6, 22, 30, 37, 63, 48, 42, 76 ]</code>",
        "An element's left child: i * 2",
        "An element's right child: i * 2 + 1",
        "An element's parent: i / 2",
        "Once you wrap your head around the math, using an array representation is very useful because node locations can be quickly determined with this arithmetic and memory usage is diminished because you don't need to maintain references to child nodes.",
        "Instructions: Here we will create a max heap. Start by just creating an insert method which adds elements to our heap. During insertion, it is important to always maintain the heap property. For a max heap this means the root element should always have the greatest value in the tree and all parent nodes should be greater than their children. For an array implementation of a heap, this is typically accomplished in three steps:",
        "Add the new element to the end of the array.",
        "If the element is larger than its parents, switch them.",
        "Continue switching until the new element is either smaller than its parent or you reach the root of the tree.",
        "Finally, add a print method which returns an array of all the items that have been added to the heap."
      ],
      "tests": [
        {
          "text": "The MaxHeap data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() }; return (typeof test == 'object')})(), 'The MaxHeap data structure exists.');"
        },
        {
          "text": "MaxHeap has a method called insert.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.insert == 'function')})(), 'MaxHeap has a method called insert.');"
        },
        {
          "text": "MaxHeap has a method called print.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.print == 'function')})(), 'MaxHeap has a method called print.');"
        },
        {
          "text": "The insert method adds elements according to the max heap property.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; test.insert(50); test.insert(100); test.insert(700); test.insert(32); test.insert(51); let result = test.print(); return ((result.length == 5) ? result[0] == 700 : result[1] == 700) })(), 'The insert method adds elements according to the max heap property.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var MaxHeap = function() {",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825b367417b2b2512c8b",
      "title": "Remove an Element from a Max Heap",
      "description": [
        "Now that we can add elements to our heap let's see how we can remove elements. Removing and inserting elements both require similar logic. In a max heap you will usually want to remove the greatest value, so this involves simply extracting it from the root of our tree. This will break the heap property of our tree, so we must reestablish it in some way. Typically, for a max heap this is done in the following way:",
        "Move the last element in the heap into the root position.",
        "If either child of the root is greater than it, swap the root with the child of greater value.",
        "Continue swapping until the parent is greater than both children, or you reach the last level in the tree.",
        "Instructions: Add a method to our max heap called remove. This method should return the greatest value that has been added to our max heap and remove it from the heap. It should also reorder the heap so the heap property is maintained. After removing an element, the next greatest element remaining in the heap should become the root. Add your insert method again here as well."
      ],
      "tests": [
        {
          "text": "The MaxHeap data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() }; return (typeof test == 'object')})(), 'The MaxHeap data structure exists.');"
        },
        {
          "text": "MaxHeap has a method called print.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.print == 'function')})(), 'MaxHeap has a method called print.');"
        },
        {
          "text": "MaxHeap has a method called insert.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.insert == 'function')})(), 'MaxHeap has a method called insert.');"
        },
        {
          "text": "MaxHeap has a method called remove.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.remove == 'function')})(), 'MaxHeap has a method called remove.');"
        },
        {
          "text": "The remove method removes the greatest element from the max heap while maintaining the max heap property.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; test.insert(30); test.insert(300); test.insert(500); test.insert(10); let result = []; result.push(test.remove()); result.push(test.remove()); result.push(test.remove()); result.push(test.remove());  return (result.join('') == '5003003010') })(), 'The remove method removes the greatest element from the max heap while maintaining the max heap property.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var MaxHeap = function() {",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825b367417b2b2512c8c",
      "title": "Implement Heap Sort with a Min Heap",
      "description": [
        "Now that we can add and remove elements let's see some of the applications heaps can be used for. Heaps are commonly used to implement priority queues because they always store an item of greatest or least value in first position. In addition, they are used to implement a sorting algorithm called heap sort. We'll see how to do this here. Heap sort uses a min heap, the reverse of a max heap. A min heap always stores the element of least value in the root position.",
        "Heap sort works by taking an unsorted array, adding each item in the array into a min heap, and then extracting every item out of the min heap into a new array. The min heap structure ensures that the new array will contain the original items in least to greatest order. This is one of the most efficient sorting algorithms with average and worst case performance of O(nlog(n)).",
        "Instructions: Let's implement heap sort with a min heap. Feel free to adapt your max heap code here. Create an object MinHeap with insert, remove, and sort methods. The sort method should return an array of all the elements in the min heap sorted from smallest to largest."
      ],
      "tests": [
        {
          "text": "The MinHeap data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() }; return (typeof test == 'object')})(), 'The MinHeap data structure exists.');"
        },
        {
          "text": "MinHeap has a method called insert.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() } else { return false; }; return (typeof test.insert == 'function')})(), 'MinHeap has a method called insert.');"
        },
        {
          "text": "MinHeap has a method called remove.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() } else { return false; }; return (typeof test.remove == 'function')})(), 'MinHeap has a method called remove.');"
        },
        {
          "text": "MinHeap has a method called sort.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() } else { return false; }; return (typeof test.sort == 'function')})(), 'MinHeap has a method called sort.');"
        },
        {
          "text": "The sort method returns an array containing all items added to the min heap in sorted order.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() } else { return false; }; test.insert(3); test.insert(12); test.insert(5); test.insert(10); test.insert(1); test.insert(27); test.insert(42); test.insert(57); test.insert(5); var result = test.sort(); return (isSorted(result)); })(), 'The sort method returns an array containing all items added to the min heap in sorted order.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// check if array is sorted",
            "function isSorted(arr) {",
            "  var check = (i) => (i == arr.length - 1) ? true : (arr[i] > arr[i + 1]) ? false : check(i + 1);",
            "  return check(0);",
            "}",
            "// generate a randomly filled array",
            "var array = new Array();",
            "(function createArray(size = 5) {",
            "  array.push(+(Math.random() * 100).toFixed(0));",
            "  return (size > 1) ? createArray(size - 1) : undefined;",
            "})(25);",
            "var MinHeap = function() {",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8256367417b2b2512c77",
      "title": "Adjacency List",
      "description": [
        "Graphs can be represented in different ways. Here we describe one way, which is called an <dfn>adjacency list</dfn>.",
        "An adjacency list is essentially a bulleted list where the left side is the node and the right side lists all the other nodes it's connected to. Below is a representation of an adjacency list.",
        "<blockquote>Node1: Node2, Node3<br>Node2: Node1<br>Node3: Node1</blockquote>",
        "Above is an undirected graph because <code>Node1</code> is connected to <code>Node2</code> and <code>Node3</code>, and that information is consistent with the connections <code>Node2</code> and <code>Node3</code> show. An adjacency list for a directed graph would mean each row of the list shows direction. If the above was directed, then <code>Node2: Node1</code> would mean there the directed edge is pointing from <code>Node2</code> towards <code>Node1</code>.",
        "We can represent the undirected graph above as an adjacency list by putting it within a JavaScript object.",
        "<blockquote>var undirectedG = {<br>  Node1: [\"Node2\", \"Node3\"],<br>  Node2: [\"Node1\"],<br>  Node3: [\"Node1\"]<br>};</blockquote>",
        "This can also be more simply represented as an array where the nodes just have numbers rather than string labels.",
        "<blockquote>var undirectedGArr = [<br>  [1, 2], # Node1<br>  [0],    # Node2<br>  [0]     # Node3<br>];</blockquote>",
        "<hr>",
        "Create a social network as an undirected graph with 4 nodes/people named <code>James</code>, <code>Jill</code>, <code>Jenny</code>, and <code>Jeff</code>. There are edges/relationships between James and Jeff, Jill and Jenny, and Jeff and Jenny."
      ],
      "tests": [
        {
          "text": "<code>undirectedAdjList</code> should only contain four nodes.",
          "testString": "assert(Object.keys(undirectedAdjList).length === 4, '<code>undirectedAdjList</code> should only contain four nodes.');"
        },
        {
          "text": "There should be an edge between <code>Jeff</code> and <code>James</code>.",
          "testString": "assert(undirectedAdjList.James.indexOf(\"Jeff\") !== -1 && undirectedAdjList.Jeff.indexOf(\"James\") !== -1, 'There should be an edge between <code>Jeff</code> and <code>James</code>.');"
        },
        {
          "text": "There should be an edge between <code>Jill</code> and <code>Jenny</code>.",
          "testString": "assert(undirectedAdjList.Jill.indexOf(\"Jenny\") !== -1 && undirectedAdjList.Jill.indexOf(\"Jenny\") !== -1, 'There should be an edge between <code>Jill</code> and <code>Jenny</code>.');"
        },
        {
          "text": "There should be an edge between <code>Jeff</code> and <code>Jenny</code>.",
          "testString": "assert(undirectedAdjList.Jeff.indexOf(\"Jenny\") !== -1 && undirectedAdjList.Jenny.indexOf(\"Jeff\") !== -1, 'There should be an edge between <code>Jeff</code> and <code>Jenny</code>.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "var undirectedAdjList = {\n\"James\": [\"Jeff\"],\"Jill\": [\"Jenny\"],\"Jenny\": [\"Jill\", \"Jeff\"],\n\"Jeff\": [\"James\", \"Jenny\"]\n};"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var undirectedAdjList = {",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8256367417b2b2512c78",
      "title": "Adjacency Matrix",
      "description": [
        "Another way to represent a graph is to put it in an <dfn>adjacency matrix</dfn>.",
        "An <dfn>adjacency matrix</dfn> is a two-dimensional (2D) array where each nested array has the same number of elements as the outer array. In other words, it is a matrix or grid of numbers, where the numbers represent the edges. Zeros mean there is no edge or relationship.",
        "<blockquote>    1 2 3<br>   ------<br>1 | 0 1 1<br>2 | 1 0 0<br>3 | 1 0 0</blockquote>",
        "Above is a very simple, undirected graph where you have three nodes, where the first node is connected to the second and third node. <strong>Note</strong>: The numbers to the top and left of the matrix are just labels for the nodes.",
        "Below is a JavaScript implementation of the same thing.",
        "<blockquote>var adjMat = [<br>  [0, 1, 1],<br>  [1, 0, 0],<br>  [1, 0, 0]<br>];</blockquote>",
        "Unlike an adjacency list, each \"row\" of the matrix has to have the same number of elements as nodes in the graph. Here we have a three by three matrix, which means we have three nodes in our graph.",
        "A directed graph would look similar. Below is a graph where the first node has an edge pointing toward the second node, and then the second node has an edge pointing to the third node.",
        "<blockquote>var adjMatDirected = [<br>  [0, 1, 0],<br>  [0, 0, 1],<br>  [0, 0, 0]<br>];</blockquote>",
        "Graphs can also have <dfn>weights</dfn> on their edges. So far, we have <dfn>unweighted</dfn> edges where just the presence and lack of edge is binary (<code>0</code> or <code>1</code>). You can have different weights depending on your application.",
        "<hr>",
        "Create an adjacency matrix of an undirected graph with five nodes. This matrix should be in a multi-dimensional array. These five nodes have relationships between the first and fourth node, the first and third node, the third and fifth node, and the fourth and fifth node. All edge weights are one."
      ],
      "tests": [
        {
          "text": "<code>undirectedAdjList</code> should only contain five nodes.",
          "testString": "assert((adjMatUndirected.length === 5) && adjMatUndirected.map(function(x) { return x.length === 5 }).reduce(function(a, b) { return a && b }) , '<code>undirectedAdjList</code> should only contain five nodes.');"
        },
        {
          "text": "There should be an edge between the first and fourth node.",
          "testString": "assert((adjMatUndirected[0][3] === 1) && (adjMatUndirected[3][0] === 1), 'There should be an edge between the first and fourth node.');"
        },
        {
          "text": "There should be an edge between the first and third node.",
          "testString": "assert((adjMatUndirected[0][2] === 1) && (adjMatUndirected[2][0] === 1), 'There should be an edge between the first and third node.');"
        },
        {
          "text": "There should be an edge between the third and fifth node.",
          "testString": "assert((adjMatUndirected[2][4] === 1) && (adjMatUndirected[4][2] === 1), 'There should be an edge between the third and fifth node.');"
        },
        {
          "text": "There should be an edge between the fourth and fifth node.",
          "testString": "assert((adjMatUndirected[3][4] === 1) && (adjMatUndirected[4][3] === 1), 'There should be an edge between the fourth and fifth node.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "var adjMatUndirected = [[0, 0, 1, 1, 0],[0, 0, 0, 0, 0],[1, 0, 0, 0, 1],[1, 0, 0, 0, 1],[0, 0, 1, 1, 0]];"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var adjMatUndirected = [",
            "];"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8256367417b2b2512c79",
      "title": "Incidence Matrix",
      "description": [
        "Yet another way to represent a graph is to put it in an <dfn>incidence matrix.</dfn>",
        "An <dfn>incidence matrix</dfn> is a two-dimensional (2D) array. Generally speaking, an incidence matrix relates two different classes of objects between its two dimensions. This kind of matrix is similar to an adjacency matrix. However, the rows and columns mean something else here.",
        "In graphs, we have edges and nodes. These will be our \"two different classes of objects\". This matrix will have the rows be the nodes and columns be the edges. This means that we can have an uneven number of rows and columns.",
        "Each column will represent a unique edge. Also, each edge connects two nodes. To show that there is an edge between two nodes, you will put a 1 in the two rows of a particular column. Below is a 3 node graph with one edge between node 1 and node 3.",
        "<blockquote>    1<br>   ---<br>1 | 1<br>2 | 0<br>3 | 1</blockquote>",
        "Here is an example of an <code>incidence matrix</code> with 4 edges and 4 nodes. Remember, the columns are the edges and rows are the nodes themselves.",
        "<blockquote>    1 2 3 4<br>   --------<br>1 | 0 1 1 1<br>2 | 1 1 0 0<br>3 | 1 0 0 1<br>4 | 0 0 1 0</blockquote>",
        "Below is a JavaScript implementation of the same thing.",
        "<blockquote>var incMat = [<br>  [0, 1, 1, 1],<br>  [1, 1, 0, 0],<br>  [1, 0, 0, 1],<br>  [0, 0, 1, 0]<br>];</blockquote>",
        "To make a directed graph, use <code>-1</code> for an edge leaving a particular node and <code>1</code> for an edge entering a node.",
        "<blockquote>var incMatDirected = [<br>  [ 0, -1,  1, -1],<br>  [-1,  1,  0,  0],<br>  [ 1,  0,  0,  1],<br>  [ 0,  0, -1,  0]<br>];</blockquote>",
        "Graphs can also have <dfn>weights</dfn> on their edges. So far, we have <dfn>unweighted</dfn> edges where just the presence and lack of edge is binary (<code>0</code> or <code>1</code>). You can have different weights depending on your application. A different weight is represented as numbers greater than 1.",
        "<hr>",
        "Create an incidence matrix of an undirected graph with five nodes and four edges. This matrix should be in a multi-dimensional array.",
        "These five nodes have relationships following relationships. The first edge is between the first and second node. The second edge is between the second and third node. The third edge is between the third and fifth node. And four edge is between the fourth and second node. All edge weights are one and the edge order matters."
      ],
      "tests": [
        {
          "text": "<code>incMatUndirected</code> should only contain five nodes.",
          "testString": "assert((incMatUndirected.length === 5) && incMatUndirected.map(function(x) { return x.length === 4 }).reduce(function(a, b) { return a && b }) , '<code>incMatUndirected</code> should only contain five nodes.');"
        },
        {
          "text": "There should be a first edge between the first and second node.",
          "testString": "assert((incMatUndirected[0][0] === 1) && (incMatUndirected[1][0] === 1), 'There should be a first edge between the first and second node.');"
        },
        {
          "text": "There should be a second edge between the second and third node.",
          "testString": "assert((incMatUndirected[1][1] === 1) && (incMatUndirected[2][1] === 1), 'There should be a second edge between the second and third node.');"
        },
        {
          "text": "There should be a third edge between the third and fifth node.",
          "testString": "assert((incMatUndirected[2][2] === 1) && (incMatUndirected[4][2] === 1), 'There should be a third edge between the third and fifth node.');"
        },
        {
          "text": "There should be a fourth edge between the second and fourth node.",
          "testString": "assert((incMatUndirected[1][3] === 1) && (incMatUndirected[3][3] === 1), 'There should be a fourth edge between the second and fourth node.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "var incMatUndirected = [[1, 0, 0, 0],[1, 1, 0, 1],[0, 1, 1, 0],[0, 0, 0, 1],[0, 0, 1, 0]];"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var incMatUndirected = [",
            "  ",
            "];"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825c367417b2b2512c90",
      "title": "Breadth-First Search",
      "description": [
        "So far, we've learned different ways of creating representations of graphs. What now? One natural question to have is what are the distances between any two nodes in the graph? Enter <dfn>graph traversal algorithms</dfn>.",
        "<dfn>Traversal algorithms</dfn> are algorithms to traverse or visit nodes in a graph. One type of traversal algorithm is the breadth-first search algorithm.",
        "This algorithm starts at one node, first visits all its neighbors that are one edge away, then goes on to visiting each of their neighbors.",
        "Visually, this is what the algorithm is doing.",
        "<img class='img-responsive' src='https://camo.githubusercontent.com/2f57e6239884a1a03402912f13c49555dec76d06/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f342f34362f416e696d617465645f4246532e676966'>",
        "To implement this algorithm, you'll need to input a graph structure and a node you want to start at.",
        "First, you'll want to be aware of the distances from the start node. This you'll want to start all your distances initially some large number, like <code>Infinity</code>. This gives a reference for the case where a node may not be reachable from your start node.",
        "Next, you'll want to go from the start node to its neighbors. These neighbors are one edge away and at this point you should add one unit of distance to the distances you're keeping track of.",
        "Last, an important data structure that will help implement the breadth-first search algorithm is the queue. This is an array where you can add elements to one end and remove elements from the other end. This is also known as a <dfn>FIFO</dfn> or <dfn>First-In-First-Out</dfn> data structure.",
        "<hr>",
        "Write a function <code>bfs()</code> that takes an adjacency matrix graph (a two-dimensional array) and a node label root as parameters. The node label will just be the integer value of the node between <code>0</code> and <code>n - 1</code>, where <code>n</code> is the total number of nodes in the graph.",
        "Your function will output a JavaScript object key-value pairs with the node and its distance from the root. If the node could not be reached, it should have a distance of <code>Infinity</code>."
      ],
      "tests": [
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return <code>{0: 1, 1: 0, 2: 1, 3: 2}</code>",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]; var results = bfs(graph, 1); return isEquivalent(results, {0: 1, 1: 0, 2: 1, 3: 2})})(), 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return <code>{0: 1, 1: 0, 2: 1, 3: 2}</code>');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>1</code> should return <code>{0: 1, 1: 0, 2: 1, 3: Infinity}</code>",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]; var results = bfs(graph, 1); return isEquivalent(results, {0: 1, 1: 0, 2: 1, 3: Infinity})})(), 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>1</code> should return <code>{0: 1, 1: 0, 2: 1, 3: Infinity}</code>');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return <code>{0: 0, 1: 1, 2: 2, 3: 3}</code>",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]; var results = bfs(graph, 0); return isEquivalent(results, {0: 0, 1: 1, 2: 2, 3: 3})})(), 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return <code>{0: 0, 1: 1, 2: 2, 3: 3}</code>');"
        },
        {
          "text": "The input graph <code>[[0, 1], [1, 0]]</code> with a start node of <code>0</code> should return <code>{0: 0, 1: 1}</code>",
          "testString": "assert((function() { var graph = [[0, 1], [1, 0]]; var results = bfs(graph, 0); return isEquivalent(results, {0: 0, 1: 1})})(), 'The input graph <code>[[0, 1], [1, 0]]</code> with a start node of <code>0</code> should return <code>{0: 0, 1: 1}</code>');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function bfs(graph, root) {\n// Distance object returned\nvar nodesLen = {};\n// Set all distances to infinity\nfor (var i = 0; i < graph.length; i++) {\nnodesLen[i] = Infinity;\n}\nnodesLen[root] = 0; // ...except root node\nvar queue = [root]; // Keep track of nodes to visit\nvar current; // Current node traversing\n// Keep on going until no more nodes to traverse\nwhile (queue.length !== 0) {\ncurrent = queue.shift();\n// Get adjacent nodes from current node\nvar curConnected = graph[current]; // Get layer of edges from current\nvar neighborIdx = []; // List of nodes with edges\nvar idx = curConnected.indexOf(1); // Get first edge connection\nwhile (idx !== -1) {\nneighborIdx.push(idx); // Add to list of neighbors\nidx = curConnected.indexOf(1, idx + 1); // Keep on searching\n}\n// Loop through neighbors and get lengths\nfor (var j = 0; j < neighborIdx.length; j++) {\n// Increment distance for nodes traversed\nif (nodesLen[neighborIdx[j]] === Infinity) {\nnodesLen[neighborIdx[j]] = nodesLen[current] + 1;\nqueue.push(neighborIdx[j]); // Add new neighbors to queue\n}\n}\n}\nreturn nodesLen;}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function bfs(graph, root) {",
            "  // Distance object returned",
            "  var nodesLen = {};",
            "  ",
            "  return nodesLen;",
            "};",
            "",
            "var exBFSGraph = [",
            "  [0, 1, 0, 0],",
            "  [1, 0, 1, 0],",
            "  [0, 1, 0, 1],",
            "  [0, 0, 1, 0]",
            "];",
            "console.log(bfs(exBFSGraph, 3));"
          ],
          "head": [],
          "tail": [
            "// Source: http://adripofjavascript.com/blog/drips/object-equality-in-javascript.html",
            "function isEquivalent(a, b) {",
            "    // Create arrays of property names",
            "    var aProps = Object.getOwnPropertyNames(a);",
            "    var bProps = Object.getOwnPropertyNames(b);",
            "    // If number of properties is different,",
            "    // objects are not equivalent",
            "    if (aProps.length != bProps.length) {",
            "        return false;",
            "    }",
            "    for (var i = 0; i < aProps.length; i++) {",
            "        var propName = aProps[i];",
            "        // If values of same property are not equal,",
            "        // objects are not equivalent",
            "        if (a[propName] !== b[propName]) {",
            "            return false;",
            "        }",
            "    }",
            "    // If we made it this far, objects",
            "    // are considered equivalent",
            "    return true;",
            "}"
          ]
        }
      }
    },
    {
      "id": "587d825d367417b2b2512c96",
      "title": "Depth-First Search",
      "description": [
        "Similar to <dfn>breadth-first search</dfn>, here we will learn about another graph traversal algorithm called <dfn>depth-first search</dfn>.",
        "Whereas the breadth-first search searches incremental edge lengths away from the source node, <dfn>depth-first search</dfn> first goes down a path of edges as far as it can.",
        "Once it reaches one end of a path, the search will backtrack to the last node with an un-visited edge path and continue searching.",
        "Visually, this is what the algorithm is doing where the top node is the starting point of the search.",
        "<img class='img-responsive' src='https://camo.githubusercontent.com/aaad9e39961daf34d967c616edeb50abf3bf1235/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f372f37662f44657074682d46697273742d5365617263682e676966'>",
        "A simple output of this algorithm is a list of nodes which are reachable from a given node. So when implementing this algorithm, you'll need to keep track of the nodes you visit.",
        "<hr>",
        "Write a function <code>dfs()</code> that takes an undirected, adjacency matrix <code>graph</code> and a node label <code>root</code> as parameters. The node label will just be the numeric value of the node between <code>0</code> and <code>n - 1</code>, where <code>n</code> is the total number of nodes in the graph.",
        "Your function should output an array of all nodes reachable from <code>root</code>."
      ],
      "tests": [
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return an array with <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>.",
          "testString": "assert.sameMembers((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 1);})(), [0, 1, 2, 3], 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return an array with <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return an array with four elements.",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 1);})().length === 4, 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return an array with four elements.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>3</code> should return an array with <code>3</code>.",
          "testString": "assert.sameMembers((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]; return dfs(graph, 3);})(), [3], 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>3</code> should return an array with <code>3</code>.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>3</code> should return an array with one element.",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]; return dfs(graph, 3);})().length === 1, 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>3</code> should return an array with one element.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>3</code> should return an array with <code>2</code> and <code>3</code>.",
          "testString": "assert.sameMembers((function() { var graph = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 3);})(), [2, 3], 'The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>3</code> should return an array with <code>2</code> and <code>3</code>.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>3</code> should return an array with two elements.",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 3);})().length === 2, 'The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>3</code> should return an array with two elements.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return an array with <code>0</code> and <code>1</code>.",
          "testString": "assert.sameMembers((function() { var graph = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 0);})(), [0, 1], 'The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return an array with <code>0</code> and <code>1</code>.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return an array with two elements.",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 0);})().length === 2, 'The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return an array with two elements.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function dfs(graph, root) { var stack = []; var tempV; var visited = []; var tempVNeighbors = []; stack.push(root); while (stack.length > 0) { tempV = stack.pop(); if (visited.indexOf(tempV) == -1) { visited.push(tempV); tempVNeighbors = graph[tempV]; for (var i = 0; i < tempVNeighbors.length; i++) { if (tempVNeighbors[i] == 1) { stack.push(i); }}}} return visited;}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function dfs(graph, root) {",
            "  ",
            "}",
            "",
            "var exDFSGraph = [",
            "  [0, 1, 0, 0],",
            "  [1, 0, 1, 0],",
            "  [0, 1, 0, 1],",
            "  [0, 0, 1, 0]",
            "];",
            "console.log(dfs(exDFSGraph, 3));"
          ],
          "head": [],
          "tail": []
        }
      }
    }
  ]
}