{
  "name": "Basic Data Structures",
  "order": 5,
  "time": "1 hour",
  "helpRoom": "Help",
  "challenges": [
    {
      "id": "587d7b7e367417b2b2512b20",
      "title": "Use an Array to Store a Collection of Data",
      "description": [
        "以下是数组（Array）数据结构的最简单的实现的一个例子。这是一个 <dfn>一维数组</dfn>（<dfn>one-dimensional Array</dfn>），它只有一层，或者说它里面没有包含其它的数组。您可以看到它包含了 <dfn>布尔值</dfn>（<dfn>booleans</dfn>）、<dfn>字符串</dfn>（<dfn>strings</dfn>）、<dfn>数字</dfn>（<dfn>numbers</dfn>） 以及 JavaScript 中其他合法的数据类型：",
        "<blockquote>let simpleArray = ['one', 2, 'three’, true, false, undefined, null];<br>console.log(simpleArray.length);<br>// logs 7</blockquote>",
        "您可以在上述例子中看到，所有数组都有一个长度（length）属性。您可以简单地使用 <code>Array.length</code> 方法来访问它。",
        "下面是一个更复杂一点的数组的例子。这是一个 <dfn>多维数组</dfn>（<dfn>multi-dimensional Array</dfn>），或者说是一个包含了其他数组的数组。您可以注意到，它还包含了 JavaScript 中的 <dfn>对象</dfn>（<dfn>objects</dfn>）。我们会在接下来的一节中讨论 JavaScript 对象变量，但现在您只需要知道数组能够存储复杂的对象。",
        "<blockquote>let complexArray = [<br>&nbsp;&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two: 2<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;three: 3,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;four: 4<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;],<br>&nbsp;&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a: \"a\",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: \"b\"<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c: \"c\",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d: “d”<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;]<br>];</blockquote>",
        "<hr>",
        "我们已经定义了一个 <code>yourArray</code> 变量。请修改题目中的语句，将一个含有至少5个元素的数组赋值给 <code>yourArray</code> 变量。您的数组应该包含至少一个 <dfn>string</dfn>、一个 <dfn>number</dfn> 和一个 <dfn>boolean</dfn>."
      ],
      "tests": [
        {
          "text": "yourArray 应该是一个数组",
          "testString": "assert.strictEqual(Array.isArray(yourArray), true, 'yourArray 应该是一个数组');"
        },
        {
          "text": "<code>yourArray</code> 至少要包含5个元素",
          "testString": "assert.isAtLeast(yourArray.length, 5, '<code>yourArray</code> 至少要包含5个元素');"
        },
        {
          "text": "<code>yourArray</code> 应该包含至少一个 <code>boolean</code>",
          "testString": "assert(yourArray.filter( el => typeof el === 'boolean').length >= 1, '<code>yourArray</code> 应该包含至少一个 <code>boolean</code>');"
        },
        {
          "text": "<code>yourArray</code> 应该包含至少一个 <code>number</code>",
          "testString": "assert(yourArray.filter( el => typeof el === 'number').length >= 1, '<code>yourArray</code> 应该包含至少一个 <code>number</code>');"
        },
        {
          "text": "<code>yourArray</code> 应该包含至少一个 <code>string</code>",
          "testString": "assert(yourArray.filter( el => typeof el === 'string').length >= 1, '<code>yourArray</code> 应该包含至少一个 <code>string</code>');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let yourArray; // change this line"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "5a661e0f1068aca922b3ef17",
      "title": "Access an Array's Contents Using Bracket Notation",
      "description": [
        "所有数据结构的基本特性是，不仅能够存储数据，还能够按需从中获取这些数据。我们已经学习了如何创建一个数组，现在让我们开始考虑如何访问数据中的信息。",
        "我们先定义一个包含 3 个元素的数组：",
        "<blockquote>let ourArray = [\"a\", \"b\", \"c\"];</blockquote>",
        "在一个数组里，每个元素都有一个 <dfn>索引</dfn>（<dfn>index</dfn>）。索引是该元素在数组中的位置，可被用于引用该元素。但是您要注意，JavaScript 数组的索引是从0开始的（<dfn>zero-indexed</dfn>），即一个数组的第一个元素是在数组中的 <em><strong>第0个</strong></em> 位置而不是第一个位置。",
        "要从一个数组中获取一个元素，我们可以在一个数组变量名的后面加一个用方括号括起来的索引。这叫做 <dfn>方括号符号</dfn>（<dfn>bracket notation</dfn>）。",
        "例如我们要从  <code>ourArray</code> 中获取 <code>\"a\"</code> 并将它赋值给一个变量，我们可以编写如下代码：",
        "<blockquote>let ourVariable = ourArray[0];<br>// ourVariable equals \"a\"</blockquote>",
        "除了用索引来获取一个元素的值，您还可以用方括号符号 <em>设置</em> 一个索引对应的元素的值：",
        "<blockquote>ourArray[1] = \"not b anymore\";<br>// ourArray now equals [\"a\", \"not b anymore\", \"c\"];</blockquote>",
        "我们现在已经利用方括号将索引为 1 的元素从 <code>\"b\"</code> 设置为了 <code>\"not b anymore\"</code>。",
        "<hr>",
        "在本挑战中，请您将 <code>myArray</code> 中第二个元素（索引 <code>1</code>）设置为除了 <code>\"b\"</code> 以外的任意值。"
      ],
      "tests": [
        {
          "text": "<code>myArray[0]</code> 必须等于 <code>\"a\"</code>",
          "testString": "assert.strictEqual(myArray[0], \"a\", '<code>myArray[0]</code> 必须等于 <code>\"a\"</code>');"
        },
        {
          "text": "<code>myArray[1]</code> 不能再等于 <code>\"b\"</code>",
          "testString": "assert.notStrictEqual(myArray[1], \"b\", '<code>myArray[1]</code> 不能再等于 <code>\"b\"</code>');"
        },
        {
          "text": "<code>myArray[2]</code> 必须等于 <code>\"c\"</code>",
          "testString": "assert.strictEqual(myArray[2], \"c\", '<code>myArray[2]</code> 必须等于 <code>\"c\"</code>');"
        },
        {
          "text": "<code>myArray[3]</code> 必须等于 <code>\"d\"</code>",
          "testString": "assert.strictEqual(myArray[3], \"d\", '<code>myArray[3]</code> 必须等于 <code>\"d\"</code>');"
        }
      ],
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let myArray = [\"a\", \"b\", \"c\", \"d\"];",
            "// change code below this line",
            "",
            "//change code above this line",
            "console.log(myArray);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d78b2367417b2b2512b0e",
      "title": "Add Items to an Array with push() and unshift()",
      "description": [
        "一个数组的长度与其包含的数据类型一样，是不固定的。数组可以包含任意数量的元素，您可以不限次数地往数组中添加元素或者从中移除元素，或者说数组是 <dfn>可变的</dfn>（<dfn>mutable</dfn>）。在本挑战中，我们要学习两个以编程方式修改数组的方法： <code>Array.push()</code> 和 <code>Array.unshift()</code>。",
        "这两个方法的输入参数都可以是一个或多个元素；对一个数组调用这两个方法都可以将输入的元素插入到该数组中；<code>push()</code> 方法将元素插入到一个数组的末尾，而 <code>unshift()</code> 方法将元素插入到一个数组的开头。请看以下例子：",
        "<blockquote>let twentyThree = 'XXIII';<br>let romanNumerals = ['XXI', 'XXII'];<br><br>romanNumerals.unshift('XIX', 'XX');<br>// now equals ['XIX', 'XX', 'XXI', 'XXII']<br><br>romanNumerals.push(twentyThree);<br>// now equals ['XIX', 'XX', 'XXI', 'XXII', 'XXIII']",
        "注意，我们还可以输入变量，这允许我们很灵活地动态改变我们数组中的数据。",
        "<hr>",
        "我们已经定义了一个 <code>mixedNumbers</code> 函数，它会接受一个数组作为输入参数。请您修改这个函数，使用 <code>push()</code> 和 <code>unshift()</code> 来将 <code>'I', 2, 'three'</code> 插入到输入的数组的开头，将 <code>7, 'VIII', 9</code> 插入到数组的末尾，使得这个函数返回一个依次包含 1-9 的数组。"
      ],
      "tests": [
        {
          "text": "<code>mixedNumbers([\"IV\", 5, \"six\"])</code> 现在应该返回 <code>[\"I\", 2, \"three\", \"IV\", 5, \"six\", 7, \"VIII\", 9]</code>",
          "testString": "assert.deepEqual(mixedNumbers(['IV', 5, 'six']), ['I', 2, 'three', 'IV', 5, 'six', 7, 'VIII', 9], '<code>mixedNumbers([\"IV\", 5, \"six\"])</code> 现在应该返回 <code>[\"I\", 2, \"three\", \"IV\", 5, \"six\", 7, \"VIII\", 9]</code>');"
        },
        {
          "text": "<code>mixedNumbers</code> 函数中应该用到 <code>push()</code> 方法",
          "testString": "assert.notStrictEqual(mixedNumbers.toString().search(/\\.push\\(/), -1, '<code>mixedNumbers</code> 函数中应该用到 <code>push()</code> 方法');"
        },
        {
          "text": "<code>mixedNumbers</code> 函数中应该用到 <code>unshift()</code> 方法",
          "testString": "assert.notStrictEqual(mixedNumbers.toString().search(/\\.unshift\\(/), -1, '<code>mixedNumbers</code> 函数中应该用到 <code>unshift()</code> 方法');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function mixedNumbers(arr) {",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "  return arr;",
            "}",
            "",
            "// do not change code below this line",
            "console.log(mixedNumbers(['IV', 5, 'six']));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d78b2367417b2b2512b0f",
      "title": "Remove Items from an Array with pop() and shift()",
      "description": [
        "<code>push()</code> 和 <code>unshift()</code> 都分别有一个作用基本与之相反的函数：<code>pop()</code> 和 <code>shift()</code>。您现在或许已经猜到，与插入元素相反，<code>pop()</code> 从数组的末尾 <em>移除</em> 一个元素，而 <code>shift()</code> 从数组的开头移除一个元素。<code>pop()</code> 与 <code>shift()</code> 以及对应的 <code>push()</code> 与 <code>unshift()</code> 的关键不同点是，前者不能接受一个参数，而且每次只能修改数组中的一个元素。",
        "让我们来看如下例子：",
        "<blockquote>let greetings = ['whats up?', 'hello', 'see ya!'];<br><br>greetings.pop();<br>// 现在等于 ['whats up?', 'hello']<br><br>greetings.shift();<br>// 现在等于 ['hello']</blockquote>",
        "对于上述两个方法中的任意一个，我们都可以返回被其移除的元素：",
        "<blockquote>let popped = greetings.pop();<br>// 返回 'hello'<br>// greetings 现在等于 []</blockquote>",
        "<hr>",
        "我们已经定义了一个 <code>popShift</code> 函数，它会接收一个数组作为输入参数并返回一个新的数组。请您修改这个函数，使用 <code>pop()</code> 和 <code>shift()</code> 来移除输入的数组的第一个元素和最后一个元素，并将这两个被移除的元素赋值给对应的变量，使得返回的数组包含它们的值。"
      ],
      "tests": [
        {
          "text": "<code>popShift([\"challenge\", \"is\", \"not\", \"complete\"])</code> 应该返回 <code>[\"challenge\", \"complete\"]</code>",
          "testString": "assert.deepEqual(popShift(['challenge', 'is', 'not', 'complete']), [\"challenge\", \"complete\"], '<code>popShift([\"challenge\", \"is\", \"not\", \"complete\"])</code> 应该返回 <code>[\"challenge\", \"complete\"]</code>');"
        },
        {
          "text": "<code>popShift</code> 函数应该用到 <code>pop()</code> 方法",
          "testString": "assert.notStrictEqual(popShift.toString().search(/\\.pop\\(/), -1, '<code>popShift</code> 函数应该用到 <code>pop()</code> 方法');"
        },
        {
          "text": "<code>popShift</code> 函数应该用到 <code>shift()</code> 方法",
          "testString": "assert.notStrictEqual(popShift.toString().search(/\\.shift\\(/), -1, '<code>popShift</code> 函数应该用到 <code>shift()</code> 方法');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function popShift(arr) {",
            "  let popped; // change this line",
            "  let shifted; // change this line",
            "  return [shifted, popped];",
            "}",
            "",
            "// do not change code below this line",
            "console.log(popShift(['challenge', 'is', 'not', 'complete']));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d78b2367417b2b2512b10",
      "title": "Remove Items Using splice()",
      "description": [
        "Ok，我们已经学到了如何利用 <code>shift()</code> 和 <code>pop()</code> 从数组的开头或者末尾移除元素，但如果我们想移除数组中间的一个元素呢？或者想一次移除多个元素呢？这时候我们就需要 <code>splice()</code> 了。<code>splice()</code> 让我们可以从数组中的任意位置 <strong>移除任意数量的连续的元素</strong>。",
        "<code>splice()</code> 最多可以接受 3 个参数，但现在我们先关注前两个。<code>splice()</code> 的前两个参数是代表被调用 <code>splice()</code> 的数组中的索引或者位置的整数。记住，数组的索引是 <em>从0开始的</em>（<em>zero-indexed</em>），所以我们要用 <code>0</code> 来指示数组中的第一个元素。<code>splice()</code> 的第一个参数代表从数组中的哪个索引开始移除元素，而第二个参数指示要从数组中删除多少个元素。例如：",
        "<blockquote>let array = ['today', 'was', 'not', 'so', 'great'];<br><br>array.splice(2, 2);<br>// 从第 3 个元素开始，删除 2 个元素<br>// 现在该数组等于 ['today', 'was', 'great']</blockquote>",
        "<code>splice()</code> 不仅从被调用的数组中移除元素，还会返回一个包含被移除元素的数组：",
        "<blockquote>let array = ['I', 'am', 'feeling', 'really', 'happy'];<br><br>let newArray = array.splice(3, 2);<br>// newArray 等于 ['really', 'happy']</blockquote>",
        "<hr>",
        "我们已经定义了一个 <code>sumOfTen</code> 函数，它接受一个数组作为输入参数，并返回数组中所有元素的和。请您修改这个函数，利用 <code>splice()</code>，使得它返回 <code>10</code>。"
      ],
      "tests": [
        {
          "text": "<code>sumOfTen</code> 应该返回 10",
          "testString": "assert.strictEqual(sumOfTen([2, 5, 1, 5, 2, 1]), 10, '<code>sumOfTen</code> 应该返回 10');"
        },
        {
          "text": "<code>sumOfTen</code> 函数应该用到 <code>splice()</code> 方法",
          "testString": "assert.notStrictEqual(sumOfTen.toString().search(/\\.splice\\(/), -1, '<code>sumOfTen</code> 函数应该用到 <code>splice()</code> 方法');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function sumOfTen(arr) {",
            "  // change code below this line",
            "  ",
            "  // change code above this line",
            "  return arr.reduce((a, b) => a + b);",
            "}",
            "",
            "// do not change code below this line",
            "console.log(sumOfTen([2, 5, 1, 5, 2, 1]));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d78b3367417b2b2512b11",
      "title": "Add Items Using splice()",
      "description": [
        "Remember in the last challenge we mentioned that <code>splice()</code> can take up to three parameters? Well, we can go one step further with <code>splice()</code> &mdash; in addition to removing elements, we can use that third parameter, which represents one or more elements, to <em>add</em> them as well. This can be incredibly useful for quickly switching out an element, or a set of elements, for another. For instance, let's say you're storing a color scheme for a set of DOM elements in an array, and want to dynamically change a color based on some action:",
        "<blockquote>function colorChange(arr, index, newColor) {<br>&nbsp;&nbsp;arr.splice(index, 1, newColor);<br>&nbsp;&nbsp;return arr;<br>}<br><br>let colorScheme = ['#878787', '#a08794', '#bb7e8c', '#c9b6be', '#d1becf'];<br><br>colorScheme = colorChange(colorScheme, 2, '#332327');<br>// we have removed '#bb7e8c' and added '#332327' in its place<br>// colorScheme now equals ['#878787', '#a08794', '#332327', '#c9b6be', '#d1becf']</blockquote>",
        "This function takes an array of hex values, an index at which to remove an element, and the new color to replace the removed element with. The return value is an array containing a newly modified color scheme! While this example is a bit oversimplified, we can see the value that utilizing <code>splice()</code> to its maximum potential can have.",
        "<hr>",
        "We have defined a function, <code>htmlColorNames</code>, which takes an array of HTML colors as an argument. Modify the function using <code>splice()</code> to remove the first two elements of the array and add <code>'DarkSalmon'</code> and <code>'BlanchedAlmond'</code> in their respective places."
      ],
      "tests": [
        {
          "text": "<code>htmlColorNames</code> 应该返回 <code>[\"DarkSalmon\", \"BlanchedAlmond\", \"LavenderBlush\", \"PaleTurqoise\", \"FireBrick\"]</code>",
          "testString": "assert.deepEqual(htmlColorNames(['DarkGoldenRod', 'WhiteSmoke', 'LavenderBlush', 'PaleTurqoise', 'FireBrick']), ['DarkSalmon', 'BlanchedAlmond', 'LavenderBlush', 'PaleTurqoise', 'FireBrick'], '<code>htmlColorNames</code> 应该返回 <code>[\"DarkSalmon\", \"BlanchedAlmond\", \"LavenderBlush\", \"PaleTurqoise\", \"FireBrick\"]</code>');"
        },
        {
          "text": "<code>htmlColorNames</code> 函数中应该用到 <code>splice()</code> 方法",
          "testString": "assert(/.splice/.test(code), '<code>htmlColorNames</code> 函数中应该用到 <code>splice()</code> 方法');"
        },
        {
          "text": "您不能使用 <code>shift()</code> 或者 <code>unshift()</code>.",
          "testString": "assert(!/shift|unshift/.test(code), '您不能使用 <code>shift()</code> 或者 <code>unshift()</code>.');"
        },
        {
          "text": "您不能使用数组的方括号符号.",
          "testString": "assert(!/\\[\\d\\]\\s*=/.test(code), '您不能使用数组的方括号符号.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function htmlColorNames(arr) {",
            "  // change code below this line",
            "  ",
            "  // change code above this line",
            "  return arr;",
            "} ",
            " ",
            "// do not change code below this line",
            "console.log(htmlColorNames(['DarkGoldenRod', 'WhiteSmoke', 'LavenderBlush', 'PaleTurqoise', 'FireBrick']));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7a367417b2b2512b12",
      "title": "Copy Array Items Using slice()",
      "description": [
        "The next method we will cover is <code>slice()</code>. <code>slice()</code>, rather than modifying an array, copies, or <em>extracts</em>, a given number of elements to a new array, leaving the array it is called upon untouched. <code>slice()</code> takes only 2 parameters &mdash; the first is the index at which to begin extraction, and the second is the index at which to stop extraction (extraction will occur up to, but not including the element at this index). Consider this:",
        "<blockquote>let weatherConditions = ['rain', 'snow', 'sleet', 'hail', 'clear'];<br><br>let todaysWeather = weatherConditions.slice(1, 3);<br>// todaysWeather equals ['snow', 'sleet'];<br>// weatherConditions still equals ['rain', 'snow', 'sleet', 'hail', 'clear']<br></blockquote>",
        "In effect, we have created a new array by extracting elements from an existing array.",
        "<hr>",
        "We have defined a function, <code>forecast</code>, that takes an array as an argument. Modify the function using <code>slice()</code> to extract information from the argument array and return a new array that contains the elements <code>'warm'</code> and <code>'sunny'</code>."
      ],
      "tests": [
        {
          "text": "<code>forecast</code> 应该返回 <code>[\"warm\", \"sunny\"]",
          "testString": "assert.deepEqual(forecast(['cold', 'rainy', 'warm', 'sunny', 'cool', 'thunderstorms']), ['warm', 'sunny'], '<code>forecast</code> 应该返回 <code>[\"warm\", \"sunny\"]');"
        },
        {
          "text": "<code>forecast</code> 函数中应该用到 <code>slice()</code> 方法",
          "testString": "assert(/\\.slice\\(/.test(code), '<code>forecast</code> 函数中应该用到 <code>slice()</code> 方法');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function forecast(arr) {",
            "  // change code below this line",
            "  ",
            "  return arr;",
            "}",
            "",
            "// do not change code below this line",
            "console.log(forecast(['cold', 'rainy', 'warm', 'sunny', 'cool', 'thunderstorms']));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7b367417b2b2512b13",
      "title": "Copy an Array with the Spread Operator",
      "description": [
        "While <code>slice()</code> allows us to be selective about what elements of an array to copy, among several other useful tasks, ES6's new <dfn>spread operator</dfn> allows us to easily copy <em>all</em> of an array's elements, in order, with a simple and highly readable syntax. The spread syntax simply looks like this: <code>...</code>",
        "In practice, we can use the spread operator to copy an array like so:",
        "<blockquote>let thisArray = [true, true, undefined, false, null];<br>let thatArray = [...thisArray];<br>// thatArray equals [true, true, undefined, false, null]<br>// thisArray remains unchanged, and is identical to thatArray</blockquote>",
        "<hr>",
        "We have defined a function, <code>copyMachine</code> which takes <code>arr</code> (an array) and <code>num</code> (a number) as arguments. The function is supposed to return a new array made up of <code>num</code> copies of <code>arr</code>. We have done most of the work for you, but it doesn't work quite right yet. Modify the function using spread syntax so that it works correctly (hint: another method we have already covered might come in handy here!)."
      ],
      "tests": [
        {
          "text": "<code>copyMachine([true, false, true], 2)</code> 应该返回 <code>[[true, false, true], [true, false, true]]</code>",
          "testString": "assert.deepEqual(copyMachine([true, false, true], 2), [[true, false, true], [true, false, true]], '<code>copyMachine([true, false, true], 2)</code> 应该返回 <code>[[true, false, true], [true, false, true]]</code>');"
        },
        {
          "text": "<code>copyMachine([1, 2, 3], 5)</code> 应该返回 <code>[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]</code>",
          "testString": "assert.deepEqual(copyMachine([1, 2, 3], 5), [[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]], '<code>copyMachine([1, 2, 3], 5)</code> 应该返回 <code>[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]</code>');"
        },
        {
          "text": "<code>copyMachine([true, true, null], 1)</code> 应该返回 <code>[[true, true, null]]</code>",
          "testString": "assert.deepEqual(copyMachine([true, true, null], 1), [[true, true, null]], '<code>copyMachine([true, true, null], 1)</code> 应该返回 <code>[[true, true, null]]</code>');"
        },
        {
          "text": "<code>copyMachine([\"it works\"], 3)</code> 应该返回 <code>[[\"it works\"], [\"it works\"], [\"it works\"]]</code>",
          "testString": "assert.deepEqual(copyMachine(['it works'], 3), [['it works'], ['it works'], ['it works']], '<code>copyMachine([\"it works\"], 3)</code> 应该返回 <code>[[\"it works\"], [\"it works\"], [\"it works\"]]</code>');"
        },
        {
          "text": "The <code>copyMachine</code> function should utilize the <code>spread operator</code> with array <code>arr</code>",
          "testString": "assert.notStrictEqual(copyMachine.toString().indexOf('.concat(_toConsumableArray(arr))'), -1, 'The <code>copyMachine</code> function should utilize the <code>spread operator</code> with array <code>arr</code>');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function copyMachine(arr, num) {",
            "  let newArr = [];",
            "  while (num >= 1) {",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "    num--;",
            "  }",
            "  return newArr;",
            "}",
            "",
            "// change code here to test different cases:",
            "console.log(copyMachine([true, false, true], 2));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7b367417b2b2512b17",
      "title": "Combine Arrays with the Spread Operator",
      "description": [
        "Another huge advantage of the <dfn>spread</dfn> operator, is the ability to combine arrays, or to insert all the elements of one array into another, at any index. With more traditional syntaxes, we can concatenate arrays, but this only allows us to combine arrays at the end of one, and at the start of another. Spread syntax makes the following operation extremely simple:",
        "<blockquote>let thisArray = ['sage', 'rosemary', 'parsley', 'thyme'];<br><br>let thatArray = ['basil', 'cilantro', ...thisArray, 'coriander'];<br>// thatArray now equals ['basil', 'cilantro', 'sage', 'rosemary', 'parsley', 'thyme', 'coriander']</blockquote>",
        "Using spread syntax, we have just achieved an operation that would have been more more complex and more verbose had we used traditional methods.",
        "<hr>",
        "We have defined a function <code>spreadOut</code> that returns the variable <code>sentence</code>, modify the function using the <dfn>spread</dfn> operator so that it returns the array <code>['learning', 'to', 'code', 'is', 'fun']</code>."
      ],
      "tests": [
        {
          "text": "<code>spreadOut</code> 应该返回 <code>[\"learning\", \"to\", \"code\", \"is\", \"fun\"]</code>",
          "testString": "assert.deepEqual(spreadOut(), ['learning', 'to', 'code', 'is', 'fun'], '<code>spreadOut</code> 应该返回 <code>[\"learning\", \"to\", \"code\", \"is\", \"fun\"]</code>');"
        },
        {
          "text": "The <code>spreadOut</code> function should utilize spread syntax",
          "testString": "assert.notStrictEqual(spreadOut.toString().search(/[...]/), -1, 'The <code>spreadOut</code> function should utilize spread syntax');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function spreadOut() {",
            "  let fragment = ['to', 'code'];",
            "  let sentence; // change this line",
            "  return sentence;",
            "}",
            "",
            "// do not change code below this line",
            "console.log(spreadOut());"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7b367417b2b2512b14",
      "title": "Check For The Presence of an Element With indexOf()",
      "description": [
        "Since arrays can be changed, or <em>mutated</em>, at any time, there's no guarantee about where a particular piece of data will be on a given array, or if that element even still exists. Luckily, JavaScript provides us with another built-in method, <code>indexOf()</code>, that allows us to quickly and easily check for the presence of an element on an array. <code>indexOf()</code> takes an element as a parameter, and when called, it returns the position, or index, of that element, or <code>-1</code> if the element does not exist on the array.",
        "For example:",
        "<blockquote>let fruits = ['apples', 'pears', 'oranges', 'peaches', 'pears'];<br><br>fruits.indexOf('dates') // returns -1<br>fruits.indexOf('oranges') // returns 2<br>fruits.indexOf('pears') // returns 1, the first index at which the element exists</blockquote>",
        "<hr>",
        "<code>indexOf()</code> can be incredibly useful for quickly checking for the presence of an element on an array. We have defined a function, <code>quickCheck</code>, that takes an array and an element as arguments. Modify the function using <code>indexOf()</code> so that it returns <code>true</code> if the passed element exists on the array, and <code>false</code> if it does not."
      ],
      "tests": [
        {
          "text": "<code>quickCheck([\"squash\", \"onions\", \"shallots\"], \"mushrooms\")</code> 应该返回 <code>false</code>",
          "testString": "assert.strictEqual(quickCheck(['squash', 'onions', 'shallots'], 'mushrooms'), false, '<code>quickCheck([\"squash\", \"onions\", \"shallots\"], \"mushrooms\")</code> 应该返回 <code>false</code>');"
        },
        {
          "text": "<code>quickCheck([\"squash\", \"onions\", \"shallots\"], \"onions\")</code> 应该返回 <code>true</code>",
          "testString": "assert.strictEqual(quickCheck(['squash', 'onions', 'shallots'], 'onions'), true, '<code>quickCheck([\"squash\", \"onions\", \"shallots\"], \"onions\")</code> 应该返回 <code>true</code>');"
        },
        {
          "text": "<code>quickCheck([3, 5, 9, 125, 45, 2], 125)</code> 应该返回 <code>true</code>",
          "testString": "assert.strictEqual(quickCheck([3, 5, 9, 125, 45, 2], 125), true, '<code>quickCheck([3, 5, 9, 125, 45, 2], 125)</code> 应该返回 <code>true</code>');"
        },
        {
          "text": "<code>quickCheck([true, false, false], undefined)</code> 应该返回 <code>false</code>",
          "testString": "assert.strictEqual(quickCheck([true, false, false], undefined), false, '<code>quickCheck([true, false, false], undefined)</code> 应该返回 <code>false</code>');"
        },
        {
          "text": "The <code>quickCheck</code> function should utilize the <code>indexOf()</code> method",
          "testString": "assert.notStrictEqual(quickCheck.toString().search(/\\.indexOf\\(/), -1, 'The <code>quickCheck</code> function should utilize the <code>indexOf()</code> method');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function quickCheck(arr, elem) {",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "}",
            "",
            "// change code here to test different cases:",
            "console.log(quickCheck(['squash', 'onions', 'shallots'], 'mushrooms'));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7b367417b2b2512b15",
      "title": "Iterate Through All an Array's Items Using For Loops",
      "description": [
        "Sometimes when working with arrays, it is very handy to be able to iterate through each item to find one or more elements that we might need, or to manipulate an array based on which data items meet a certain set of criteria. JavaScript offers several built in methods that each iterate over arrays in slightly different ways to achieve different results (such as <code>every()</code>, <code>forEach()</code>, <code>map()</code>, etc.), however the technique which is most flexible and offers us the greatest amount of control is a simple <code>for</code> loop.",
        "Consider the following:",
        "<blockquote>function greaterThanTen(arr) {<br>&nbsp;&nbsp;let newArr = [];<br>&nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] > 10) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr.push(arr[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return newArr;<br>}<br><br>greaterThanTen([2, 12, 8, 14, 80, 0, 1]);<br>// returns [12, 14, 80]</blockquote>",
        "Using a <code>for</code> loop, this function iterates through and accesses each element of the array, and subjects it to a simple test that we have created. In this way, we have easily and programmatically determined which data items are greater than <code>10</code>, and returned a new array containing those items.",
        "<hr>",
        "We have defined a function, <code>filteredArray</code>, which takes <code>arr</code>, a nested array, and <code>elem</code> as arguments, and returns a new array. <code>elem</code> represents an element that may or may not be present on one or more of the arrays nested within <code>arr</code>. Modify the function, using a <code>for</code> loop, to return a filtered version of the passed array such that any array nested within <code>arr</code> containing <code>elem</code> has been removed."
      ],
      "tests": [
        {
          "text": "<code>filteredArray([[10, 8, 3], [14, 6, 23], [3, 18, 6]], 18)</code> 应该返回 <code>[ [10, 8, 3], [14, 6, 23] ]</code>",
          "testString": "assert.deepEqual(filteredArray([ [10, 8, 3], [14, 6, 23], [3, 18, 6] ], 18), [[10, 8, 3], [14, 6, 23]], '<code>filteredArray([[10, 8, 3], [14, 6, 23], [3, 18, 6]], 18)</code> 应该返回 <code>[ [10, 8, 3], [14, 6, 23] ]</code>');"
        },
        {
          "text": "<code>filteredArray([ [\"trumpets\", 2], [\"flutes\", 4], [\"saxophones\", 2] ], 2)</code> 应该返回 <code>[ [\"flutes\", 4] ]</code>",
          "testString": "assert.deepEqual(filteredArray([ ['trumpets', 2], ['flutes', 4], ['saxophones', 2] ], 2), [['flutes', 4]], '<code>filteredArray([ [\"trumpets\", 2], [\"flutes\", 4], [\"saxophones\", 2] ], 2)</code> 应该返回 <code>[ [\"flutes\", 4] ]</code>');"
        },
        {
          "text": "<code>filteredArray([ [\"amy\", \"beth\", \"sam\"], [\"dave\", \"sean\", \"peter\"] ], \"peter\")</code> 应该返回 <code>[ [\"amy\", \"beth\", \"sam\"] ]</code>",
          "testString": "assert.deepEqual(filteredArray([['amy', 'beth', 'sam'], ['dave', 'sean', 'peter']], 'peter'), [['amy', 'beth', 'sam']], '<code>filteredArray([ [\"amy\", \"beth\", \"sam\"], [\"dave\", \"sean\", \"peter\"] ], \"peter\")</code> 应该返回 <code>[ [\"amy\", \"beth\", \"sam\"] ]</code>');"
        },
        {
          "text": "<code>filteredArray([[3, 2, 3], [1, 6, 3], [3, 13, 26], [19, 3, 9]], 3)</code> 应该返回 <code>[ ]</code>",
          "testString": "assert.deepEqual(filteredArray([[3, 2, 3], [1, 6, 3], [3, 13, 26], [19, 3, 9]], 3), [], '<code>filteredArray([[3, 2, 3], [1, 6, 3], [3, 13, 26], [19, 3, 9]], 3)</code> 应该返回 <code>[ ]</code>');"
        },
        {
          "text": "The <code>filteredArray</code> function should utilize a <code>for</code> loop",
          "testString": "assert.notStrictEqual(filteredArray.toString().search(/for/), -1, 'The <code>filteredArray</code> function should utilize a <code>for</code> loop');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function filteredArray(arr, elem) {",
            "  let newArr = [];",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "  return newArr;",
            "}",
            "",
            "// change code here to test different cases:",
            "console.log(filteredArray([[3, 2, 3], [1, 6, 3], [3, 13, 26], [19, 3, 9]], 3));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7b367417b2b2512b16",
      "title": "Create complex multi-dimensional arrays",
      "description": [
        "很好！您已经学到很多关于数组的知识了！但这些只是一个大概，您还有很多关于数组的东西要学，您将在接下来的小节中看到很多这些新知识。但在您继续去学习<dfn>对象</dfn>（<dfn>Objects</dfn>）之前，让我们再花一点时间看一看，数组怎样能够变得比之前的挑战中更复杂一点。",
        "One of the most powerful features when thinking of arrays as data structures, is that arrays can contain, or even be completely made up of other arrays. We have seen arrays that contain arrays in previous challenges, but fairly simple ones. However, arrays can contain an infinite depth of arrays that can contain other arrays, each with their own arbitrary levels of depth, and so on. In this way, an array can very quickly become very complex data structure, known as a <dfn>multi-dimensional</dfn>, or nested array. Consider the following example:",
        "<blockquote>let nestedArray = [ // top, or first level - the outer most array<br>&nbsp;&nbsp;['deep'], // an array within an array, 2 levels of depth<br>&nbsp;&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;['deeper'], ['deeper'] // 2 arrays nested 3 levels deep<br>&nbsp;&nbsp;],<br>&nbsp;&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;['deepest'], ['deepest'] // 2 arrays nested 4 levels deep<br>&nbsp;&nbsp;&nbsp;&nbsp;],<br>&nbsp;&nbsp;&nbsp;&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;['deepest-est?'] // an array nested 5 levels deep<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;]<br>];</blockquote>",
        "While this example may seem convoluted, this level of complexity is not unheard of, or even unusual, when dealing with large amounts of data.",
        "However, we can still very easily access the deepest levels of an array this complex with bracket notation:",
        "<blockquote>console.log(nestedArray[2][1][0][0][0]);<br>// logs: deepest-est?</blockquote>",
        "And now that we know where that piece of data is, we can reset it if we need to:",
        "<blockquote>nestedArray[2][1][0][0][0] = 'deeper still';<br><br>console.log(nestedArray[2][1][0][0][0]);<br>// now logs: deeper still</blockquote>",
        "<hr>",
        "We have defined a variable, <code>myNestedArray</code>, set equal to an array. Modify <code>myNestedArray</code>, using any combination of <dfn>strings</dfn>, <dfn>numbers</dfn>, and <dfn>booleans</dfn> for data elements, so that it has exactly five levels of depth (remember, the outer-most array is level 1). Somewhere on the third level, include the string <code>'deep'</code>, on the fourth level, include the string <code>'deeper'</code>, and on the fifth level, include the string <code>'deepest'</code>."
      ],
      "tests": [
        {
          "text": "<code>myNestedArray</code> should contain only numbers, booleans, and strings as data elements",
          "testString": "assert.strictEqual((function(arr) { let flattened = (function flatten(arr) { const flat = [].concat(...arr); return flat.some (Array.isArray) ? flatten(flat) : flat; })(arr); for (let i = 0; i < flattened.length; i++) { if ( typeof flattened[i] !== 'number' && typeof flattened[i] !== 'string' && typeof flattened[i] !== 'boolean') { return false } } return true })(myNestedArray), true, '<code>myNestedArray</code> should contain only numbers, booleans, and strings as data elements');"
        },
        {
          "text": "<code>myNestedArray</code> should have exactly 5 levels of depth",
          "testString": "assert.strictEqual((function(arr) {let depth = 0;function arrayDepth(array, i, d) { if (Array.isArray(array[i])) {  arrayDepth(array[i], 0, d + 1);} else {  depth = (d > depth) ? d : depth;}if (i < array.length) {  arrayDepth(array, i + 1, d);}  }arrayDepth(arr, 0, 0);return depth;})(myNestedArray), 4, '<code>myNestedArray</code> should have exactly 5 levels of depth');"
        },
        {
          "text": "<code>myNestedArray</code> should contain exactly one occurrence of the string <code>\"deep\"</code> on an array nested 3 levels deep",
          "testString": "assert((function howDeep(array, target, depth = 0) {return array.reduce((combined, current) => {if (Array.isArray(current)) {  return combined.concat(howDeep(current, target, depth + 1));} else if (current === target) {  return combined.concat(depth);} else {  return combined;}}, []);})(myNestedArray, 'deep').length === 1 && (function howDeep(array, target, depth = 0) {return array.reduce((combined, current) => {if (Array.isArray(current)) {  return combined.concat(howDeep(current, target, depth + 1));} else if (current === target) {  return combined.concat(depth);} else {  return combined;}}, []);})(myNestedArray, 'deep')[0] === 2, '<code>myNestedArray</code> should contain exactly one occurrence of the string <code>\"deep\"</code> on an array nested 3 levels deep');"
        },
        {
          "text": "<code>myNestedArray</code> should contain exactly one occurrence of the string <code>\"deeper\"</code> on an array nested 4 levels deep",
          "testString": "assert((function howDeep(array, target, depth = 0) {return array.reduce((combined, current) => {if (Array.isArray(current)) {  return combined.concat(howDeep(current, target, depth + 1));} else if (current === target) {  return combined.concat(depth);} else {  return combined;}}, []);})(myNestedArray, 'deeper').length === 1 && (function howDeep(array, target, depth = 0) {return array.reduce((combined, current) => {if (Array.isArray(current)) {  return combined.concat(howDeep(current, target, depth + 1));} else if (current === target) {  return combined.concat(depth);} else {  return combined;}}, []);})(myNestedArray, 'deeper')[0] === 3, '<code>myNestedArray</code> should contain exactly one occurrence of the string <code>\"deeper\"</code> on an array nested 4 levels deep');"
        },
        {
          "text": "<code>myNestedArray</code> should contain exactly one occurrence of the string <code>\"deepest\"</code> on an array nested 5 levels deep",
          "testString": "assert((function howDeep(array, target, depth = 0) {return array.reduce((combined, current) => {if (Array.isArray(current)) {  return combined.concat(howDeep(current, target, depth + 1));} else if (current === target) {  return combined.concat(depth);} else {  return combined;}}, []);})(myNestedArray, 'deepest').length === 1 && (function howDeep(array, target, depth = 0) {return array.reduce((combined, current) => {if (Array.isArray(current)) {  return combined.concat(howDeep(current, target, depth + 1));} else if (current === target) {  return combined.concat(depth);} else {  return combined;}}, []);})(myNestedArray, 'deepest')[0] === 4, '<code>myNestedArray</code> should contain exactly one occurrence of the string <code>\"deepest\"</code> on an array nested 5 levels deep');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let myNestedArray = [",
            "  // change code below this line",
            "  ['unshift', false, 1, 2, 3, 'complex', 'nested'],",
            "  ['loop', 'shift', 6, 7, 1000, 'method'],",
            "  ['concat', false, true, 'spread', 'array'],",
            "  ['mutate', 1327.98, 'splice', 'slice', 'push'],",
            "  ['iterate', 1.3849, 7, '8.4876', 'arbitrary', 'depth']",
            "  // change code above this line",
            "];"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7c367417b2b2512b18",
      "title": "Add Key-Value Pairs to JavaScript Objects",
      "description": [
        "At their most basic, objects are just collections of <dfn>key-value pairs</dfn>, or in other words, pieces of data mapped to unique identifiers that we call <dfn>properties</dfn> or <dfn>keys</dfn>. Let's take a look at a very simple example:",
        "<blockquote>let FCC_User = {<br>&nbsp;&nbsp;username: 'awesome_coder',<br>&nbsp;&nbsp;followers: 572,<br>&nbsp;&nbsp;points: 1741,<br>&nbsp;&nbsp;completedProjects: 15<br>};</blockquote>",
        "The above code defines an object called <code>FCC_User</code> that has four <dfn>properties</dfn>, each of which map to a specific value. If we wanted to know the number of <code>followers</code> <code>FCC_User</code> has, we can access that property by writing:",
        "<blockquote>let userData = FCC_User.followers;<br>// userData equals 572</blockquote>",
        "This is called <dfn>dot notation</dfn>. Alternatively, we can also access the property with brackets, like so:",
        "<blockquote>let userData = FCC_User['followers']<br>// userData equals 572</blockquote>",
        "Notice that with <dfn>bracket notation</dfn>, we enclosed <code>followers</code> in quotes. This is because the brackets actually allow us to pass a variable in to be evaluated as a property name (hint: keep this in mind for later!). Had we passed <code>followers</code> in without the quotes, the JavaScript engine would have attempted to evaluate it as a variable, and a <code>ReferenceError: followers is not defined</code> would have been thrown.",
        "<hr>",
        "Using the same syntax, we can also <em><strong>add new</strong></em> key-value pairs to objects. We've created a <code>foods</code> object with three entries. Add three more entries: <code>bananas</code> with a value of <code>13</code>, <code>grapes</code> with a value of <code>35</code>, and <code>strawberries</code> with a value of <code>27</code>."
      ],
      "tests": [
        {
          "text": "<code>foods</code> is an object",
          "testString": "assert(typeof foods === 'object', '<code>foods</code> is an object');"
        },
        {
          "text": "The <code>foods</code> object has a key <code>\"bananas\"</code> with a value of <code>13</code>",
          "testString": "assert(foods.bananas === 13, 'The <code>foods</code> object has a key <code>\"bananas\"</code> with a value of <code>13</code>');"
        },
        {
          "text": "The <code>foods</code> object has a key <code>\"grapes\"</code> with a value of <code>35</code>",
          "testString": "assert(foods.grapes === 35, 'The <code>foods</code> object has a key <code>\"grapes\"</code> with a value of <code>35</code>');"
        },
        {
          "text": "The <code>foods</code> object has a key <code>\"strawberries\"</code> with a value of <code>27</code>",
          "testString": "assert(foods.strawberries === 27, 'The <code>foods</code> object has a key <code>\"strawberries\"</code> with a value of <code>27</code>');"
        },
        {
          "text": "The key-value pairs should be set using dot or bracket notation",
          "testString": "assert(code.search(/bananas:/) === -1 && code.search(/grapes:/) === -1 && code.search(/strawberries:/) === -1, 'The key-value pairs should be set using dot or bracket notation');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let foods = {",
            "  apples: 25,",
            "  oranges: 32,",
            "  plums: 28",
            "};",
            "",
            "// change code below this line",
            "",
            "// change code above this line",
            "",
            "console.log(foods);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7c367417b2b2512b19",
      "title": "Modify an Object Nested Within an Object",
      "description": [
        "Now let's take a look at a slightly more complex object. Object properties can be nested to an arbitrary depth, and their values can be any type of data supported by JavaScript, including arrays and even other objects. Consider the following:",
        "<blockquote>let nestedObject = {<br>&nbsp;&nbsp;id: 28802695164,<br>&nbsp;&nbsp;date: 'December 31, 2016',<br>&nbsp;&nbsp;data: {<br>&nbsp;&nbsp;&nbsp;&nbsp;totalUsers: 99,<br>&nbsp;&nbsp;&nbsp;&nbsp;online: 80,<br>&nbsp;&nbsp;&nbsp;&nbsp;onlineStatus: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active: 67,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;away: 13<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "<code>nestedObject</code> has three unique keys: <code>id</code>, whose value is a number, <code>date</code> whose value is a string, and <code>data</code>, whose value is an object which has yet another object nested within it. While structures can quickly become complex, we can still use the same notations to access the information we need.",
        "<hr>",
        "Here we've defined an object, <code>userActivity</code>, which includes another object nested within it. You can modify properties on this nested object in the same way you modified properties in the last challenge. Set the value of the <code>online</code> key to <code>45</code>."
      ],
      "tests": [
        {
          "text": "<code>userActivity</code> has <code>id</code>, <code>date</code> and <code>data</code> properties",
          "testString": "assert('id' in userActivity && 'date' in userActivity && 'data' in userActivity, '<code>userActivity</code> has <code>id</code>, <code>date</code> and <code>data</code> properties');"
        },
        {
          "text": "<code>userActivity</code> has a <code>data</code> key set to an object with keys <code>totalUsers</code> and <code>online</code>",
          "testString": "assert('totalUsers' in userActivity.data && 'online' in userActivity.data, '<code>userActivity</code> has a <code>data</code> key set to an object with keys <code>totalUsers</code> and <code>online</code>');"
        },
        {
          "text": "The <code>online</code> property nested in the <code>data</code> key of <code>userActivity</code> should be set to <code>45</code>",
          "testString": "assert(userActivity.data.online === 45, 'The <code>online</code> property nested in the <code>data</code> key of <code>userActivity</code> should be set to <code>45</code>');"
        },
        {
          "text": "The <code>online</code> property is set using dot or bracket notation",
          "testString": "assert.strictEqual(code.search(/online: 45/), -1, 'The <code>online</code> property is set using dot or bracket notation');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let userActivity = {",
            "  id: 23894201352,",
            "  date: 'January 1, 2017',",
            "  data: {",
            "    totalUsers: 51,",
            "    online: 42",
            "  }",
            "};",
            "",
            "// change code below this line",
            "",
            "// change code above this line",
            "",
            "console.log(userActivity);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7c367417b2b2512b1a",
      "title": "Access Property Names with Bracket Notation",
      "description": [
        "In the first object challenge we mentioned the use of bracket notation as a way to access property values using the evaluation of a variable. For instance, imagine that our <code>foods</code> object is being used in a program for a supermarket cash register. We have some function that sets the <code>selectedFood</code> and we want to check our <code>foods</code> object for the presence of that food. This might look like:",
        "<blockquote>let selectedFood = getCurrentFood(scannedItem);<br>let inventory = foods[selectedFood];</blockquote>",
        "This code will evaluate the value stored in the <code>selectedFood</code> variable and return the value of that key in the <code>foods</code> object, or <code>undefined</code> if it is not present. Bracket notation is very useful because sometimes object properties are not known before runtime or we need to access them in a more dynamic way.",
        "<hr>",
        "We've defined a function, <code>checkInventory</code>, which receives a scanned item as an argument. Return the current value of the <code>scannedItem</code> key in the <code>foods</code> object. You can assume that only valid keys will be provided as an argument to <code>checkInventory</code>."
      ],
      "tests": [
        {
          "text": "<code>checkInventory</code> is a function",
          "testString": "assert.strictEqual(typeof checkInventory, 'function', '<code>checkInventory</code> is a function');"
        },
        {
          "text": "The <code>foods</code> object should have only the following key-value pairs: <code>apples: 25</code>, <code>oranges: 32</code>, <code>plums: 28</code>, <code>bananas: 13</code>, <code>grapes: 35</code>, <code>strawberries: 27</code>",
          "testString": "assert.deepEqual(foods, {apples: 25, oranges: 32, plums: 28, bananas: 13, grapes: 35, strawberries: 27}, 'The <code>foods</code> object should have only the following key-value pairs: <code>apples: 25</code>, <code>oranges: 32</code>, <code>plums: 28</code>, <code>bananas: 13</code>, <code>grapes: 35</code>, <code>strawberries: 27</code>');"
        },
        {
          "text": "<code>checkInventory(\"apples\")</code> 应该返回 <code>25</code>",
          "testString": "assert.strictEqual(checkInventory('apples'), 25, '<code>checkInventory(\"apples\")</code> 应该返回 <code>25</code>');"
        },
        {
          "text": "<code>checkInventory(\"bananas\")</code> 应该返回 <code>13</code>",
          "testString": "assert.strictEqual(checkInventory('bananas'), 13, '<code>checkInventory(\"bananas\")</code> 应该返回 <code>13</code>');"
        },
        {
          "text": "<code>checkInventory(\"strawberries\")</code> 应该返回 <code>27</code>",
          "testString": "assert.strictEqual(checkInventory('strawberries'), 27, '<code>checkInventory(\"strawberries\")</code> 应该返回 <code>27</code>');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let foods = {",
            "  apples: 25,",
            "  oranges: 32,",
            "  plums: 28,",
            "  bananas: 13,",
            "  grapes: 35,",
            "  strawberries: 27",
            "};",
            "// do not change code above this line",
            "",
            "function checkInventory(scannedItem) {",
            "  // change code below this line",
            "",
            "}",
            "",
            "// change code below this line to test different cases:",
            "console.log(checkInventory(\"apples\"));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7c367417b2b2512b1b",
      "title": "Use the delete Keyword to Remove Object Properties",
      "description": [
        "Now you know what objects are and their basic features and advantages. In short, they are key-value stores which provide a flexible, intuitive way to structure data, <strong><em>and</em></strong>, they provide very fast lookup time. Throughout the rest of these challenges, we will describe several common operations you can perform on objects so you can become comfortable applying these useful data structures in your programs.",
        "In earlier challenges, we have both added to and modified an object's key-value pairs. Here we will see how we can <em>remove</em> a key-value pair from an object.",
        "Let's revisit our <code>foods</code> object example one last time. If we wanted to remove the <code>apples</code> key, we can remove it by using the <code>delete</code> keyword like this:",
        "<blockquote>delete foods.apples;</blockquote>",
        "<hr>",
        "Use the delete keyword to remove the <code>oranges</code>, <code>plums</code>, and <code>strawberries</code> keys from the <code>foods</code> object."
      ],
      "tests": [
        {
          "text": "The <code>foods</code> object only has three keys: <code>apples</code>, <code>grapes</code>, and <code>bananas</code>",
          "testString": "assert(!foods.hasOwnProperty('oranges') && !foods.hasOwnProperty('plums') && !foods.hasOwnProperty('strawberries') && Object.keys(foods).length === 3, 'The <code>foods</code> object only has three keys: <code>apples</code>, <code>grapes</code>, and <code>bananas</code>');"
        },
        {
          "text": "The <code>oranges</code>, <code>plums</code>, and <code>strawberries</code> keys are removed using <code>delete</code>",
          "testString": "assert(code.search(/oranges:/) !== -1 && code.search(/plums:/) !== -1 && code.search(/strawberries:/) !== -1, 'The <code>oranges</code>, <code>plums</code>, and <code>strawberries</code> keys are removed using <code>delete</code>');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let foods = {",
            "  apples: 25,",
            "  oranges: 32,",
            "  plums: 28,",
            "  bananas: 13,",
            "  grapes: 35,",
            "  strawberries: 27",
            "};",
            "",
            "// change code below this line",
            "",
            "// change code above this line",
            "",
            "console.log(foods);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7d367417b2b2512b1c",
      "title": "Check if an Object has a Property",
      "description": [
        "Now we can add, modify, and remove keys from objects. But what if we just wanted to know if an object has a specific property? JavaScript provides us with two different ways to do this. One uses the <code>hasOwnProperty()</code> method and the other uses the <code>in</code> keyword. If we have an object <code>users</code> with a property of <code>Alan</code>, we could check for its presence in either of the following ways:",
        "<blockquote>users.hasOwnProperty('Alan');<br>'Alan' in users;<br>// both return true</blockquote>",
        "<hr>",
        "We've created an object, <code>users</code>, with some users in it and a function <code>isEveryoneHere</code>, which we pass the <code>users</code> object to as an argument. Finish writing this function so that it returns <code>true</code> only if the <code>users</code> object contains all four names, <code>Alan</code>, <code>Jeff</code>, <code>Sarah</code>, and <code>Ryan</code>, as keys, and <code>false</code> otherwise."
      ],
      "tests": [
        {
          "text": "The <code>users</code> object only contains the keys <code>Alan</code>, <code>Jeff</code>, <code>Sarah</code>, and <code>Ryan</code>",
          "testString": "assert('Alan' in users && 'Jeff' in users && 'Sarah' in users && 'Ryan' in users && Object.keys(users).length === 4, 'The <code>users</code> object only contains the keys <code>Alan</code>, <code>Jeff</code>, <code>Sarah</code>, and <code>Ryan</code>');"
        },
        {
          "text": "The function <code>isEveryoneHere</code> returns <code>true</code> if <code>Alan</code>, <code>Jeff</code>, <code>Sarah</code>, and <code>Ryan</code> are properties on the <code>users</code> object",
          "testString": "assert(isEveryoneHere(users) === true, 'The function <code>isEveryoneHere</code> returns <code>true</code> if <code>Alan</code>, <code>Jeff</code>, <code>Sarah</code>, and <code>Ryan</code> are properties on the <code>users</code> object');"
        },
        {
          "text": "The function <code>isEveryoneHere</code> returns <code>false</code> if <code>Alan</code>, <code>Jeff</code>, <code>Sarah</code>, and <code>Ryan</code> are not properties on the <code>users</code> object",
          "testString": "assert((function() { delete users.Alan; delete users.Jeff; delete users.Sarah; delete users.Ryan; return isEveryoneHere(users) })() === false, 'The function <code>isEveryoneHere</code> returns <code>false</code> if <code>Alan</code>, <code>Jeff</code>, <code>Sarah</code>, and <code>Ryan</code> are not properties on the <code>users</code> object');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let users = {",
            "  Alan: {",
            "    age: 27,",
            "    online: true",
            "  },",
            "  Jeff: {",
            "    age: 32,",
            "    online: true",
            "  },",
            "  Sarah: {",
            "    age: 48,",
            "    online: true",
            "  },",
            "  Ryan: {",
            "    age: 19,",
            "    online: true",
            "  }",
            "};",
            "",
            "function isEveryoneHere(obj) {",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "}",
            "",
            "console.log(isEveryoneHere(users));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7d367417b2b2512b1d",
      "title": " Iterate Through the Keys of an Object with a for...in Statement",
      "description": [
        "有时候你会需要遍历一个对象中的所有键。这需要 JavaScript 中的一个特殊语法：<dfn>for...in</dfn> 语句。以遍历 <code>users</code> 对象的键为例：",
        "<blockquote>for (let user in users) {<br>&nbsp;&nbsp;console.log(user);<br>};<br><br>// logs:<br>Alan<br>Jeff<br>Sarah<br>Ryan</blockquote>",
        "在这个语句中，我们定义了一个 <code>user</code> 变量，您可以看到，这个变量在 for...in 语句对对象的每一个键的遍历中都会被重置。",
        "<strong>注意：</strong><br>跟数组不同，对象不会维持其中的键的顺序，因此一个对象中某个键的位置，或者说它出现的相对顺序，在引用或访问该键时是不确定的。",
        "<hr>",
        "我们已经定义了一个 <code>countOnline</code> 函数，请在其中使用一个 <dfn>for...in</dfn> 语句来遍历 <code>users</code> 对象中的用户，并返回 <code>online</code> 属性为 <code>true</code> 的用户的数量。"
      ],
      "tests": [
        {
          "text": "<code>users</code> 对象中应该包含 <code>online</code> 为 <code>true</code> 的用户对象 <code>Jeff</code> 和 <code>Ryan</code> 以及 <code>online</code> 为 <code>false</code> 的用户对象 <code>Alan</code> 和 <code>Sarah</code>",
          "testString": "assert(users.Alan.online === false && users.Jeff.online === true &&  users.Sarah.online === false &&  users.Ryan.online === true, '<code>users</code> 对象中应该包含 <code>online</code> 为 <code>true</code> 的用户对象 <code>Jeff</code> 和 <code>Ryan</code> 以及 <code>online</code> 为 <code>false</code> 的用户对象 <code>Alan</code> 和 <code>Sarah</code>');"
        },
        {
          "text": "<code>countOnline</code> 函数应该返回 <code>online</code> 属性为 <code>true</code> 的用户的数量",
          "testString": "assert((function() { users.Harry = {online: true}; users.Sam = {online: true}; users.Carl = {online: true}; return countOnline(users) })() === 5, '<code>countOnline</code> 函数应该返回 <code>online</code> 属性为 <code>true</code> 的用户的数量');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let users = {",
            "  Alan: {",
            "    age: 27,",
            "    online: false",
            "  },",
            "  Jeff: {",
            "    age: 32,",
            "    online: true",
            "  },",
            "  Sarah: {",
            "    age: 48,",
            "    online: false",
            "  },",
            "  Ryan: {",
            "    age: 19,",
            "    online: true",
            "  }",
            "};",
            "",
            "function countOnline(obj) {",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "}",
            "",
            "console.log(countOnline(users));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7d367417b2b2512b1e",
      "title": "Generate an Array of All Object Keys with Object.keys()",
      "description": [
        "我们还可以输入一个对象作为参数来调用 <code>Object.keys()</code> 方法，使其生成一个包含对象中所有键的数组。这会返回一个由对象中所有键的名称（字符串）组成的数组。再次说明，这个数组中的项的顺序是不确定的。",
        "<hr>",
        "请您完成 <code>getArrayOfUsers</code> 函数，使其返回一个包含输入的对象的所有属性的数组。"
      ],
      "tests": [
        {
          "text": "<code>users</code> 对象应该只包含 <code>Alan</code>、<code>Jeff</code>、<code>Sarah</code> 和 <code>Ryan</code> 这 4 个键",
          "testString": "assert('Alan' in users && 'Jeff' in users && 'Sarah' in users && 'Ryan' in users && Object.keys(users).length === 4, '<code>users</code> 对象应该只包含 <code>Alan</code>、<code>Jeff</code>、<code>Sarah</code> 和 <code>Ryan</code> 这 4 个键');"
        },
        {
          "text": "<code>getArrayOfUsers</code> 函数应该返回一个包含 <code>users</code> 对象中所有键的数组",
          "testString": "assert((function() { users.Sam = {}; users.Lewis = {}; let R = getArrayOfUsers(users); return (R.indexOf('Alan') !== -1 && R.indexOf('Jeff') !== -1 && R.indexOf('Sarah') !== -1 && R.indexOf('Ryan') !== -1 && R.indexOf('Sam') !== -1 && R.indexOf('Lewis') !== -1); })() === true, '<code>getArrayOfUsers</code> 函数应该返回一个包含 <code>users</code> 对象中所有键的数组');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let users = {",
            "  Alan: {",
            "    age: 27,",
            "    online: false",
            "  },",
            "  Jeff: {",
            "    age: 32,",
            "    online: true",
            "  },",
            "  Sarah: {",
            "    age: 48,",
            "    online: false",
            "  },",
            "  Ryan: {",
            "    age: 19,",
            "    online: true",
            "  }",
            "};",
            "",
            "function getArrayOfUsers(obj) {",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "}",
            "",
            "console.log(getArrayOfUsers(users));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b7d367417b2b2512b1f",
      "title": "Modify an Array Stored in an Object",
      "description": [
        "现在您已经接触到 JavaScript 对象的所有运算。您可以增加、修改和移除键值对，检查某个键是否存在，并且遍历一个对象中的所有键。在您继续学习 JavaScript 的过程中，您会看到更 versatile applications of objects. Additionally, the optional Advanced Data Structures lessons later in the curriculum also cover the ES6 <dfn>Map</dfn> and <dfn>Set</dfn> objects, both of which are similar to ordinary objects but provide some additional features. Now that you've learned the basics of arrays and objects, you're fully prepared to begin tackling more complex problems using JavaScript!",
        "<hr>",
        "Take a look at the object we've provided in the code editor. The <code>user</code> object contains three keys. The <code>data</code> key contains five keys, one of which contains an array of <code>friends</code>. From this, you can see how flexible objects are as data structures. We've started writing a function <code>addFriend</code>. Finish writing it so that it takes a <code>user</code> object and adds the name of the <code>friend</code> argument to the array stored in <code>user.data.friends</code> and returns that array."
      ],
      "tests": [
        {
          "text": "<code>user</code> 对象应该包含 <code>name</code>、<code>age</code> 和 <code>data</code> 三个键",
          "testString": "assert('name' in user && 'age' in user && 'data' in user, '<code>user</code> 对象应该包含 <code>name</code>、<code>age</code> 和 <code>data</code> 三个键');"
        },
        {
          "text": "<code>addFriend</code> 函数应该接受一个 <code>user</code> 对象和一个 <code>friend</code> 字符串作为输入参数，并将 friend 插入到 <code>user</code> 对象的 <code>friends</code> 数组中",
          "testString": "assert((function() { let L1 = user.data.friends.length; addFriend(user, 'Sean'); let L2 = user.data.friends.length; return (L2 === L1 + 1); })(), '<code>addFriend</code> 函数应该接受一个 <code>user</code> 对象和一个 <code>friend</code> 字符串作为输入参数，并将 friend 插入到 <code>user</code> 对象的 <code>friends</code> 数组中');"
        },
        {
          "text": "<code>addFriend(user, \"Pete\")</code> 应该返回 <code>[\"Sam\", \"Kira\", \"Tomo\", \"Pete\"]</code>",
          "testString": "assert.deepEqual((function() { delete user.data.friends; user.data.friends = ['Sam', 'Kira', 'Tomo']; return addFriend(user, 'Pete') })(), ['Sam', 'Kira', 'Tomo', 'Pete'], '<code>addFriend(user, \"Pete\")</code> 应该返回 <code>[\"Sam\", \"Kira\", \"Tomo\", \"Pete\"]</code>');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let user = {",
            "  name: 'Kenneth',",
            "  age: 28,",
            "  data: {",
            "    username: 'kennethCodesAllDay',",
            "    joinDate: 'March 26, 2016',",
            "    organization: 'freeCodeCamp',",
            "    friends: [",
            "      'Sam',",
            "      'Kira',",
            "      'Tomo'",
            "    ],",
            "    location: {",
            "      city: 'San Francisco',",
            "      state: 'CA',",
            "      country: 'USA'",
            "    }",
            "  }",
            "};",
            "",
            "function addFriend(userObj, friend) {",
            "  // change code below this line  ",
            "",
            "  // change code above this line",
            "}",
            "",
            "console.log(addFriend(user, 'Pete'));"
          ],
          "head": [],
          "tail": []
        }
      }
    }
  ]
}
