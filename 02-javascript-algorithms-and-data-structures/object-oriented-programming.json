{
  "name": "Object Oriented Programming",
  "order": 7,
  "time": "5 hours",
  "helpRoom": "Help",
  "challenges": [
    {
      "id": "587d7dac367417b2b2512b73",
      "title": "Create a Basic JavaScript Object",
      "description": [
        "想想我们在生活中每天都可见到的事物：比如汽车、商店以及小鸟等。它们都是<code>物体</code>：即人们可以观察和与之互动的实体事物。",
        "那么这些<code>物体</code>都有哪些特征呢？比如汽车的特征是有轮子，商店是用来出售商品的，而小鸟的特征是有翅膀。",
        "这些特征，或者说是<code>属性</code>定义了一个<code>物体</code>由什么构成的。需要注意的是：那些相似的<code>物体</code>可以拥有相同的<code>属性</code>，但是这些<code>属性</code>可能会有不同的值。举个例子：所有的汽车都有轮子，但并不是所有汽车的轮子个数都是一样的。",
        "JavaScript 中的<code>对象</code>可以用来描述现实世界中的物体，并赋予他们<code>属性</code>和行为，就像它们在现实世界中的对应物一样。下面是使用这些概念来创建一个<code>duck 对象</code>的示例：",
        "<blockquote>let duck = {<br>&nbsp;&nbsp;name: \"Aflac\",<br>&nbsp;&nbsp;numLegs: 2<br>};</blockquote>",
        "这个<code>duck 对象</code> 有两组键值对：一个是<code>name</code>属性，它的值是 \"Aflac\"；另一个是<code>numLegs</code>属性，它的值是 2。",
        "<hr>",
        "创建一个<code>dog 对象</code>，并给这个对象添加两个属性：<code>name</code>和<code>numLegs</code>，同时把这两个属性的值分别设为字符串和数字。"
      ],
      "tests": [
        {
          "text": "<code>dog</code>应该是一个<code>object</code>。",
          "testString": "assert(typeof(dog) === 'object', '<code>dog</code>应该是一个<code>object</code>');"
        },
        {
          "text": "<code>dog</code>应该有一个<code>name</code>属性，且它的值是一个<code>字符串<code>。",
          "testString": "assert(typeof(dog.name) === 'string', '<code>dog</code> 应该有一个<code>name</code>属性，且它的值是一个<code>字符串<code>。');"
        },
        {
          "text": "<code>dog</code>应该有一个<code>numLegs</code>属性，且它的值是一个<code>数字</code>。",
          "testString": "assert(typeof(dog.numLegs) === 'number', '<code>dog</code>应该有一个<code>numLegs</code>属性，且它的值是一个<code>数字</code>。');"
        }
      ],
      "solutions": [
        "let dog = {\n  name: '',\n  numLegs: 4\n};"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let dog = {",
            "  ",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dac367417b2b2512b74",
      "title": "Use Dot Notation to Access the Properties of an Object",
      "description": [
        "在上一个挑战中，我们创建了一个拥有不同<code>属性</code>的<code>对象</code>，现在我们来看看该如何访问这些<code>属性</code>：",
        "<blockquote>let duck = {<br>&nbsp;&nbsp;name: \"Aflac\",<br>&nbsp;&nbsp;numLegs: 2<br>};<br>console.log(duck.name);<br>// 这段代码会在控制台中输出 \"Aflac\" </blockquote>",
        "我们可以用“点号表示法”来访问对象的属性，只需要在<code>对象</code>名称后面加上<code>.</code>以及<code>属性</code>名即可。比如，<code>duck.name</code>就可以访问到 \"Aflac\"。",
        "<hr>",
        "请在控制台里面输出<code>dog</code>对象中两个<code>属性</code>对应的值。"
      ],
      "tests": [
        {
          "text": "你应该使用<code>console.log</code>来将<code>dog</code>对象的<code>name</code>属性值输出到控制台。",
          "testString": "assert(/console.log\\(.*dog\\.name.*\\)/g.test(code), '你应该使用<code>console.log</code>来将<code>dog</code>对象的<code>name</code>属性值输出到控制台。');"
        },
        {
          "text": "你应该使用<code>console.log</code>来将<code>dog</code>对象的<code>numLegs</code>属性值输出到控制台。",
          "testString": "assert(/console.log\\(.*dog\\.numLegs.*\\)/g.test(code), '你应该使用<code>console.log</code>来将<code>dog</code>对象的<code>numLegs</code>属性值输出到控制台。');"
        }
      ],
      "solutions": [
        "let dog = {\n  name: \"Spot\",\n  numLegs: 4\n};\nconsole.log(dog.name);\nconsole.log(dog.numLegs);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let dog = {",
            "  name: \"Spot\",",
            "  numLegs: 4",
            "};",
            "// 请把你的代码写在这条注释以下 ",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dad367417b2b2512b75",
      "title": "Create a Method on an Object",
      "description": [
        "<code>对象</code>可以有一个叫做<code>方法</code>的特殊<code>属性</code>。",
        "<code>方法</code>其实是一个值为函数的<code>属性</code>，它可以为一个<code>对象</code>添加不同的行为。以下就是一个带有方法属性的<code>duck</code>示例：",
        "<blockquote>let duck = {<br>&nbsp;&nbsp;name: \"Aflac\",<br>&nbsp;&nbsp;numLegs: 2,<br>&nbsp;&nbsp;sayName: function() {return \"The name of this duck is \" + duck.name + \".\";}<br>};<br>duck.sayName();<br>// 返回了: \"The name of this duck is Aflac.\"</blockquote>",
        "这个例子给<code>duck</code>对象添加了一个<code>sayName 方法</code>，这个方法返回一个包含<code>duck</code>名字的句子。",
        "注意：这个<code>方法</code>在返回语句中使用<code>duck.name</code>的方式来获取<code>name</code>的属性值。在下一个挑战中我们将会使用另外一种方法来实现。",
        "<hr>",
        "给<code>dog 对象</code>设置一个名为<code>sayLegs</code>的方法，并让它返回 \"This dog has 4 legs.\" 这句话。"
      ],
      "tests": [
        {
          "text": "<code>dog.sayLegs()</code>应该是一个函数。",
          "testString": "assert(typeof(dog.sayLegs) === 'function', '<code>dog.sayLegs()</code>应该是一个函数。');"
        },
        {
          "text": "<code>dog.sayLegs()</code>应该返回给定的字符串，需要注意标点和间距的问题。",
          "testString": "assert(dog.sayLegs() === 'This dog has 4 legs.', '<code>dog.sayLegs()</code>应该返回给定的字符串，需要注意标点和间距的问题。');"
        }
      ],
      "solutions": [
        "let dog = {\n  name: \"Spot\",\n  numLegs: 4,\n  sayLegs () {\n    return 'This dog has ' + this.numLegs + ' legs.';\n  }\n};\n\ndog.sayLegs();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let dog = {",
            "  name: \"Spot\",",
            "  numLegs: 4,",
            "  ",
            "};",
            "",
            "dog.sayLegs();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dad367417b2b2512b76",
      "title": "Make Code More Reusable with the this Keyword",
      "description": [
        "在上一个挑战中我们了解了该如何给<code>duck</code>对象设置一个<code>方法</code>属性。然后我们通过使用“点号表示法”<code>duck.name</code>来获取<code>name</code>的属性值而不需要使用<code>return<code>语句：",
        "<code>sayName: function() {return \"The name of this duck is \" + duck.name + \".\";}</code>",
        "虽然这是访问对象属性的有效方法，但是这里有一个陷阱。如果变量名发生了改变，那么引用了原始名称的任何代码都需要更新。在一个简短的对象定义中这并不是问题，但是如果对象有很多对其属性的引用，那么发生错误的可能性就更大了。",
        "我们可以使用<code>this</code>关键字这个方法来避免这一问题：",
        "<blockquote>let duck = {<br>&nbsp;&nbsp;name: \"Aflac\",<br>&nbsp;&nbsp;numLegs: 2,<br>&nbsp;&nbsp;sayName: function() {return \"The name of this duck is \" + this.name + \".\";}<br>};</blockquote>",
        "<code>this</code>是一个很复杂的知识点，而上面那个例子也只是使用<code>this</code>的一种方法而已。在当前的上下文环境中，<code>this</code>指向的就是与这个方法有关联的<code>duck</code>对象。",
        "如果把对象的变量名改为<code>mallard</code>，那使用<code>this</code>就没有必要在代码中找到所有指向<code>duck</code>的部分，这样可以使得代码更具有可读性和复用性。",
        "<hr>",
        "修改<code>dog.sayLegs</code>方法以将所有直接对<code>dog</code>的引用删除。可以参考上面的例子。"
      ],
      "tests": [
        {
          "text": "<code>dog.sayLegs()</code>应该返回一个指定的字符串。",
          "testString": "assert(dog.sayLegs() === 'This dog has 4 legs.', '<code>dog.sayLegs()</code>应该返回一个指定的字符串。');"
        },
        {
          "text": "你的代码应该使用<code>this</code>关键字来访问<code>dog</code>对象的<code>numLegs</code>属性值。",
          "testString": "assert(code.match(/this\\.numLegs/g), '你的代码应该使用<code>this</code>关键字来访问<code>dog</code>对象的<code>numLegs</code>属性值。');"
        }
      ],
      "solutions": [
        "let dog = {\n  name: \"Spot\",\n  numLegs: 4,\n  sayLegs () {\n    return 'This dog has ' + this.numLegs + ' legs.';\n  }\n};\n\ndog.sayLegs();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let dog = {",
            "  name: \"Spot\",",
            "  numLegs: 4,",
            "  sayLegs: function() {return \"This dog has \" + dog.numLegs + \" legs.\";}",
            "};",
            "",
            "dog.sayLegs();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dad367417b2b2512b77",
      "title": "Define a Constructor Function",
      "description": [
        "<code>构造函数</code>用以创建一个新对象，并给这个新对象定义属性和行为。因此这是创建新对象的一个最基本的方式。",
        "以下就是一个<code>构造函数</code>的示例：",
        "<blockquote>function Bird() {<br>&nbsp;&nbsp;this.name = \"Albert\";<br>&nbsp;&nbsp;this.color = \"blue\";<br>&nbsp;&nbsp;this.numLegs = 2;<br>}</blockquote>",
        "这个<code>构造函数</code>定义了一个<code>Bird</code>对象，其属性<code>name</code>、<code>color</code>和<code>numLegs</code>的值分别被设置为<code>Albert<code>、<code>blue<code>和 2。",
        "<code>构造函数</code>遵循一些惯例规则：",
        "<ul><li><code>构造函数</code>函数名的首字母最好大写，这是为了方便我们区分<code>构造函数</code>和其他非构造函数。</li><li><code>构造函数</code>使用<code>this</code>关键字来给它将创建的这个对象设置新的属性。在<code>构造函数</code>里面，<code>this</code>指向的就是它新创建的这个对象。</li><li><code>构造函数</code>定义了属性和行为就可创建对象，而不是像其他函数一样需要设置返回值。</li></ul>",
        "<hr>",
        "创建一个<code>构造函数</code>：<code>Dog</code>。给其添加<code>name</code>，<code>color</code>和<code>numLegs</code>属性并分别给它们设置为：字符串，字符串和数字。"
      ],
      "tests": [
        {
          "text": "<code>Dog</code>应该有一个<code>name</code>属性且它的值是一个字符串。",
          "testString": "assert(typeof (new Dog()).name === 'string', '<code>Dog</code>应该有一个<code>name</code>属性且它的值是一个字符串。');"
        },
        {
          "text": "<code>Dog</code>应该有一个<code>color</code>属性且它的值是一个字符串。",
          "testString": "assert(typeof (new Dog()).color === 'string', '<code>Dog</code>应该有一个<code>color</code>属性且它的值是一个字符串。');"
        },
        {
          "text": "<code>Dog</code>应该有一个<code>numLegs</code>属性且它的值是一个数字。",
          "testString": "assert(typeof (new Dog()).numLegs === 'number', '<code>Dog</code>应该有一个<code>numLegs</code>属性且它的值是一个数字。');"
        }
      ],
      "solutions": [
        "function Dog (name, color, numLegs) {\n  this.name = 'name';\n  this.color = 'color';\n  this.numLegs = 4;\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dad367417b2b2512b78",
      "title": "Use a Constructor to Create Objects",
      "description": [
        "在上一个挑战中，我们用所学到的知识创建了一个<code>Bird</code>构造函数：",
        "<blockquote>function Bird() {<br>&nbsp;&nbsp;this.name = \"Albert\";<br>&nbsp;&nbsp;this.color  = \"blue\";<br>&nbsp;&nbsp;this.numLegs = 2;<br>&nbsp;&nbsp;// 构造函数里面的 \"this\" 总是指向新创建的实例。<br>}<br><br>let blueBird = new Bird();</blockquote>",
        "注意：通过构造函数创建对象的时候要使用<code>new</code>操作符。因为只有这样，JavaScript 才知道要给<code>Bird</code>这个构造函数创建一个新的<code>实例</code>：<code>blueBird</code>。如果不使用<code>new</code>操作符来新建对象，那么构造函数里面的<code>this</code>就无法指向新创建的这个对象实例，从而产生不可预见的错误。",
        "现在<code>blueBird</code>这个实例就继承了<code>Bird</code>这个构造函数的所有属性，如下：",
        "<blockquote>blueBird.name; // => Albert<br>blueBird.color; // => blue<br>blueBird.numLegs; // => 2</blockquote>",
        "由构造函数创建的实例也和其他对象一样，它的属性可以被访问和修改：",
        "<blockquote>blueBird.name = 'Elvira';<br>blueBird.name; // => Elvira</blockquote>",
        "<hr>",
        "使用上一个课时中的<code>Dog</code>构造函数创建一个<code>Dog</code>的新实例，并把它赋值给变量<code>hound</code>。"
      ],
      "tests": [
        {
          "text": "<code>hound</code>应该是通过<code>Dog</code>构造函数来创建的。",
          "testString": "assert(hound instanceof Dog, '<code>hound</code>应该是通过<code>Dog</code>构造函数来创建的。');"
        },
        {
          "text": "你的代码中应该使用<code>new</code>操作符来创建<code>Dog</code>构造函数的新<code>实例</code>。",
          "testString": "assert(code.match(/new/g), '你的代码中应该使用<code>new</code>操作符来创建<code>Dog</code>构造函数的新<code>实例</code>。');"
        }
      ],
      "solutions": [
        "function Dog() {\n  this.name = \"Rupert\";\n  this.color = \"brown\";\n  this.numLegs = 4;\n}\nconst hound = new Dog();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog() {",
            "  this.name = \"Rupert\";",
            "  this.color = \"brown\";",
            "  this.numLegs = 4;",
            "}",
            "// 请把你的代码写在这条注释以下",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dae367417b2b2512b79",
      "title": "Extend Constructors to Receive Arguments",
      "description": [
        "上一个挑战中<code>Bird</code>和<code>Dog</code>构造函数运行得不错。但是，注意到没有：所有通过<code>Bird</code>构造函数创建出来的实例<code>Birds</code>都自动的取名为 Albert，颜色都是蓝色，还都有两条腿。如果你想要新创建出来的小鸟们拥有不同的名字和颜色要怎么办呢？当然，手动的去修改每一个小鸟实例自己的属性也是可以实现的，只是会增加很多无谓的工作量：",
        "<blockquote>let swan = new Bird();<br>swan.name = \"Carlos\";<br>swan.color = \"white\";</blockquote>",
        "假如你写了一个程序来追踪一个鸟舍里面的几百只甚至几千只不同的小鸟，你将会花费很多时间去创建所有的小鸟实例并给它们的属性一一修改为不同的值。",
        "为了减轻创建不同<code>Bird</code>对象的工作量，你可以给你的<code>Bird</code>设置为可以接收参数的构造函数：",
        "<blockquote>function Bird(name, color) {<br>&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;this.color = color;<br>&nbsp;&nbsp;this.numLegs = 2;<br>}</blockquote>",
        "然后将值通过参数的方式传递给<code>Bird</code>构造函数来定义每一个唯一的小鸟实例：",
        "<code>let cardinal = new Bird(\"Bruce\", \"red\");</code>",
        "这给<code>Bird</code>的名字和颜色属性分别赋值为 Bruce 和红色提供了另外一种方法。但<code>numLegs</code>属性被默认赋值为 2。",
        "<code>cardinal</code>有以下这些属性：",
        "<blockquote>cardinal.name // => Bruce<br>cardinal.color // => red<br>cardinal.numLegs // => 2</blockquote>",
        "这样一来构造函数就变得很灵活了。现在可以直接定义每个<code>Bird</code>实例在创建时的属性，这是 JavaScript 构造函数非常实用的用法之一。它们根据共同或相似的属性和行为将对象归纳为一组，并能够自动的创建各自实例。",
        "<hr>",
        "创建另一个<code>Dog</code>构造函数。这一次，给它设置两个参数：<code>name</code>和<code>color</code>，同时给<code>numLegs</code>赋值为 4。然后创建一个新<code>Dog</code>实例保存为变量名：<code>terrier</code>，再将两个字符串通过参数的形式传入<code>name</code>和<code>color</code>属性。"
      ],
      "tests": [
        {
          "text": "<code>Dog</code>应该接收一个<code>name</code>参数。",
          "testString": "assert((new Dog('Clifford')).name === 'Clifford', '<code>Dog</code>应该接收一个<code>name</code>参数。');"
        },
        {
          "text": "<code>Dog</code>应该接收一个<code>color</code>参数。",
          "testString": "assert((new Dog('Clifford', 'yellow')).color === 'yellow', '<code>Dog</code>应该接收一个<code>color</code>参数。');"
        },
        {
          "text": "<code>Dog</code>应该有一个<code>numLegs</code>属性且值为 4。",
          "testString": "assert((new Dog('Clifford')).numLegs === 4, '<code>Dog</code>应该有一个<code>numLegs</code>属性且值为 4。');"
        },
        {
          "text": "<code>terrier</code>应该是通过<code>Dog</code>构造函数创建的。",
          "testString": "assert(terrier instanceof Dog, '<code>terrier</code>应该是通过<code>Dog</code>构造函数创建的。');"
        }
      ],
      "solutions": [
        "function Dog (name, color) {\n  this.numLegs = 4;\n  this.name = name;\n  this.color = color;\n}\n\nconst terrier = new Dog();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog() {",
            "  ",
            "}",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dae367417b2b2512b7a",
      "title": "Verify an Object's Constructor with instanceof",
      "description": [
        "凡是通过构造函数创建出的新对象，都叫做这个构造函数的<code>实例</code>。JavaScript 提供了一种很简便的方法来验证这个事实，那就是通过<code>instanceof</code>操作符。<code>instanceof</code>允许你将对象与构造函数之间进行比较，根据对象是否由这个构造函数创建的返回<code>true</code>或者<code>false</code>。以下是一个示例：",
        "<blockquote>let Bird = function(name, color) {<br>&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;this.color = color;<br>&nbsp;&nbsp;this.numLegs = 2;<br>}<br><br>let crow = new Bird(\"Alexis\", \"black\");<br><br>crow instanceof Bird; // => true</blockquote>",
        "如果一个对象不是使用构造函数创建的，那么<code>instanceof</code>将会验证这个对象不是构造函数的实例：",
        "<blockquote>let canary = {<br>&nbsp;&nbsp;name: \"Mildred\",<br>&nbsp;&nbsp;color: \"Yellow\",<br>&nbsp;&nbsp;numLegs: 2<br>};<br><br>canary instanceof Bird; // => false</blockquote>",
        "<hr>",
        "给<code>House</code>构造函数创建一个新实例，取名为<code>myHouse</code>并且传递一个数字给<code>bedrooms<code>参数。然后使用<code>instanceof</code>操作符验证这个对象是否为<code>House</code>的实例。"
      ],
      "tests": [
        {
          "text": "<code>myHouse</code>应该有一个<code>numBedrooms</code>属性被赋值为一个数字。",
          "testString": "assert(typeof myHouse.numBedrooms === 'number', '<code>myHouse</code>应该有一个<code>numBedrooms</code>属性被赋值为一个数字。');"
        },
        {
          "text": "请务必使用<code>instanceof</code>操作符验证<code>myHouse</code>这个对象是<code>House</code>构造函数的一个实例。",
          "testString": "assert(/myHouse\\s*instanceof\\s*House/.test(code), '请务必使用<code>instanceof</code>操作符验证<code>myHouse</code>这个对象是<code>House</code>构造函数的一个实例。');"
        }
      ],
      "solutions": [
        "function House(numBedrooms) {\n  this.numBedrooms = numBedrooms;\n}\nconst myHouse = new House(4);\nconsole.log(myHouse instanceof House);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "/* jshint expr: true */",
            "",
            "function House(numBedrooms) {",
            "  this.numBedrooms = numBedrooms;",
            "}",
            "",
            "// 请把你的代码写在这条注释以下",
            "",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dae367417b2b2512b7b",
      "title": "Understand Own Properties",
      "description": [
        "请看下面的实例，<code>Bird</code>构造函数定义了两个属性：<code>name</code>和<code>numLegs</code>：",
        "<blockquote>function Bird(name) {<br>&nbsp;&nbsp;this.name  = name;<br>&nbsp;&nbsp;this.numLegs = 2;<br>}<br><br>let duck = new Bird(\"Donald\");<br>let canary = new Bird(\"Tweety\");</blockquote>",
        "<code>name</code>和<code>numLegs</code>被叫做<code>自身</code>属性，因为他们是直接在实例对象上定义的。这就意味着<code>duck</code>和<code>canary</code>这两个对象分别拥有这些属性的独立副本。",
        "事实上，<code>Bird</code>的这些实例都将拥有这些属性的独立副本。",
        "以下的代码将<code>duck</code>里面所有的<code>自身</code>属性都存到一个叫 code>ownProps</code>的数组里面：",
        "<blockquote>let ownProps = [];<br><br>for (let property in duck) {<br>&nbsp;&nbsp;if(duck.hasOwnProperty(property)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;ownProps.push(property);<br>&nbsp;&nbsp;}<br>}<br><br>console.log(ownProps); // prints [ \"name\", \"numLegs\" ]</blockquote>",
        "<hr>",
        "将<code>canary</code>对象里面的<code>自身</code>属性添加到<code>ownProps</code>数组里面。"
      ],
      "tests": [
        {
          "text": "<code>ownProps</code>应该包含<code>\"numLegs\"</code>和<code>\"name\"</code>两个属性的值。",
          "testString": "assert(ownProps.indexOf('name') !== -1 && ownProps.indexOf('numLegs') !== -1, '<code>ownProps</code>应该包含<code>\"numLegs\"</code>和<code>\"name\"</code>两个属性的值。');"
        },
        {
          "text": "在不使用内置方法<code>Object.keys()</code>的情况下完成这个挑战。",
          "testString": "assert(!/\\Object.keys/.test(code), '在不使用内置方法<code>Object.keys()</code>的情况下完成这个挑战。');"
        }
      ],
      "solutions": [
        "function Bird(name) {\n  this.name = name;\n  this.numLegs = 2;\n}\n\nlet canary = new Bird(\"Tweety\");\nfunction getOwnProps (obj) {\n  const props = [];\n  \n  for (let prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      props.push(prop);\n    }\n  }\n  \n  return props;\n}\n\nconst ownProps = getOwnProps(canary);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Bird(name) {",
            "  this.name = name;",
            "  this.numLegs = 2;",
            "}",
            "",
            "let canary = new Bird(\"Tweety\");",
            "let ownProps = [];",
            "// 请把你的代码写在这条注释以下",
            "",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dae367417b2b2512b7c",
      "title": "Use Prototype Properties to Reduce Duplicate Code",
      "description": [
        "所有<code>Bird</code>实例可能会有相同的<code>numLegs</code>值，所以在每一个<code>Bird</code>的实例中本质上都有一个重复的变量<code>numLegs</code>。",
        "当只有两个实例时可能并不是什么问题，但想象一下如果有数百万个实例，这将会产生许许多多重复的变量。",
        "这里有一个更好的方法可以解决上述问题，那就是使用<code>Bird</code>的<code>原型</code>。<code>原型</code>是一个可以在所有<code>Bird</code>实例之间共享的对象。以下是一个在<code>Bird prototype</code>中添加<code>numLegs</code>属性的示例：",
        "<blockquote>Bird.prototype.numLegs = 2;</blockquote>",
        "现在所有的<code>Bird</code>实例都拥有了共同的<code>numLegs</code>属性值。",
        "<blockquote>console.log(duck.numLegs);  // 在控制台输出 2<br>console.log(canary.numLegs);  // 在控制台输出 2</blockquote>",
        "由于所有的实例都可以继承<code>原型</code>上的属性，所以可以把<code>原型</code>看作是创建对象的 \"配方\"。",
        "请注意：<code>duck</code>和<code>canary</code>的<code>原型</code>是<code>Bird</code>构造函数原型<code>Bird.prototype</code>的一部分。JavaScript 中几乎所有的对象都有一个<code>原型</code>属性，这个属性是属于它所在的构造函数的一部分。",
        "<hr>",
        "给<code>Dog</code>的<code>原型</code>添加一个<code>numLegs</code>属性。"
      ],
      "tests": [
        {
          "text": "<code>beagle</code>应该有一个<code>numLegs</code>属性。",
          "testString": "assert(beagle.numLegs !== undefined, '<code>beagle</code>应该有一 <code>numLegs</code>属性。');"
        },
        {
          "text": "<code>beagle.numLegs</code>应该是一个数字。",
          "testString": "assert(typeof(beagle.numLegs) === 'number' , '<code>beagle.numLegs</code>应该是一个数字。');"
        },
        {
          "text": "<code>numLegs</code>应该是一个<code>原型</code>属性而不是一个<code>自身</code>属性。",
          "testString": "assert(beagle.hasOwnProperty('numLegs') === false, '<code>numLegs</code>应该是一个<code>原型</code>属性而不是一个<code>自身</code>属性。');"
        }
      ],
      "solutions": [
        "function Dog (name) {\n  this.name = name;\n}\nDog.prototype.numLegs = 4;\nlet beagle = new Dog(\"Snoopy\");"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "",
            "",
            "// 请把你的代码写在这条注释以下",
            "let beagle = new Dog(\"Snoopy\");"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7daf367417b2b2512b7d",
      "title": "Iterate Over All Properties",
      "description": [
        "现在你已经了解了两种属性: <code>自身</code>属性和<code>原型</code>属性。<code>自身</code>属性是直接在对象上定义的。而<code>原型</code>属性是定义在<code>prototype</code>上的：",
        "<blockquote>function Bird(name) {<br>&nbsp;&nbsp;this.name = name;  // 自身属性 <br>}<br><br>Bird.prototype.numLegs = 2; // 原型属性 <br><br>let duck = new Bird(\"Donald\");</blockquote>",
        "这个示例会告诉你如何将<code>duck</code>的<code>自身</code>属性和<code>原型</code>属性分别添加到<code>ownProps</code>数组和<code>prototypeProps</code>数组里面：",
        "<blockquote>let ownProps = [];<br>let prototypeProps = [];<br><br>for (let property in duck) {<br>&nbsp;&nbsp;if(duck.hasOwnProperty(property)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;ownProps.push(property);<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;prototypeProps.push(property);<br>&nbsp;&nbsp;}<br>}<br><br>console.log(ownProps); // 输出 [\"name\"]<br>console.log(prototypeProps); // 输出 [\"numLegs\"]</blockquote>",
        "<hr>",
        "将<code>beagle</code>的所有属性都添加到<code>ownProps</code>数组里面去。将<code>Dog</code>的所有<code>原型</code>属性添加到<code>prototypeProps</code>数组中。"
      ],
      "tests": [
        {
          "text": "这个<code>ownProps</code>数组应该包含<code>\"name\"</code>这个值。",
          "testString": "assert(ownProps.indexOf('name') !== -1, '这个<code>ownProps</code>属性应该包含<code>\"name\"</code>这个值。');"
        },
        {
          "text": "这个<code>prototypeProps</code>数组应该包含<code>\"numLegs\"</code>这个值。",
          "testString": "assert(prototypeProps.indexOf('numLegs') !== -1, '这个<code>prototypeProps</code>数组应该包含<code>\"numLegs\"</code>这个值。');"
        },
        {
          "text": "在不使用内置方法<code>Object.keys()</code>的情况下完成这个挑战。",
          "testString": "assert(!/\\Object.keys/.test(code), '在不使用内置方法<code>Object.keys()</code>的情况下完成这个挑战。');"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name;\n}\n\nDog.prototype.numLegs = 4;\n\nlet beagle = new Dog(\"Snoopy\");\n\nlet ownProps = [];\nlet prototypeProps = [];\nfor (let prop in beagle) {\n  if (beagle.hasOwnProperty(prop)) {\n    ownProps.push(prop);\n  } else {\n    prototypeProps.push(prop);\n  }\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "Dog.prototype.numLegs = 4;",
            "",
            "let beagle = new Dog(\"Snoopy\");",
            "",
            "let ownProps = [];",
            "let prototypeProps = [];",
            "",
            "// 请把你的代码写在这条注释以下 ",
            "",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7daf367417b2b2512b7e",
      "title": "Understand the Constructor Property",
      "description": [
        "在上一个挑战中创建的实例对象<code>duck</code>和<code>beagle</code>都有一个特殊的<code>constructor</code>属性：",
        "<blockquote>let duck = new Bird();<br>let beagle = new Dog();<br><br>console.log(duck.constructor === Bird);  //输出 true<br>console.log(beagle.constructor === Dog);  //输出 true</blockquote>",
        "需要注意到的是这个<code>constructor</code>属性是对创建这个实例的构造函数的一个引用。",
        "<code>constructor</code>属性存在的一个优势是，我们可以通过检查这个属性来找出它是一个什么样的对象。下面是一个例子，来看看是怎么使用的：",
        "<blockquote>function joinBirdFraternity(candidate) {<br>&nbsp;&nbsp;if (candidate.constructor === Bird) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;}<br>}</blockquote>",
        "<strong>注意：</strong><br>由于<code>constructor</code>属性可以被重写（在下面两节挑战中将会遇到），所以使用<code>instanceof</code>方法来检查对象的类型会更好。",
        "<hr>",
        "写一个<code>joinDogFraternity</code>函数，传入一个<code>candidate</code>参数并使用<code>constructor</code>属性来判断传入的 candidate 是不是<code>Dog</code>创建的对象实例，如果是，就返回<code>true</code>，否则返回<code>false</code>。"
      ],
      "tests": [
        {
          "text": "<code>joinDogFraternity</code>应该被定义为一个函数。",
          "testString": "assert(typeof(joinDogFraternity) === 'function', '<code>joinDogFraternity</code>应该被定义为一个函数。');"
        },
        {
          "text": "如果<code>candidate</code>是<code>Dog</code>的一个对象实例，则<code>joinDogFraternity</code>函数应该返回<code>true</code>。",
          "testString": "assert(joinDogFraternity(new Dog(\"\")) === true, '如果<code>candidate</code>是<code>Dog</code>的一个对象实例，则<code>joinDogFraternity</code>函数应该返回<code>true</code>。');"
        },
        {
          "text": "<code>joinDogFraternity</code>中应该用到<code>constructor</code>属性。",
          "testString": "assert(/\\.constructor/.test(code) && !/instanceof/.test(code), '<code>joinDogFraternity</code>中应该用到<code>constructor</code>属性。');"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name;\n}\nfunction joinDogFraternity(candidate) {\n  return candidate.constructor === Dog;\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "// 请把你的代码写在这条注释以下",
            "function joinDogFraternity(candidate) {",
            "  ",
            "}",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7daf367417b2b2512b7f",
      "title": "Change the Prototype to a New Object",
      "description": [
        "到目前为止，你已经可以单独给<code>prototype</code>添加属性了：",
        "<blockquote>Bird.prototype.numLegs = 2;</blockquote>",
        "这将在添加许多属性的时候变得单调乏味。",
        "<blockquote>Bird.prototype.eat = function() {<br>&nbsp;&nbsp;console.log(\"nom nom nom\");<br>}<br><br>Bird.prototype.describe = function() {<br>&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>}</blockquote>",
        "一种更有效的方法就是给对象的<code>prototype</code>设置为一个已经包含了属性的新对象。这样一来，所有属性都可以一次性添加进来：",
        "<blockquote>Bird.prototype = {<br>&nbsp;&nbsp;numLegs: 2, <br>&nbsp;&nbsp;eat: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"nom nom nom\");<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "<hr>",
        "通过给<code>prototype</code>设置为新对象的方法，在<code>Dog</code>构造函数的<code>原型</code>上添加一个属性<code>numLegs</code>以及两个方法：<code>eat()</code>和<code>describe()</code>。"
      ],
      "tests": [
        {
          "text": "<code>Dog.prototype</code>应该被设置为一个新对象。",
          "testString": "assert((/Dog\\.prototype\\s*?=\\s*?{/).test(code), '<code>Dog.prototype</code>应该被设置为一个新对象。');"
        },
        {
          "text": "<code>Dog.prototype</code>应该拥有属性<code>numLegs</code>。",
          "testString": "assert(Dog.prototype.numLegs !== undefined, '<code>Dog.prototype</code>应该拥有属性<code>numLegs</code>。');"
        },
        {
          "text": "<code>Dog.prototype</code>应该拥有方法<code>eat()</code>。",
          "testString": "assert(typeof Dog.prototype.eat === 'function', '<code>Dog.prototype</code>应该拥有方法<code>eat()</code>。'); "
        },
        {
          "text": "<code>Dog.prototype</code>应该拥有方法<code>describe()</code>。",
          "testString": "assert(typeof Dog.prototype.describe === 'function', '<code>Dog.prototype</code>应该拥有方法<code>describe()</code>。'); "
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name; \n}\nDog.prototype = {\nnumLegs: 4,\n  eat () {\n    console.log('nom nom nom');\n  },\n  describe () {\n    console.log('My name is ' + this.name);\n  }\n};"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name; ",
            "}",
            "",
            "Dog.prototype = {",
            "  // 请把你的代码写在这条注释以下",
            "  ",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7daf367417b2b2512b80",
      "title": "Remember to Set the Constructor Property when Changing the Prototype",
      "description": [
        "如果我们手动的给一个新对象重新设置<code>原型</code>的话，这将会产生一个重要的副作用：删除了<code>constructor</code>属性！所以在上一个挑战中，我们将<code>duck</code>的<code>constructor</code>属性输出到控制台的话将会得到以下结果：",
        "<blockquote>console.log(duck.constructor)<br>// 哎呀，控制台中输出了 ‘undefined’！</blockquote>",
        "为了解决这个问题，所以凡是原型被手动设置给了一个新对象，都要记得重新定义一个<code>constructor</code>属性：",
        "<blockquote>Bird.prototype = {<br>&nbsp;&nbsp;constructor: Bird, // 定义 constructor 属性<br>&nbsp;&nbsp;numLegs: 2,<br>&nbsp;&nbsp;eat: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"nom nom nom\");<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name); <br>&nbsp;&nbsp;}<br>};</blockquote>",
        "<hr>",
        "给<code>Dog 的原型</code>定义一个<code>constructor</code>属性。"
      ],
      "tests": [
        {
          "text": "<code>Dog.prototype</code>应该定义一个<code>constructor</code>属性。",
          "testString": "assert(Dog.prototype.constructor === Dog, '<code>Dog.prototype</code>应该定义一个<code>constructor</code>属性。');"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name; \n}\nDog.prototype = {\n  constructor: Dog,\n  numLegs: 2, \n  eat: function() {\n    console.log(\"nom nom nom\"); \n  }, \n  describe: function() {\n    console.log(\"My name is \" + this.name); \n  }\n};"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name; ",
            "}",
            "",
            "// 请只修改这条注释以下的代码",
            "Dog.prototype = {",
            "  ",
            "  numLegs: 2, ",
            "  eat: function() {",
            "    console.log(\"nom nom nom\"); ",
            "  }, ",
            "  describe: function() {",
            "    console.log(\"My name is \" + this.name); ",
            "  }",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db0367417b2b2512b81",
      "title": "Understand Where an Object’s Prototype Comes From",
      "description": [
        "就像人们从父母那里继承基因一样，对象也可直接从创建它的构造函数那里继承其<code>原型。请看下面的例子：<code>Bird</code>构造函数创建了一个<code>duck</code>对象：",
        "<blockquote>function Bird(name) {<br>&nbsp;&nbsp;this.name = name;<br>}<br><br>let duck = new Bird(\"Donald\");</blockquote>",
        "<code>duck</code>对象继承了<code>Bird</code>构造函数的<code>原型</code>。你可以使用<code>isPrototypeOf</code>方法来验证他们原型之间的关系：",
        "<blockquote>Bird.prototype.isPrototypeOf(duck);<br>// 返回 true</blockquote>",
        "<hr>",
        "使用<code>isPrototypeOf</code>方法验证<code>beagle</code>的<code>原型</code>是否继承了<code>Bird</code>构造函数的<code>原型</code>。"
      ],
      "tests": [
        {
          "text": "验证<code>Dog.prototype</code>应该是<code>beagle</code>的<code>原型</code>。",
          "testString": "assert(/Dog\\.prototype\\.isPrototypeOf\\(beagle\\)/.test(code), '验证<code>Dog.prototype</code>应该是<code>beagle</code>的<code>原型</code>。');"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name;\n}\nlet beagle = new Dog(\"Snoopy\");\nDog.prototype.isPrototypeOf(beagle);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "let beagle = new Dog(\"Snoopy\");",
            "",
            "// 请把你的代码写在这条注释以下",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db0367417b2b2512b82",
      "title": "Understand the Prototype Chain",
      "description": [
        "JavaScript 中所有的对象（除了少数例外）都有自己的<code>原型</code>。而且，对象的<code>原型</code>本身就是一个对象。",
        "<blockquote>function Bird(name) {<br>&nbsp;&nbsp;this.name = name;<br>}<br><br>typeof Bird.prototype; // => object</blockquote>",
        "正是因为<code>原型</code>也是一个对象，所以<code>原型</code>对象也有属于它自己的<code>原型</code>！这样看来的话，<code>Bird.prototype</code>的<code>原型</code>就是<code>Object.prototype</code>：",
        "<blockquote>Object.prototype.isPrototypeOf(Bird.prototype);<br>// 返回 true</blockquote>",
        "这有什么作用呢？你可能还记得我们在上一个挑战中学到的<code>hasOwnProperty</code>方法：",
        "<blockquote>let duck = new Bird(\"Donald\");<br>duck.hasOwnProperty(\"name\"); // => true</blockquote>",
        "<code>hasOwnProperty</code>是定义在<code>Object.prototype</code>上的一个方法，<code>Bird.prototype</code>和<code>duck</code>对象方面并没有这个方法，但是我们可以在<code>Bird.prototype</code>上访问这个方法，还可以在<code>duck</code>对象上访问这个方法。这就是一个<code>原型</code>链。",
        "在这个<code>原型</code>链中，<code>Bird</code>构造函数是<code>duck</code>实例的<code>父级</code>，那么<code>duck</code>就是<code>子级</code>。<code>Object</code>则是<code>Bird</code>构造函数和<code>duck</code>实例共同的<code>父级</code>。",
        "<code>对象</code>是 JavaScript 中所有对象的<code>父级</code>，也就是原型链的最顶层。因此，所有对象都可以访问<code>hasOwnProperty</code>这个方法。",
        "<hr>",
        "修改以下代码使其展示出正确的原型链。"
      ],
      "tests": [
        {
          "text": "你的代码应该展示<code>Object.prototype</code>是<code>Dog.prototype</code>的原型。",
          "testString": "assert(/Object\\.prototype\\.isPrototypeOf/.test(code), \"你的代码应该展示<code>Object.prototype</code>是<code>Dog.prototype</code>的原型。\");"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name;\n}\nlet beagle = new Dog(\"Snoopy\");\nDog.prototype.isPrototypeOf(beagle);\nObject.prototype.isPrototypeOf(Dog.prototype);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "let beagle = new Dog(\"Snoopy\");",
            "",
            "Dog.prototype.isPrototypeOf(beagle);  // => true",
            "",
            "// 修改以下代码使其结果返回 true",
            "???.isPrototypeOf(Dog.prototype);",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db0367417b2b2512b83",
      "title": "Use Inheritance So You Don't Repeat Yourself",
      "description": [
        "编程中有一个潜在的原则就是：<code>不要重复你的代码（简称：DRY ）</code>。编写重复的代码之所以会成为一个问题，是因为任何改变都需要去多个地方修复你所有重复的代码，这通常意味着我们需要做更多的工作，而且会产生更高的出错率。",
        "请注意观察下面的示例，<code>describe</code>这个方法本应该是由<code>Bird</code>和<code>Dog</code>共享的：",
        "<blockquote>Bird.prototype = {<br>&nbsp;&nbsp;constructor: Bird,<br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>&nbsp;&nbsp;}<br>};<br><br>Dog.prototype = {<br>&nbsp;&nbsp;constructor: Dog,<br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "但在上面的示例中，<code>describe</code>方法在两个地方重复定义了。根据上面所说的<code>DRY</code>原则，我们可以通过创建一个叫做<code>Animal</code>的<code>超类型</code>（或者父类）来重写这段代码：",
        "<blockquote>function Animal() { };<br><br>Animal.prototype = {<br>&nbsp;&nbsp;constructor: Animal, <br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "由于<code>Animal</code>构造函数包括了<code>describe</code>方法，所以你可以在<code>Bird</code>和<code>Dog</code>这两个构造函数里面去掉这个方法：",
        "<blockquote>Bird.prototype = {<br>&nbsp;&nbsp;constructor: Bird<br>};<br><br>Dog.prototype = {<br>&nbsp;&nbsp;constructor: Dog<br>};</blockquote>",
        "<hr>",
        "<code>Cat</code>和<code>Bear</code>中的<code>eat</code>方法重复定义了。本着<code>DRY</code>的原则，通过将<code>eat</code>方法移动到<code>Animal</code>这个<code>超类</code>中来重写你的代码。"
      ],
      "tests": [
        {
          "text": "<code>Animal.prototype</code>应该有<code>eat</code>属性。",
          "testString": "assert(Animal.prototype.hasOwnProperty('eat'), '<code>Animal.prototype</code>应该有<code>eat</code>属性。');"
        },
        {
          "text": "<code>Bear.prototype</code>不应该有<code>eat</code>属性。",
          "testString": "assert(!(Bear.prototype.hasOwnProperty('eat')), '<code>Bear.prototype</code>不应该有<code>eat</code>属性。');"
        },
        {
          "text": "<code>Cat.prototype</code>不应该有<code>eat</code>属性。",
          "testString": "assert(!(Cat.prototype.hasOwnProperty('eat')), '<code>Cat.prototype</code>不应该有<code>eat</code>属性。');"
        }
      ],
      "solutions": [
        "function Cat(name) {\n  this.name = name; \n}\n\nCat.prototype = {\n  constructor: Cat\n};\n\nfunction Bear(name) {\n  this.name = name; \n}\n\nBear.prototype = {\n  constructor: Bear\n};\n\nfunction Animal() { }\n\nAnimal.prototype = {\n  constructor: Animal,\n  eat: function() {\n    console.log(\"nom nom nom\");\n  }\n};"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Cat(name) {",
            "  this.name = name; ",
            "}",
            "",
            "Cat.prototype = {",
            "  constructor: Cat, ",
            "  eat: function() {",
            "    console.log(\"nom nom nom\");",
            "  }",
            "};",
            "",
            "function Bear(name) {",
            "  this.name = name; ",
            "}",
            "",
            "Bear.prototype = {",
            "  constructor: Bear, ",
            "  eat: function() {",
            "    console.log(\"nom nom nom\");",
            "  }",
            "};",
            "",
            "function Animal() { }",
            "",
            "Animal.prototype = {",
            "  constructor: Animal,",
            "  ",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db0367417b2b2512b84",
      "title": "Inherit Behaviors from a Supertype",
      "description": [
        "在上一个挑战中，我们创建了一个叫做<code>Animal</code>的<code>超类</code>，用来定义所有动物共有的行为：",
        "<blockquote>function Animal() { }<br>Animal.prototype.eat = function() {<br>&nbsp;&nbsp;console.log(\"nom nom nom\");<br>};</blockquote>",
        "在这一节以及下一节挑战中我们将涉及到如何将<code>Bird</code>和<code>Dog</code>中重写<code>Animal</code>的方法，而无需重新定义它们。这里我们将会用到构造函数里面的<code>继承</code>这个特性。",
        "这一节挑战中我们学习第一步：创建一个<code>超类</code>（或者叫父类）的实例。",
        "你已经学会了一种使用<code>new</code>操作符来创建一个<code>Animal</code>实例的方法：",
        "<blockquote>let animal = new Animal();</blockquote>",
        "此语法用于<code>继承</code>时会存在一些缺点，这些缺点对于当前我们这个挑战的范围来说太负责了。相反，这里有一种没有这些缺点的方法来替代<code>new</code>操作：",
        "<blockquote>let animal = Object.create(Animal.prototype);</blockquote>",
        "<code>Object.create(obj)</code>创建了一个新对象，并指定了<code>obj</code>作为新对象的<code>原型</code>。回忆一下，我们之前就说过<code>原型</code>就像是创建对象的一个 \"配方\"。通过给<code>animal</code>的<code>原型</code>设置为<code>Animal</code>构造函数的<code>原型</code>，你将可以有效的给<code>animal</code>对象以及<code>Animal</code>构造函数的任何其他实例相同的 \"配方\"。",
        "<blockquote>animal.eat(); // 输出 \"nom nom nom\"<br>animal instanceof Animal; // => true</blockquote>",
        "<hr>",
        "使用<code>Object.create</code>方法给<code>Animal</code>创建两个实例：<code>duck</code>和<code>beagle</code>。"
      ],
      "tests": [
        {
          "text": "<code>duck</code>变量应该被定义为一个对象。",
          "testString": "assert(typeof duck !== \"undefined\", '<code>duck</code>变量应该被定义为一个对象。');"
        },
        {
          "text": "<code>beagle</code>变量应该被定义为一个对象。",
          "testString": "assert(typeof beagle !== \"undefined\", 'The <code>beagle</code>变量应该被定义为一个对象。');"
        },
        {
          "text": "<code>duck</code>的原型应该被设置为<code>Animal</code>构造函数的<code>原型</code>。",
          "testString": "assert(duck instanceof Animal, '<code>duck</code>的原型应该被设置为<code>Animal</code>构造函数的<code>原型</code>。');"
        },
        {
          "text": "<code>beagle</code>的原型应该被设置为<code>Animal</code>构造函数的<code>原型</code>。",
          "testString": "assert(beagle instanceof Animal, '<code>beagle</code>的原型应该被设置为<code>Animal</code>构造函数的<code>原型</code>。');"
        }
      ],
      "solutions": [
        "function Animal() { }\n\nAnimal.prototype = {\n  constructor: Animal, \n  eat: function() {\n    console.log(\"nom nom nom\");\n  }\n};\nlet duck = Object.create(Animal.prototype);\nlet beagle = Object.create(Animal.prototype);\n\nduck.eat();\nbeagle.eat();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Animal() { }",
            "",
            "Animal.prototype = {",
            "  constructor: Animal, ",
            "  eat: function() {",
            "    console.log(\"nom nom nom\");",
            "  }",
            "};",
            "",
            "// 请把你的代码写在这条注释以下",
            "",
            "let duck; // 修改这一行代码",
            "let beagle; // 修改这一行代码",
            "",
            "duck.eat(); // 应该输出 \"nom nom nom\"",
            "beagle.eat(); // 应该输出 \"nom nom nom\" "
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db1367417b2b2512b85",
      "title": "Set the Child's Prototype to an Instance of the Parent",
      "description": [
        "在上一个挑战中，我们学习了从<code>超类 Animal</code>（或者叫父类）继承其行为的第一个步骤：使用<code>Object.create</code>方法创建<code>Animal</code>的实例。",
        "这一节挑战我们将学习第二个步骤：给<code>子类型</code>（或者子类）设置<code>原型</code>。这样一来，<code>Bird</code>就是<code>Animal</code>的一个实例了。",
        "<blockquote>Bird.prototype = Object.create(Animal.prototype);</blockquote>",
        "请记住，<code>原型</code>类似于创建对象的 \"配方\"。从某种意义上来说，现在<code>Bird</code>对象的配方包含了<code>Animal</code>构造函数的所有关键 \"成分\"。",
        "<blockquote>let duck = new Bird(\"Donald\");<br>duck.eat(); // 输出 \"nom nom nom\"</blockquote>",
        "<code>duck</code>继承了<code>Animal</code>构造函数的所有属性，也包括了<code>eat</code>方法。",
        "<hr>",
        "修改你的代码，以实现<code>Dog</code>实例继承了<code>Animal</code>构造函数。"
      ],
      "tests": [
        {
          "text": "<code>Dog.prototype</code>应该是<code>Animal</code>的一个实例。",
          "testString": "assert(Animal.prototype.isPrototypeOf(Dog.prototype), '<code>Dog.prototype</code>应该是<code>Animal</code>的一个实例。');"
        }
      ],
      "solutions": [
        "function Animal() { }\n\nAnimal.prototype = {\n  constructor: Animal,\n  eat: function() {\n    console.log(\"nom nom nom\");\n  }\n};\n\nfunction Dog() { }\nDog.prototype = Object.create(Animal.prototype);\n\nlet beagle = new Dog();\nbeagle.eat();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Animal() { }",
            "",
            "Animal.prototype = {",
            "  constructor: Animal,",
            "  eat: function() {",
            "    console.log(\"nom nom nom\");",
            "  }",
            "};",
            "",
            "function Dog() { }",
            "",
            "// 请把你的代码写在这条注释以下",
            "",
            "",
            "let beagle = new Dog();",
            "beagle.eat();  // 应该输出 \"nom nom nom\""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db1367417b2b2512b86",
      "title": "Reset an Inherited Constructor Property",
      "description": [
        "当一个对象从另外一个对象那里继承了其<code>原型</code>，那么它也继承了<code>父类</code>的 constructor 属性。",
        "请看下面的举例：",
        "<blockquote>function Bird() { }<br>Bird.prototype = Object.create(Animal.prototype);<br>let duck = new Bird();<br>duck.constructor // function Animal(){...}</blockquote>",
        "但是<code>duck</code>和其他所有<code>Bird</code>的实例都应该表明它们是由<code>Bird</code>这个构造函数创建的，而不是由<code>Animal</code>创建的。为此，你可以手动的将<code>Bird</code>的 constructor 属性设置为<code>Bird</code>对象：",
        "<blockquote>Bird.prototype.constructor = Bird;<br>duck.constructor // function Bird(){...}</blockquote>",
        "<hr>",
        "修改你的代码，使得<code>duck.constructor</code>和<code>beagle.constructor</code>返回各自的 constructors 属性。"
      ],
      "tests": [
        {
          "text": "<code>Bird.prototype</code>应该是<code>Animal</code>的一个实例。",
          "testString": "assert(Animal.prototype.isPrototypeOf(Bird.prototype), '<code>Bird.prototype</code>应该是<code>Animal</code>的一个实例。');"
        },
        {
          "text": "<code>duck.constructor</code>应该返回<code>Bird</code>。",
          "testString": "assert(duck.constructor === Bird, '<code>duck.constructor</code>应该返回<code>Bird</code>。');"
        },
        {
          "text": "<code>Dog.prototype</code>应该是<code>Animal</code>的一个实例。",
          "testString": "assert(Animal.prototype.isPrototypeOf(Dog.prototype), '<code>Dog.prototype</code>应该是<code>Animal</code>的一个实例。');"
        },
        {
          "text": "<code>beagle.constructor</code>应该返回<code>Dog</code>。",
          "testString": "assert(beagle.constructor === Dog, '<code>beagle.constructor</code>应该返回<code>Dog</code>。');"
        }
      ],
      "solutions": [
        "function Animal() { }\nfunction Bird() { }\nfunction Dog() { }\nBird.prototype = Object.create(Animal.prototype);\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\nBird.prototype.constructor = Bird;\nlet duck = new Bird();\nlet beagle = new Dog();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Animal() { }",
            "function Bird() { }",
            "function Dog() { }",
            "",
            "Bird.prototype = Object.create(Animal.prototype);",
            "Dog.prototype = Object.create(Animal.prototype);",
            "",
            "// 请把你的代码写在这条注释以下",
            "",
            "",
            "",
            "let duck = new Bird();",
            "let beagle = new Dog();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db1367417b2b2512b87",
      "title": "Add Methods After Inheritance",
      "description": [
        "从<code>父类</code>构造函数继承其<code>原型</code>对象的构造函数除了继承过来的方法之外，还可以有自己的方法。",
        "请看举例：<code>Bird</code>构造函数继承了<code>Animal</code>构造函数的<code>原型</code>：",
        "<blockquote>function Animal() { }<br>Animal.prototype.eat = function() {<br>&nbsp;&nbsp;console.log(\"nom nom nom\");<br>};<br>function Bird() { }<br>Bird.prototype = Object.create(Animal.prototype);<br>Bird.prototype.constructor = Bird;</blockquote>",
        "除了从<code>Animal</code>构造函数继承的行为之外，你可能还需要给<code>Bird</code>对象添加表示其唯一的行为。这里，我们给<code>Bird</code>对象添加一个<code>fly()</code>函数。函数以一种和其他任意构造函数相同的方式添加到<code>Bird</code>的<code>原型</code>中：",
        "<blockquote>Bird.prototype.fly = function() {<br>&nbsp;&nbsp;console.log(\"I'm flying!\");<br>};</blockquote>",
        "现在<code>Bird</code>的实例中就有了<code>eat()</code>和<code>fly()</code>这两个方法：",
        "<blockquote>let duck = new Bird();<br>duck.eat(); // 输出 \"nom nom nom\"<br>duck.fly(); // 输出 \"I'm flying!\"</blockquote>",
        "<hr>",
        "添加所有必要的代码，使得<code>Dog</code>对象继承<code>Animal</code>构造函数，并且把<code>Dog 原型</code>上的 constructor 属性设置为 Dog。然后给<code>Dog</code>对象添加一个<code>bark()</code>方法，这样的话，<code>beagle</code>将同时拥有<code>eat()</code>和<code>bark()</code>这个两个方法。在<code>bark()</code>方法中应该将 \"Woof!\" 输出到控制台。"
      ],
      "tests": [
        {
          "text": "<code>Animal</code>应该不拥有<code>bark()</code>方法。",
          "testString": "assert(typeof Animal.prototype.bark == \"undefined\", '<code>Animal</code>应该不拥有<code>bark()</code>方法。');"
        },
        {
          "text": "<code>Dog</code>应该继承了<code>Animal</code>构造函数的<code>eat()</code>方法。",
          "testString": "assert(typeof Dog.prototype.eat == \"function\", '<code>Dog</code>应该继承了<code>Animal</code>构造函数的<code>eat()</code>方法。');"
        },
        {
          "text": "<code>Dog</code>应该有一个<code>bark()</code>方法作为<code>自身</code>属性。",
          "testString": "assert(Dog.prototype.hasOwnProperty('bark'), '<code>Dog</code>应该有一个<code>bark()</code>方法作为<code>自身</code>属性。');"
        },
        {
          "text": "<code>beagle</code>应该是<code>Animal</code>的一个<code>instanceof</code>。",
          "testString": "assert(beagle instanceof Animal, '<code>beagle</code>应该是<code>Animal</code>的一个<code>instanceof</code>。');"
        },
        {
          "text": "<code>beagle</code>的 constructor 属性应该被设置为<code>Dog</code>。",
          "testString": "assert(beagle.constructor === Dog, '<code>beagle</code>的 constructor 属性应该被设置为<code>Dog</code>。');"
        }
      ],
      "solutions": [
        "function Animal() { }\nAnimal.prototype.eat = function() { console.log(\"nom nom nom\"); };\n\nfunction Dog() { }\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\nDog.prototype.bark = function () {\n  console.log('Woof!');\n};\nlet beagle = new Dog();\n\nbeagle.eat();\nbeagle.bark();"
      ],
      "hints": [
        "Objects inherit methods from other objects by cloning their prototype. The Object.create method will come in handy, and don't forget to reset the constructor property afterward!"
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Animal() { }",
            "Animal.prototype.eat = function() { console.log(\"nom nom nom\"); };",
            "",
            "function Dog() { }",
            "",
            "// 请把你的代码写在这条注释以下 ",
            "",
            "",
            "",
            "",
            "// 请把你的代码写在这条注释以下 ",
            "",
            "let beagle = new Dog();",
            "",
            "beagle.eat(); // 应该输出 \"nom nom nom\"",
            "beagle.bark(); // 应该输出 \"Woof!\""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db1367417b2b2512b88",
      "title": "Override Inherited Methods",
      "description": [
        "在上一个挑战中，我们学习到了一个对象可以通过复制另一个对象的<code>原型</code>继承其属性和行为（或方法）：",
        "<blockquote>ChildObject.prototype = Object.create(ParentObject.prototype);</blockquote>",
        "然后，<code>ChildObject</code>通过将它们（即需要添加的方法）链接到它的<code>原型</code>中就可以访问到自己的方法了：",
        "<blockquote>ChildObject.prototype.methodName = function() {...};</blockquote>",
        "我们还可以重写继承的方法。还是以同样的方法，通过使用与要重写的方法相同的方法名向<code>ChildObject.prototype</code>中添加方法。",
        "请看下面的举例：<code>Bird</code>重写了从<code>Animal</code>继承来的<code>eat()</code>方法：",
        "<blockquote>function Animal() { }<br>Animal.prototype.eat = function() {<br>&nbsp;&nbsp;return \"nom nom nom\";<br>};<br>function Bird() { }<br><br>// 继承了 Animal 的所有方法<br>Bird.prototype = Object.create(Animal.prototype);<br><br>// Bird.eat() 重写了 Animal.eat() 方法<br>Bird.prototype.eat = function() {<br>&nbsp;&nbsp;return \"peck peck peck\";<br>};</blockquote>",
        "如果你有一个实例：<code>let duck = new Bird();</code>，然后你调用了<code>duck.eat()</code>，这就是 JavaScript 如何在<code>duck</code>的<code>原型</code>链上寻找方法：",
        "1. duck => 这里定义了 eat() 方法吗？没有。",
        "2. Bird => 这里定义了 eat() 方法吗？=> 是的。执行它并停止往上搜索。",
        "3. Animal => 这里也定义了 eat() 方法，但是 JavaScript 在到达这层原型链之前已停止了搜索。",
        "4. Object => JavaScript 在到达这层原型链之前也已经停止了搜索。",
        "<hr>",
        "重写<code>Penguin</code>对象里面的<code>fly()</code>方法，使其返回 \"Alas, this is a flightless bird.\""
      ],
      "tests": [
        {
          "text": "<code>penguin.fly()</code>方法应该返回字符串：\"Alas, this is a flightless bird.\"",
          "testString": "assert(penguin.fly() === \"Alas, this is a flightless bird.\", '<code>penguin.fly()</code>方法应该返回字符串：\"Alas, this is a flightless bird.\"');"
        },
        {
          "text": "The <code>bird.fly()</code>方法应该返回 \"I am flying!\"",
          "testString": "assert((new Bird()).fly() === \"I am flying!\", 'The <code>bird.fly()</code>方法应该返回 \"I am flying!\"');"
        }
      ],
      "solutions": [
        "function Bird() { }\n\nBird.prototype.fly = function() { return \"I am flying!\"; };\n\nfunction Penguin() { }\nPenguin.prototype = Object.create(Bird.prototype);\nPenguin.prototype.constructor = Penguin;\nPenguin.prototype.fly = () => 'Alas, this is a flightless bird.';\nlet penguin = new Penguin();\nconsole.log(penguin.fly());"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Bird() { }",
            "",
            "Bird.prototype.fly = function() { return \"I am flying!\"; };",
            "",
            "function Penguin() { }",
            "Penguin.prototype = Object.create(Bird.prototype);",
            "Penguin.prototype.constructor = Penguin;",
            "",
            "// 请把你的代码写在这条注释以下",
            "",
            "",
            "",
            "// 请把你的代码写在这条注释以下",
            "",
            "let penguin = new Penguin();",
            "console.log(penguin.fly());"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db2367417b2b2512b89",
      "title": "Use a Mixin to Add Common Behavior Between Unrelated Objects",
      "description": [
        "正如你所见，行为是通过继承来共享的。然而，在有些情况下，继承不是最好的解决方案。继承不适用于那些不相关的对象，比如<code>Bird</code>和<code>Airplane</code>。它们都可以飞行，但是一个<code>Bird</code>并不是一种<code>Airplane</code>，反之亦然。",
        "对于不相关的对象，最好使用<code>mixins</code>类。一个<code>mixin</code>类允许其他对象使用函数集合。",
        "<blockquote>let flyMixin = function(obj) {<br>&nbsp;&nbsp;obj.fly = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Flying, wooosh!\");<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "<code>flyMixin</code>构造器能接受任何对象，并为其提供了<code>fly</code>方法。",
        "<blockquote>let bird = {<br>&nbsp;&nbsp;name: \"Donald\",<br>&nbsp;&nbsp;numLegs: 2<br>};<br><br>let plane = {<br>&nbsp;&nbsp;model: \"777\",<br>&nbsp;&nbsp;numPassengers: 524<br>};<br><br>flyMixin(bird);<br>flyMixin(plane);</blockquote>",
        "这里，<code>bird</code>和code>plane</code>对象都被传递到了<code>flyMixin</code>，然后将<code>fly</code>方法分配给了每一个对象。现在<code>bird</code>和<code>plane</code>都可以飞行了：",
        "<blockquote>bird.fly(); // 输出 \"Flying, wooosh!\"<br>plane.fly(); // 输出 \"Flying, wooosh!\"</blockquote>",
        "请注意：<code>mixin</code>是如何允许相同的<code>fly</code>方法被不相关的对象<code>bird</code>和<code>plane</code>重用的。",
        "<hr>",
        "创建一个名为<code>glideMixin</code>的<code>mixin</code>类，并定义一个<code>glide</code>方法。然后使用<code>glideMixin</code>来给<code>bird</code>和<code>boat</code>赋予滑行的能力。"
      ],
      "tests": [
        {
          "text": "你的代码应该声明一个变量名为<code>glideMixin</code>的函数。",
          "testString": "assert(typeof glideMixin === \"function\", '你的代码应该声明一个变量名为<code>glideMixin</code>的函数。');"
        },
        {
          "text": "你的代码应该在<code>bird</code>上使用<code>glideMixin</code>，以提供<code>glide</code>方法。",
          "testString": "assert(typeof bird.glide === \"function\", '你的代码应该在<code>bird</code>上使用<code>glideMixin</code>，以提供<code>glide</code>方法。');"
        },
        {
          "text": "你的代码应该在<code>boat</code>上使用<code>glideMixin</code>，以提供<code>glide</code>方法。",
          "testString": "assert(typeof boat.glide === \"function\", '你的代码应该在<code>boat</code>上使用<code>glideMixin</code>，以提供<code>glide</code>方法。');"
        }
      ],
      "solutions": [
        "let bird = {\n  name: \"Donald\",\n  numLegs: 2\n};\n\nlet boat = {\n  name: \"Warrior\",\n  type: \"race-boat\"\n};\nfunction glideMixin (obj) {\n  obj.glide = () => 'Gliding!';\n}\n\nglideMixin(bird);\nglideMixin(boat);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let bird = {",
            "  name: \"Donald\",",
            "  numLegs: 2",
            "};",
            "",
            "let boat = {",
            "  name: \"Warrior\",",
            "  type: \"race-boat\"",
            "};",
            "",
            "// 请把你的代码写在这条注释以下",
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db2367417b2b2512b8a",
      "title": "Use Closure to Protect Properties Within an Object from Being Modified Externally",
      "description": [
        "在上一次挑战中，<code>bird</code>有一个公共属性<code>name</code>。它之所以被认为是公共的，是因为它可以在<code>bird</code>的定义范围之外被访问和更改。",
        "<blockquote>bird.name = \"Duffy\";</blockquote>",
        "因此，你代码的任何部分都可以轻松地将<code>bird</code>的 name 属性更改为任意值。想想密码和银行账户之类的东西，如果你代码库的任何部分都可以轻易改变，那么将会引起很多问题。",
        "使属性私有化最简单的方法就是通过在构造函数中创建变量。这改变了该变量在构造函数中的范围，而不是全局可用的范围。这样，属性只能由构造函数中的方法访问和更改。",
        "<blockquote>function Bird() {<br>&nbsp;&nbsp;let hatchedEgg = 10; // 私有属性 <br><br>&nbsp;&nbsp;this.getHatchedEggCount = function() { // bird 对象可以是使用的公有方法 <br>&nbsp;&nbsp;&nbsp;&nbsp;return hatchedEgg;<br>&nbsp;&nbsp;};<br>}<br>let ducky = new Bird();<br>ducky.getHatchedEggCount(); // 返回 10</blockquote>",
        "这里的<code>getHachedEggCount</code>是一种特权方法，因为它可以访问私有属性<code>hatchedEgg</code>。这是可能的，因为<code>hatchedEgg</code>是在与<code>getHachedEggCount</code>相同的上下文中声明的。在 JavaScript 中，函数总是可以访问创建它的上下文。这就叫做<code>闭包</code>。",
        "<hr>",
        "更改在<code>Bird</code>函数中声明<code>weight</code>的方法，使其成为私有变量。然后，创建一个返回<code>weight</code>值的<code>getWeight</code>方法。"
      ],
      "tests": [
        {
          "text": "<code>weight</code>属性应该是一个私有变量。",
          "testString": "assert(!code.match(/this\\.weight/g), 'The <code>weight</code>属性应该是一个私有变量。');"
        },
        {
          "text": "你的代码应该在<code>Bird</code>中创建一个名为<code>getWeight</code>方法，该方法返回<code>weight</code>值。",
          "testString": "assert((new Bird()).getWeight() === 15, '你的代码应该在<code>Bird</code>中创建一个名为<code>getWeight</code>方法，该方法返回<code>weight</code>值。');"
        }
      ],
      "solutions": [
        "function Bird() {\n  let weight = 15;\n  \n  this.getWeight = () => weight;\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Bird() {",
            "  this.weight = 15;",
            "  ",
            "  ",
            "}",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db2367417b2b2512b8b",
      "title": "Understand the Immediately Invoked Function Expression (IIFE)",
      "description": [
        "JavaScript 中的一个常见模式就是，函数一被声明就执行：",
        "<blockquote>(function () {<br>&nbsp;&nbsp;console.log(\"Chirp, chirp!\");<br>})(); // 这是一个立即执行的匿名函数表达式<br>// 立即输出 \"Chirp, chirp!\"</blockquote>",
        "请注意，函数没有名称，也不存储在变量中。函数表达式末尾的两个括号（）导致它被立即执行或调用。这种模式被叫做<code>自执行函数表达式</code>或者<code>IIFE</code>。",
        "<hr>",
        "重写函数<code>makeNest</code>，并删除它的调用，取而代之是一个匿名的<code>自执行函数表达式</code>（<code>IIFE</code>）。"
      ],
      "tests": [
        {
          "text": "该函数应该是匿名的。",
          "testString": "assert(/\\(\\s*?function\\s*?\\(\\s*?\\)\\s*?{/.test(code), '该函数应该是匿名的。');"
        },
        {
          "text": "你的函数应该在表达式的末尾有括号，以便立即调用它。",
          "testString": "assert(/}\\s*?\\)\\s*?\\(\\s*?\\)/.test(code), '你的函数应该在表达式的末尾有括号，以便立即调用它。');"
        }
      ],
      "solutions": [
        "(function () {\n  console.log(\"A cozy nest is ready\");\n})();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function makeNest() {",
            "  console.log(\"A cozy nest is ready\");",
            "}",
            "",
            "makeNest(); "
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db2367417b2b2512b8c",
      "title": "Use an IIFE to Create a Module",
      "description": [
        "一个<code>自执行函数表达式</code>（<code>IIFE</code>）通常用于将相关功能分组到单个对象或者是<code>模块</code>中。例如，先前的挑战中定义了两种的一个混合类：",
        "<blockquote>function glideMixin(obj) {<br>&nbsp;&nbsp;obj.glide = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Gliding on the water\");<br>&nbsp;&nbsp;};<br>}<br>function flyMixin(obj) {<br>&nbsp;&nbsp;obj.fly = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Flying, wooosh!\");<br>&nbsp;&nbsp;};<br>}</blockquote>",
        "我们可以将这些<code>mixins</code>分成以下模块：",
        "<blockquote>let motionModule = (function () {<br>&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;glideMixin: function (obj) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.glide = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Gliding on the water\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;flyMixin: function(obj) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.fly = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Flying, wooosh!\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}) (); // 两个括号导致函数被立即调用</blockquote>",
        "请注意，你有一个<code>自执行函数表达式</code>（<code>IIFE</code>）返回一个<code>motionModule</code>对象。这个返回的对象包含作为对象属性的所有<code>mixin</code>行为。",
        "<code>模块</code>模式的优点是，所有的运动行为都可以打包成一个对象，然后由代码的其他部分使用。下面是一个使用它的例子：",
        "<blockquote>motionModule.glideMixin(duck);<br>duck.glide();</blockquote>",
        "<hr>",
        "创建一个名为<code>funModule</code>的<code>模块</code>，将这两个<code>mixins</code>：<code>isCuteMixin</code>和<code>singMixin</code>包装起来。<code>funModule</code>应该返回一个对象。"
      ],
      "tests": [
        {
          "text": "<code>funModule</code>应该被定义并返回一个对象。",
          "testString": "assert(typeof funModule === \"object\", '<code>funModule</code>应该被定义并返回一个对象。');"
        },
        {
          "text": "<code>funModule.isCuteMixin</code>应该访问一个函数。",
          "testString": "assert(typeof funModule.isCuteMixin === \"function\", '<code>funModule.isCuteMixin</code>应该访问一个函数。');"
        },
        {
          "text": "<code>funModule.singMixin</code>应该访问一个函数。",
          "testString": "assert(typeof funModule.singMixin === \"function\", '<code>funModule.singMixin</code>应该访问一个函数。');"
        }
      ],
      "solutions": [
        "const funModule = (function () {\n  return {\n    isCuteMixin: obj => {\n      obj.isCute = () => true;\n    },\n    singMixin: obj => {\n      obj.sing = () => console.log(\"Singing to an awesome tune\");\n    }\n  };\n})();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let isCuteMixin = function(obj) {",
            "  obj.isCute = function() {",
            "    return true;",
            "  };",
            "};",
            "let singMixin = function(obj) {",
            "  obj.sing = function() {",
            "    console.log(\"Singing to an awesome tune\");",
            "  };",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    }
  ]
}
