{
  "name": "Object Oriented Programming",
  "order": 7,
  "time": "5 hours",
  "helpRoom": "Help",
  "challenges": [
    {
      "id": "587d7dac367417b2b2512b73",
      "title": "Create a Basic JavaScript Object",
      "description": [
        "想想我们在生活中每天都可见到的事物：比如汽车、商店以及小鸟等。这些都是 <code>对象</code>：所以对象就是这些人们可以观察和与之互动的实体事物。",
        "那么这些 <code>对象</code> 都有哪些特征呢？比如汽车的特征是有轮子，商店是用来出售商品的，而小鸟的特征是有翅膀。",
        "这些特征，或者说是 <code>属性</code> 定义了一个 <code>对象</code> 由什么构成的。需要注意的是：那些相似的 <code>对象</code> 可以拥有相同的 <code>属性</code>，但是这些 <code>属性</code> 可能会有不同的值。举个例子：所有的汽车都有轮子，但并不是所有汽车的轮子个数都是一样的。",
        "Javascript 中的 <code>对象</code> 被用来模拟现实世界中的对象，并赋予他们 <code>属性</code> 和行为，就像它们在现实世界中的对应物一样。下面是使用这些概念来创建一个 <code>duck</code> <code>对象</code> 的示例：",
        "<blockquote>let duck = {<br>&nbsp;&nbsp;name: \"Aflac\",<br>&nbsp;&nbsp;numLegs: 2<br>};</blockquote>",
        "这个 <code>duck</code> <code>对象</code> 有两组键值对：一个是属性 <code>name</code> 的值是 \"Aflac\" 和 一个是属性 <code>numLegs</code> 的值是2。",
        "<hr>",
        "创建一个 <code>dog</code> <code>对象</code>，并给这个对象添加两个属性：<code>name</code> 和 <code>numLegs</code>，同时分别给这两个属性设置一个字符串和数字。"
      ],
      "tests": [
        {
          "text": "<code>dog</code> 应该就是一个 <code>object</code>。",
          "testString": "assert(typeof(dog) === 'object', '<code>dog</code> 应该就是一个 <code>object</code>');"
        },
        {
          "text": "<code>dog</code> 应该有一个 <code>name</code> 属性被设置了一个 <code>string</code>。",
          "testString": "assert(typeof(dog.name) === 'string', '<code>dog</code> 应该有一个 <code>name</code> 属性被设置了一个 <code>string</code>。');"
        },
        {
          "text": "<code>dog</code> 应该有一个 <code>numLegs</code> 属性被设置了一个 <code>number</code>。",
          "testString": "assert(typeof(dog.numLegs) === 'number', '<code>dog</code> 应该有一个 <code>numLegs</code> 属性被设置了一个 <code>number</code>。');"
        }
      ],
      "solutions": [
        "let dog = {\n  name: '',\n  numLegs: 4\n};"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let dog = {",
            "  ",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dac367417b2b2512b74",
      "title": "Use Dot Notation to Access the Properties of an Object",
      "description": [
        "在上一个挑战中创建了一个拥有不同的 <code>属性</code> 的 <code>对象</code>，接下来你就了解到是如何访问这些 <code>属性</code> 的，请看下面的例子：",
        "<blockquote>let duck = {<br>&nbsp;&nbsp;name: \"Aflac\",<br>&nbsp;&nbsp;numLegs: 2<br>};<br>console.log(duck.name);<br>// 这里将会输出 \"Aflac\" 到控制台 </blockquote>",
        "点标记可以用在一个 <code>对象</code> 名称后面：如<code>duck</code>，点后面就是 <code>属性</code> 的名称用来接收一个 \"Aflac\" 值：如 <code>name</code>。",
        "<hr>",
        "请在你的控制台里面输出 <code>dog</code> 这个对象的两个 <code>属性</code>。"
      ],
      "tests": [
        {
          "text": "你应该使用 <code>console.log</code> 来将 <code>dog</code> 对象的 <code>name</code> 属性值输出到控制台。",
          "testString": "assert(/console.log\\(.*dog\\.name.*\\)/g.test(code), '你应该使用 <code>console.log</code> 来将 <code>dog</code> 对象的 <code>name</code> 属性值输出到控制台。');"
        },
        {
          "text": "你应该使用 <code>console.log</code> 来将 <code>dog</code> 对象的 <code>numLegs</code> 属性值输出到控制台。",
          "testString": "assert(/console.log\\(.*dog\\.numLegs.*\\)/g.test(code), '你应该使用 <code>console.log</code> 来将 <code>dog</code> 对象的 <code>numLegs</code> 属性值输出到控制台。');"
        }
      ],
      "solutions": [
        "let dog = {\n  name: \"Spot\",\n  numLegs: 4\n};\nconsole.log(dog.name);\nconsole.log(dog.numLegs);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let dog = {",
            "  name: \"Spot\",",
            "  numLegs: 4",
            "};",
            "// 在下一行添加你的代码",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dad367417b2b2512b75",
      "title": "Create a Method on an Object",
      "description": [
        "<code>对象</code> 可以有一个叫做 <code>方法</code> 的特殊 <code>属性</code>。",
        "<code>方法</code> 其实就是一个函数 <code>属性</code>。它可以为一个 <code>对象</code> 添加不同的行为属性。以下就是一个带有方法属性的 <code>duck</code> 示例：",
        "<blockquote>let duck = {<br>&nbsp;&nbsp;name: \"Aflac\",<br>&nbsp;&nbsp;numLegs: 2,<br>&nbsp;&nbsp;sayName: function() {return \"The name of this duck is \" + duck.name + \".\";}<br>};<br>duck.sayName();<br>// 返回了: \"The name of this duck is Aflac.\"</blockquote>",
        "这个例子给 <code>duck</code> 对象添加了一个 <code>sayName</code> <code>method</code>，这个方法返回一个 <code>duck</code> 名字的语句",
        "注意：这个 <code>method</code> 在返回语句的声明里面使用了 <code>duck.name</code> 方式来接收 code>name</code> 的属性值。在下一个挑战中我们将会使用另外一种方法来实现。",
        "<hr>",
        "给 <code>dog</code> <code>对象</code> 设置一个名为 <code>sayLegs</code> 的方法，方法里面返回一个 \"This dog has 4 legs.\" 的语句。"
      ],
      "tests": [
        {
          "text": "<code>dog.sayLegs()</code> 应该是一个方法。",
          "testString": "assert(typeof(dog.sayLegs) === 'function', '<code>dog.sayLegs()</code>应该是一个方法。');"
        },
        {
          "text": "<code>dog.sayLegs()</code> 应该返回给定的字符串 - 需要注意标点和间距的问题。",
          "testString": "assert(dog.sayLegs() === 'This dog has 4 legs.', '<code>dog.sayLegs()</code> 应该返回给定的字符串 - 需要注意标点和间距的问题。');"
        }
      ],
      "solutions": [
        "let dog = {\n  name: \"Spot\",\n  numLegs: 4,\n  sayLegs () {\n    return 'This dog has ' + this.numLegs + ' legs.';\n  }\n};\n\ndog.sayLegs();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let dog = {",
            "  name: \"Spot\",",
            "  numLegs: 4,",
            "  ",
            "};",
            "",
            "dog.sayLegs();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dad367417b2b2512b76",
      "title": "Make Code More Reusable with the this Keyword",
      "description": [
        "在上一个挑战中介绍了如何给 <code>duck</code> 对象设置一个 <code>方法</code> 属性。",
        "<code>sayName: function() {return \"The name of this duck is \" + duck.name + \".\";}</code>",
        "虽然这是访问对象属性的有效方法，但是这里有一个陷阱。如果变量名发生了改变，那么引用了原始名称的任何代码都需要更新。在一个简短的对象定义中这并不是问题，但是如果对象有很多对其属性的引用，那么发生错误的可能性就更大了。",
        "我们可以使用 <code>this</code> 关键字这个方法来避免这一问题：",
        "<blockquote>let duck = {<br>&nbsp;&nbsp;name: \"Aflac\",<br>&nbsp;&nbsp;numLegs: 2,<br>&nbsp;&nbsp;sayName: function() {return \"The name of this duck is \" + this.name + \".\";}<br>};</blockquote>",
        "<code>this</code> 是一个很深入的话题，而上面那个例子也只是使用 <code>this</code> 的一种方法而已。在当面的上下文环境中，<code>this</code> 指向的就是与这个方法有关联的 <code>duck</code> 对象。",
        "如果把对象的变量名改为 <code>mallard</code>，那使用 <code>this</code> 就没有必要在代码中找到所有指向 <code>duck</code> 的部分，这样可以使得代码更具有可读性和复用性。",
        "<hr>",
        "修改 <code>dog.sayLegs</code> 方法以将所有直接对 <code>dog</code> 的引用删除。可以使用 <code>duck</code> 示例进行指导。"
      ],
      "tests": [
        {
          "text": "<code>dog.sayLegs()</code> 应该返回一个指定的字符串。",
          "testString": "assert(dog.sayLegs() === 'This dog has 4 legs.', '<code>dog.sayLegs()</code> 应该返回一个指定的字符串。');"
        },
        {
          "text": "你的代码应该使用 <code>this</code> 关键字来访问 <code>dog</code> 对象的 <code>numLegs</code> 属性值。",
          "testString": "assert(code.match(/this\\.numLegs/g), '你的代码应该使用 <code>this</code> 关键字来访问 <code>dog</code> 对象的 <code>numLegs</code> 属性值。');"
        }
      ],
      "solutions": [
        "let dog = {\n  name: \"Spot\",\n  numLegs: 4,\n  sayLegs () {\n    return 'This dog has ' + this.numLegs + ' legs.';\n  }\n};\n\ndog.sayLegs();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let dog = {",
            "  name: \"Spot\",",
            "  numLegs: 4,",
            "  sayLegs: function() {return \"This dog has \" + dog.numLegs + \" legs.\";}",
            "};",
            "",
            "dog.sayLegs();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dad367417b2b2512b77",
      "title": "Define a Constructor Function",
      "description": [
        "<code>构造函数</code> 用以创建一个新对象，并给这个新对象定义属性和行为。因此这是创建新对象的一个最基本的方式。",
        "以下就是一个 <code>构造函数</code> 的示例：",
        "<blockquote>function Bird() {<br>&nbsp;&nbsp;this.name = \"Albert\";<br>&nbsp;&nbsp;this.color = \"blue\";<br>&nbsp;&nbsp;this.numLegs = 2;<br>}</blockquote>",
        "这个 <code>构造函数</code> 定义了一个 <code>Bird</code> 对象，其属性 <code>name</code>、 <code>color</code> 和 <code>numLegs</code> 的值分别被设置为 ‘Albert’、‘blue’ 和 2。",
        "<code>构造函数</code> 遵循一些惯例规则：",
        "<ul><li><code>构造函数</code> 必须要以大写字母开头来定义，用来区别 <code>构造函数</code> 和其他非构造函数。</li><li><code>构造函数</code> 使用 <code>this</code> 关键字来给它将创建的这个对象设置新的属性。在 <code>构造函数</code> 里面，<code>this</code> 指向的就是它新创建的这个对象。</li><li><code>构造函数</code> 定义了属性和行为就可创建对象，而不是像其他函数一样需要通过返回值。</li></ul>",
        "<hr>",
        "创建一个 <code>构造函数</code>：<code>Dog</code>。给其添加 <code>name</code>, <code>color</code> 和 <code>numLegs</code> 属性并分别给它们设置为：字符串，字符串和数字。"
      ],
      "tests": [
        {
          "text": "<code>Dog</code> 应该有一个 <code>name</code> 属性被设置为一个字符串。",
          "testString": "assert(typeof (new Dog()).name === 'string', '<code>Dog</code> 应该有一个 <code>name</code> 属性被设置为一个字符串。');"
        },
        {
          "text": "<code>Dog</code> 应该有一个 <code>color</code> 属性被设置为一个字符串。",
          "testString": "assert(typeof (new Dog()).color === 'string', '<code>Dog</code> 应该有一个 <code>color</code> 属性被设置为一个字符串。');"
        },
        {
          "text": "<code>Dog</code> 应该有一个 <code>numLegs</code> 属性被设置为一个数字。",
          "testString": "assert(typeof (new Dog()).numLegs === 'number', '<code>Dog</code> 应该有一个 <code>numLegs</code> 属性被设置为一个数字。');"
        }
      ],
      "solutions": [
        "function Dog (name, color, numLegs) {\n  this.name = 'name';\n  this.color = 'color';\n  this.numLegs = 4;\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dad367417b2b2512b78",
      "title": "Use a Constructor to Create Objects",
      "description": [
        "以下是在前一个挑战中学习到并创建的一个 <code>Bird</code> 构造函数：",
        "<blockquote>function Bird() {<br>&nbsp;&nbsp;this.name = \"Albert\";<br>&nbsp;&nbsp;this.color  = \"blue\";<br>&nbsp;&nbsp;this.numLegs = 2;<br>&nbsp;&nbsp;// 构造函数里面的 \"this\" 总是指向新创建的实例。<br>}<br><br>let blueBird = new Bird();</blockquote>",
        "注意：通过构造函数创建对象的时候要使用 <code>new</code> 操作符。因为只有这样， Javascript 才知道要给 <code>Bird</code> 这个构造函数创建一个新的 <code>实例</code> 名字叫做 <code>blueBird</code>。如果不使用 <code>new</code> 操作符来新建对象，那么构造函数里面的 <code>this</code> 就无法指向新创建的这个对象实例，从而产生不可预见的错误。",
        "现在 <code>blueBird</code> 这个实例就继承了 <code>Bird</code> 这个构造函数的所有属性，如下：",
        "<blockquote>blueBird.name; // => Albert<br>blueBird.color; // => blue<br>blueBird.numLegs; // => 2</blockquote>",
        "由构造函数创建的实例也和其他对象一样，它的属性可以被访问和修改：",
        "<blockquote>blueBird.name = 'Elvira';<br>blueBird.name; // => Elvira</blockquote>",
        "<hr>",
        "使用上一个课时中的 <code>Dog</code> 构造函数创建一个 <code>Dog</code> 的新实例，分配给其一个变量名 <code>hound</code>。"
      ],
      "tests": [
        {
          "text": "<code>hound</code> 应该是通过 <code>Dog</code> 构造函数来创建的。",
          "testString": "assert(hound instanceof Dog, '<code>hound</code> 应该是通过 <code>Dog</code> 构造函数来创建的。');"
        },
        {
          "text": "你的代码中应该使用 <code>new</code> 操作符来创建 <code>Dog</code> 构造函数的新 <code>实例</code>。",
          "testString": "assert(code.match(/new/g), '你的代码中应该使用 <code>new</code> 操作符来创建 <code>Dog</code> 构造函数的新 <code>实例</code>。');"
        }
      ],
      "solutions": [
        "function Dog() {\n  this.name = \"Rupert\";\n  this.color = \"brown\";\n  this.numLegs = 4;\n}\nconst hound = new Dog();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog() {",
            "  this.name = \"Rupert\";",
            "  this.color = \"brown\";",
            "  this.numLegs = 4;",
            "}",
            "// 在下一行添加你的代码",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dae367417b2b2512b79",
      "title": "Extend Constructors to Receive Arguments",
      "description": [
        "上一个挑战中 <code>Bird</code> 和 <code>Dog</code> 构造函数运行得不错。但是，注意到没有：所有通过 <code>Bird</code> 构造函数创建出来的实例 <code>Birds</code> 都自动的取名为 ‘Albert’、颜色为蓝色、都是两条腿。如果你想要新创建出来的小鸟们拥有不同的名字和颜色要怎么办呢？当然，手动的去修改每一个小鸟实例自己的属性也是可以实现的，只是会增加很多没必要的工作量：",
        "<blockquote>let swan = new Bird();<br>swan.name = \"Carlos\";<br>swan.color = \"white\";</blockquote>",
        "假如你写了一个程序来追踪一个鸟舍里面的几百只甚至几千只不同的小鸟。这样将会花费很多很多的时间去创建所有的小鸟实例并给它们的属性一一修改为不同的值。",
        "为了减轻创建不同的 <code>Bird</code> 对象，你可以给你的 <code>Bird</code> 设置为可以接收参数的构造函数：",
        "<blockquote>function Bird(name, color) {<br>&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;this.color = color;<br>&nbsp;&nbsp;this.numLegs = 2;<br>}</blockquote>",
        "然后将值通过形参的方式传递给 <code>Bird</code> 构造函数来定义每一个唯一的小鸟实例：",
        "<code>let cardinal = new Bird(\"Bruce\", \"red\");</code>",
        "这给 <code>Bird</code> 的名字和颜色属性分别赋值为 ‘Bruce’ 和红色提供了另外一种方法。但 <code>numLegs</code> 属性被默认赋值为 2。",
        "<code>cardinal</code> 有以下这些属性：",
        "<blockquote>cardinal.name // => Bruce<br>cardinal.color // => red<br>cardinal.numLegs // => 2</blockquote>",
        "这样一来构造函数就变得很灵活了。现在可以直接定义每个 <code>Bird</code> 实例在创建时的属性，这是 JavaScript 构造函数非常有用的一种方式。它们根据共同或相似的属性和行为将对象归纳为一组，并能够自动的创建各自实例。",
        "<hr>",
        "创建另一个 <code>Dog</code> 构造函数。这一次，给它设置两个参数： <code>name</code> 和 <code>color</code>，同时设置 <code>numLegs</code> 的值默认为 4。然后创建一个新 <code>Dog</code> 实例保存为变量名： <code>terrier</code>，再将两个字符串通过参数的形式传入 <code>name</code> 和 <code>color</code> 属性。"
      ],
      "tests": [
        {
          "text": "<code>Dog</code> 应该接收一个 <code>name</code> 参数。",
          "testString": "assert((new Dog('Clifford')).name === 'Clifford', '<code>Dog</code> 应该接收一个 <code>name</code> 参数。');"
        },
        {
          "text": "<code>Dog</code> 应该接收一个 <code>color</code> 参数。",
          "testString": "assert((new Dog('Clifford', 'yellow')).color === 'yellow', '<code>Dog</code> 应该接收一个 <code>color</code> 参数。');"
        },
        {
          "text": "<code>Dog</code> 应该有一个 <code>numLegs</code> 属性被赋值为 4。",
          "testString": "assert((new Dog('Clifford')).numLegs === 4, '<code>Dog</code> 应该有一个 <code>numLegs</code> 属性被赋值为 4。');"
        },
        {
          "text": "<code>terrier</code> 应该是通过 <code>Dog</code> 构造函数创建的。",
          "testString": "assert(terrier instanceof Dog, '<code>terrier</code> 应该是通过 <code>Dog</code> 构造函数创建的。');"
        }
      ],
      "solutions": [
        "function Dog (name, color) {\n  this.numLegs = 4;\n  this.name = name;\n  this.color = color;\n}\n\nconst terrier = new Dog();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog() {",
            "  ",
            "}",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dae367417b2b2512b7a",
      "title": "Verify an Object's Constructor with instanceof",
      "description": [
        "不管何时通过构造函数创建新的新对象都是这个构造函数的一个 <code>实例</code>。 JavaScript 提供了一种很简便的方法来验证这个事实，那就是通过 <code>instanceof</code> 操作符。<code>instanceof</code> 允许你将对象与构造函数之间进行比较，根据对象是否由这个构造函数创建的返回相应的 <code>true</code> 或者 <code>false</code>。以下就是一个示例：",
        "<blockquote>let Bird = function(name, color) {<br>&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;this.color = color;<br>&nbsp;&nbsp;this.numLegs = 2;<br>}<br><br>let crow = new Bird(\"Alexis\", \"black\");<br><br>crow instanceof Bird; // => true</blockquote>",
        "如果一个对象不是使用构造函数创建的，那么 <code>instanceof</code> 将会证明这个对象不是构造函数的实例：",
        "<blockquote>let canary = {<br>&nbsp;&nbsp;name: \"Mildred\",<br>&nbsp;&nbsp;color: \"Yellow\",<br>&nbsp;&nbsp;numLegs: 2<br>};<br><br>canary instanceof Bird; // => false</blockquote>",
        "<hr>",
        "给 <code>House</code> 构造函数创建一个新实例，取名为 <code>myHouse</code> 并且传递一个数字给 <code>bedrooms<code> 参数。然后使用 <code>instanceof</code> 操作符证明这个对象是否是 <code>House</code> 的实例。"
      ],
      "tests": [
        {
          "text": "<code>myHouse</code> 应该有一个 <code>numBedrooms</code> 属性被赋值为一个数字。",
          "testString": "assert(typeof myHouse.numBedrooms === 'number', '<code>myHouse</code> 应该有一个 <code>numBedrooms</code> 属性被赋值为一个数字。');"
        },
        {
          "text": "一定要使用 <code>instanceof</code> 操作符证明 <code>myHouse</code> 这个对象是 <code>House</code> 构造函数的一个实例。",
          "testString": "assert(/myHouse\\s*instanceof\\s*House/.test(code), '一定要使用 <code>instanceof</code> 操作符证明 <code>myHouse</code> 这个对象是 <code>House</code> 构造函数的一个实例。');"
        }
      ],
      "solutions": [
        "function House(numBedrooms) {\n  this.numBedrooms = numBedrooms;\n}\nconst myHouse = new House(4);\nconsole.log(myHouse instanceof House);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "/* jshint expr: true */",
            "",
            "function House(numBedrooms) {",
            "  this.numBedrooms = numBedrooms;",
            "}",
            "",
            "// 在下一行添加你的代码",
            "",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dae367417b2b2512b7b",
      "title": "Understand Own Properties",
      "description": [
        "请看下面的举例，<code>Bird</code> 构造函数定义了两个属性：<code>name</code> 和 <code>numLegs</code>：",
        "<blockquote>function Bird(name) {<br>&nbsp;&nbsp;this.name  = name;<br>&nbsp;&nbsp;this.numLegs = 2;<br>}<br><br>let duck = new Bird(\"Donald\");<br>let canary = new Bird(\"Tweety\");</blockquote>",
        "<code>name</code> 和 <code>numLegs</code> 被叫做 <code>自身</code> 属性，因为他们是直接在实例对象上定义的。这就意味着 <code>duck</code> 和 <code>canary</code> 这两个对象都有属于自己的这些属性的单独副本。",
        "事实上，<code>Bird</code> 的这些实例都将拥有属于自己的这些属性的副本。",
        "以下的代码将 <code>duck</code> 里面所有的 <code>自身</code> 属性都存到一个叫 <code>ownProps</code> 的数组里面：",
        "<blockquote>let ownProps = [];<br><br>for (let property in duck) {<br>&nbsp;&nbsp;if(duck.hasOwnProperty(property)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;ownProps.push(property);<br>&nbsp;&nbsp;}<br>}<br><br>console.log(ownProps); // prints [ \"name\", \"numLegs\" ]</blockquote>",
        "<hr>",
        "将 <code>canary</code> 对象里面的 <code>自身</code> 属性添加到 <code>canary</code> 数组里面。"
      ],
      "tests": [
        {
          "text": "<code>ownProps</code> 应该包含了 <code>\"numLegs\"</code> 和 <code>\"name\"</code> 两个属性的值。",
          "testString": "assert(ownProps.indexOf('name') !== -1 && ownProps.indexOf('numLegs') !== -1, '<code>ownProps</code> 应该包含了 <code>\"numLegs\"</code> 和 <code>\"name\"</code> 两个属性的值。');"
        },
        {
          "text": "在不使用内置方法 <code>Object.keys()</code> 的情况下解决这个挑战。",
          "testString": "assert(!/\\Object.keys/.test(code), '在不使用内置方法 <code>Object.keys()</code> 的情况下解决这个挑战。');"
        }
      ],
      "solutions": [
        "function Bird(name) {\n  this.name = name;\n  this.numLegs = 2;\n}\n\nlet canary = new Bird(\"Tweety\");\nfunction getOwnProps (obj) {\n  const props = [];\n  \n  for (let prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      props.push(prop);\n    }\n  }\n  \n  return props;\n}\n\nconst ownProps = getOwnProps(canary);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Bird(name) {",
            "  this.name = name;",
            "  this.numLegs = 2;",
            "}",
            "",
            "let canary = new Bird(\"Tweety\");",
            "let ownProps = [];",
            "// 在下一行添加你的代码",
            "",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dae367417b2b2512b7c",
      "title": "Use Prototype Properties to Reduce Duplicate Code",
      "description": [
        "由于 <code>numLegs</code> 属性可能对 <code>Bird</code> 的所有实例都具有相同的值，所以在每一个 <code>Bird</code> 的实例中本质上都有一个重复的变量 <code>numLegs</code>。",
        "当只有两个实例时可能并不是什么问题，但想象一下如果有数百万个实例，这将会产生许许多多重复的变量。",
        "这里有一个更好的方法可以解决上述问题，那就是使用 <code>Bird’s</code> <code>原型</code>。<code>原型</code> 是一个可以在所有 <code>Bird</code> 实例之间共享的对象。以下是一个如何在 <code>Bird prototype</code> 中添加 <code>numLegs</code> 属性的：",
        "<blockquote>Bird.prototype.numLegs = 2;</blockquote>",
        "现在所有的 <code>Bird</code> 实例都拥有了共同的 <code>numLegs</code> 属性。",
        "<blockquote>console.log(duck.numLegs);  // 在控制台输出 2<br>console.log(canary.numLegs);  // 在控制台输出 2</blockquote>",
        "由于所有的实例都可以在 <code>原型</code> 上自动的拥有属性，所以可以把 <code>原型</code> 看作是创建对象的 \"recipe\"。",
        "请注意： <code>duck</code> 和 <code>canary</code> 的 <code>原型</code> 是<code>Bird</code> 构造函数原型 <code>Bird.prototype</code> 的一部分。JavaScript 中几乎所有的对象都有一个 <code>原型</code> 属性，它是创建它的构造函数的一部分。",
        "<hr>",
        "给 <code>Dog</code> 的 <code>原型</code> 添加一个 <code>numLegs</code> 属性。"
      ],
      "tests": [
        {
          "text": "<code>beagle</code> 应该有一个 <code>numLegs</code> 属性。",
          "testString": "assert(beagle.numLegs !== undefined, '<code>beagle</code> 应该有一个 <code>numLegs</code> 属性。');"
        },
        {
          "text": "<code>beagle.numLegs</code> 应该是一个数字。",
          "testString": "assert(typeof(beagle.numLegs) === 'number' , '<code>beagle.numLegs</code> 应该是一个数字。');"
        },
        {
          "text": "<code>numLegs</code> 应该是一个 <code>原型</code> 属性而不是一个 <code>自身</code> 属性。",
          "testString": "assert(beagle.hasOwnProperty('numLegs') === false, '<code>numLegs</code> should be a <code>prototype</code> 应该是一个 <code>原型</code> 属性而不是一个 <code>自身</code> 属性。');"
        }
      ],
      "solutions": [
        "function Dog (name) {\n  this.name = name;\n}\nDog.prototype.numLegs = 4;\nlet beagle = new Dog(\"Snoopy\");"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "",
            "",
            "// 在下一行添加你的代码",
            "let beagle = new Dog(\"Snoopy\");"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7daf367417b2b2512b7d",
      "title": "Iterate Over All Properties",
      "description": [
        "现在你已经了解了两种属性: <code>自身</code> 属性和 <code>原型</code> 属性。 <code>自身</code> 属性是直接在对象实例它自己内部定义的。而 <code>原型</code> 属性是定义在 <code>prototype</code> 上的：",
        "<blockquote>function Bird(name) {<br>&nbsp;&nbsp;this.name = name;  // 自身属性 <br>}<br><br>Bird.prototype.numLegs = 2; // 原型属性 <br><br>let duck = new Bird(\"Donald\");</blockquote>",
        "这是一个告诉你如何将 <code>duck’s</code> <code>自身</code> 属性和 <code>原型</code> 属性分别添加到 <code>ownProps</code> 数组和 <code>prototypeProps</code> 数组里面：",
        "<blockquote>let ownProps = [];<br>let prototypeProps = [];<br><br>for (let property in duck) {<br>&nbsp;&nbsp;if(duck.hasOwnProperty(property)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;ownProps.push(property);<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;prototypeProps.push(property);<br>&nbsp;&nbsp;}<br>}<br><br>console.log(ownProps); // 输出 [\"name\"]<br>console.log(prototypeProps); // 输出 [\"numLegs\"]</blockquote>",
        "<hr>",
        "将 <code>beagle</code> 的所有属性都添加到 code>ownProps</code> 数组里面去。将 <code>Dog</code> 的所有 <code>原型</code> 属性添加到 <code>prototypeProps</code> 数组中。"
      ],
      "tests": [
        {
          "text": "这个 <code>ownProps</code> 数组应该包含了 <code>\"name\"</code> 这个值。",
          "testString": "assert(ownProps.indexOf('name') !== -1, '这个 <code>ownProps</code> 属性应该包含了 <code>\"name\"</code> 这个值。');"
        },
        {
          "text": "这个 <code>prototypeProps</code> 数组应该包含了 <code>\"numLegs\"</code> 这个值。",
          "testString": "assert(prototypeProps.indexOf('numLegs') !== -1, '这个 <code>prototypeProps</code> 数组应该包含了 <code>\"numLegs\"</code> 这个值。');"
        },
        {
          "text": "在不使用内置方法 <code>Object.keys()</code> 的情况下解决这个挑战。",
          "testString": "assert(!/\\Object.keys/.test(code), '在不使用内置方法 <code>Object.keys()</code> 的情况下解决这个挑战。');"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name;\n}\n\nDog.prototype.numLegs = 4;\n\nlet beagle = new Dog(\"Snoopy\");\n\nlet ownProps = [];\nlet prototypeProps = [];\nfor (let prop in beagle) {\n  if (beagle.hasOwnProperty(prop)) {\n    ownProps.push(prop);\n  } else {\n    prototypeProps.push(prop);\n  }\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "Dog.prototype.numLegs = 4;",
            "",
            "let beagle = new Dog(\"Snoopy\");",
            "",
            "let ownProps = [];",
            "let prototypeProps = [];",
            "",
            "// 在下一行添加你的代码 ",
            "",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7daf367417b2b2512b7e",
      "title": "Understand the Constructor Property",
      "description": [
        "在上一个挑战中创建的实例对象 <code>duck</code> 和 <code>beagle</code> 都有一个特殊的  <code>constructor</code> 属性：",
        "<blockquote>let duck = new Bird();<br>let beagle = new Dog();<br><br>console.log(duck.constructor === Bird);  //输出 true<br>console.log(beagle.constructor === Dog);  //输出 true</blockquote>",
        "需要注意到的是这个 <code>constructor</code> 属性是对创建这个实例的构造函数的一个引用。",
        "<code>constructor</code> 属性的一个优势就是通过检查这个属性来找出它是一个什么样的对象。下面是一个例子，来看看是怎么使用的：",
        "<blockquote>function joinBirdFraternity(candidate) {<br>&nbsp;&nbsp;if (candidate.constructor === Bird) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;}<br>}</blockquote>",
        "<strong>注意：</strong><br>由于 <code>constructor</code> 属性可以被重写（在下面两节挑战中将会遇到） 所以通常使用 <code>instanceof</code> 方法来检查对象的类型要更好。",
        "<hr>",
        "写一个 <code>joinDogFraternity</code> 函数，传入一个 <code>candidate</code> 参数并使用 <code>constructor</code> 属性来判断传入的 candidate 是不是 <code>Dog</code> 创建的对象实例，如果是返回 <code>true</code> 否则返回 <code>false</code>。"
      ],
      "tests": [
        {
          "text": "<code>joinDogFraternity</code> 应该被定义为一个函数。",
          "testString": "assert(typeof(joinDogFraternity) === 'function', '<code>joinDogFraternity</code> 应该被定义为一个函数。');"
        },
        {
          "text": "如果 <code>candidate</code> 是 <code>Dog</code> 的一个对象实例，则 <code>joinDogFraternity</code> 函数应该返回 <code>true</code>。",
          "testString": "assert(joinDogFraternity(new Dog(\"\")) === true, '如果 <code>candidate</code> 是 <code>Dog</code> 的一个对象实例，则 <code>joinDogFraternity</code> 函数应该返回 <code>true</code>。');"
        },
        {
          "text": "<code>joinDogFraternity</code> 应该要使用 <code>constructor</code> 属性。",
          "testString": "assert(/\\.constructor/.test(code) && !/instanceof/.test(code), '<code>joinDogFraternity</code> 应该要使用 <code>constructor</code> 属性。');"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name;\n}\nfunction joinDogFraternity(candidate) {\n  return candidate.constructor === Dog;\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "// 在下一行添加你的代码",
            "function joinDogFraternity(candidate) {",
            "  ",
            "}",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7daf367417b2b2512b7f",
      "title": "Change the Prototype to a New Object",
      "description": [
        "到目前为止，你已经可以单独给 <code>prototype</code> 添加属性了：",
        "<blockquote>Bird.prototype.numLegs = 2;</blockquote>",
        "这将在添加许多属性的时候变得单调乏味的。",
        "<blockquote>Bird.prototype.eat = function() {<br>&nbsp;&nbsp;console.log(\"nom nom nom\");<br>}<br><br>Bird.prototype.describe = function() {<br>&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>}</blockquote>",
        "一种更有效的方法就是给对象的 <code>prototype</code> 设置为一个已经包含了属性的新对象。这样一来，所有属性都可以一次性被添加进来：",
        "<blockquote>Bird.prototype = {<br>&nbsp;&nbsp;numLegs: 2, <br>&nbsp;&nbsp;eat: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"nom nom nom\");<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "<hr>",
        "通过给 <code>prototype</code> 设置为新对象的方法，给 <code>Dog</code> 构造函数的 <code>原型</code> 上添加一个属性 <code>numLegs</code> 和两个方法 <code>eat()</code> 、<code>describe()</code>。"
      ],
      "tests": [
        {
          "text": "<code>Dog.prototype</code> 应该被设置为一个新对象。",
          "testString": "assert((/Dog\\.prototype\\s*?=\\s*?{/).test(code), '<code>Dog.prototype</code> 应该被设置为一个新对象。');"
        },
        {
          "text": "<code>Dog.prototype</code> 应该拥有属性 <code>numLegs</code>。",
          "testString": "assert(Dog.prototype.numLegs !== undefined, '<code>Dog.prototype</code> 应该拥有属性 <code>numLegs</code>。');"
        },
        {
          "text": "<code>Dog.prototype</code> 应该拥有方法 <code>eat()</code>。",
          "testString": "assert(typeof Dog.prototype.eat === 'function', '<code>Dog.prototype</code> 应该拥有方法 <code>eat()</code>。'); "
        },
        {
          "text": "<code>Dog.prototype</code> 应该拥有方法 <code>describe()</code>。",
          "testString": "assert(typeof Dog.prototype.describe === 'function', '<code>Dog.prototype</code> 应该拥有方法 <code>describe()</code>。'); "
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name; \n}\nDog.prototype = {\nnumLegs: 4,\n  eat () {\n    console.log('nom nom nom');\n  },\n  describe () {\n    console.log('My name is ' + this.name);\n  }\n};"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name; ",
            "}",
            "",
            "Dog.prototype = {",
            "  // 在下一行添加你的代码",
            "  ",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7daf367417b2b2512b80",
      "title": "Remember to Set the Constructor Property when Changing the Prototype",
      "description": [
        "There is one crucial side effect of manually setting the <code>prototype</code> to a new object. It erased the <code>constructor</code> property! The code in the previous challenge would print the following for <code>duck</code>:",
        "<blockquote>console.log(duck.constructor)<br>// prints ‘undefined’ - Oops!</blockquote>",
        "To fix this, whenever a prototype is manually set to a new object, remember to define the <code>constructor</code> property:",
        "<blockquote>Bird.prototype = {<br>&nbsp;&nbsp;constructor: Bird, // define the constructor property<br>&nbsp;&nbsp;numLegs: 2,<br>&nbsp;&nbsp;eat: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"nom nom nom\");<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name); <br>&nbsp;&nbsp;}<br>};</blockquote>",
        "<hr>",
        "Define the <code>constructor</code> property on the <code>Dog</code> <code>prototype</code>."
      ],
      "tests": [
        {
          "text": "<code>Dog.prototype</code> should set the <code>constructor</code> property.",
          "testString": "assert(Dog.prototype.constructor === Dog, '<code>Dog.prototype</code> should set the <code>constructor</code> property.');"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name; \n}\nDog.prototype = {\n  constructor: Dog,\n  numLegs: 2, \n  eat: function() {\n    console.log(\"nom nom nom\"); \n  }, \n  describe: function() {\n    console.log(\"My name is \" + this.name); \n  }\n};"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name; ",
            "}",
            "",
            "// Modify the code below this line",
            "Dog.prototype = {",
            "  ",
            "  numLegs: 2, ",
            "  eat: function() {",
            "    console.log(\"nom nom nom\"); ",
            "  }, ",
            "  describe: function() {",
            "    console.log(\"My name is \" + this.name); ",
            "  }",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db0367417b2b2512b81",
      "title": "Understand Where an Object’s Prototype Comes From",
      "description": [
        "Just like people inherit genes from their parents, an object inherits its <code>prototype</code> directly from the constructor function that created it. For example, here the <code>Bird</code> constructor creates the <code>duck</code> object:",
        "<blockquote>function Bird(name) {<br>&nbsp;&nbsp;this.name = name;<br>}<br><br>let duck = new Bird(\"Donald\");</blockquote>",
        "<code>duck</code> inherits its <code>prototype</code> from the <code>Bird</code> constructor function. You can show this relationship with the <code>isPrototypeOf</code> method:",
        "<blockquote>Bird.prototype.isPrototypeOf(duck);<br>// returns true</blockquote>",
        "<hr>",
        "Use <code>isPrototypeOf</code> to check the <code>prototype</code> of <code>beagle</code>."
      ],
      "tests": [
        {
          "text": "Show that <code>Dog.prototype</code> is the <code>prototype</code> of <code>beagle</code>",
          "testString": "assert(/Dog\\.prototype\\.isPrototypeOf\\(beagle\\)/.test(code), 'Show that <code>Dog.prototype</code> is the <code>prototype</code> of <code>beagle</code>');"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name;\n}\nlet beagle = new Dog(\"Snoopy\");\nDog.prototype.isPrototypeOf(beagle);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "let beagle = new Dog(\"Snoopy\");",
            "",
            "// Add your code below this line",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db0367417b2b2512b82",
      "title": "Understand the Prototype Chain",
      "description": [
        "All objects in JavaScript (with a few exceptions) have a <code>prototype</code>. Also, an object’s <code>prototype</code> itself is an object.",
        "<blockquote>function Bird(name) {<br>&nbsp;&nbsp;this.name = name;<br>}<br><br>typeof Bird.prototype; // => object</blockquote>",
        "Because a <code>prototype</code> is an object, a <code>prototype</code> can have its own <code>prototype</code>! In this case, the <code>prototype</code> of <code>Bird.prototype</code> is <code>Object.prototype</code>:",
        "<blockquote>Object.prototype.isPrototypeOf(Bird.prototype);<br>// returns true</blockquote>",
        "How is this useful? You may recall the <code>hasOwnProperty</code> method from a previous challenge:",
        "<blockquote>let duck = new Bird(\"Donald\");<br>duck.hasOwnProperty(\"name\"); // => true</blockquote>",
        "The <code>hasOwnProperty</code> method is defined in <code>Object.prototype</code>, which can be accessed by <code>Bird.prototype</code>, which can then be accessed by <code>duck</code>. This is an example of the <code>prototype</code> chain.",
        "In this <code>prototype</code> chain, <code>Bird</code> is the <code>supertype</code> for <code>duck</code>, while <code>duck</code> is the <code>subtype</code>. <code>Object</code> is a <code>supertype</code> for both <code>Bird</code> and <code>duck</code>.",
        "<code>Object</code> is a <code>supertype</code> for all objects in JavaScript. Therefore, any object can use the <code>hasOwnProperty</code> method.",
        "<hr>",
        "Modify the code to show the correct prototype chain."
      ],
      "tests": [
        {
          "text": "Your code should show that <code>Object.prototype</code> is the prototype of <code>Dog.prototype</code>\")",
          "testString": "assert(/Object\\.prototype\\.isPrototypeOf/.test(code), \"Your code should show that <code>Object.prototype</code> is the prototype of <code>Dog.prototype</code>\");"
        }
      ],
      "solutions": [
        "function Dog(name) {\n  this.name = name;\n}\nlet beagle = new Dog(\"Snoopy\");\nDog.prototype.isPrototypeOf(beagle);\nObject.prototype.isPrototypeOf(Dog.prototype);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Dog(name) {",
            "  this.name = name;",
            "}",
            "",
            "let beagle = new Dog(\"Snoopy\");",
            "",
            "Dog.prototype.isPrototypeOf(beagle);  // => true",
            "",
            "// Fix the code below so that it evaluates to true",
            "???.isPrototypeOf(Dog.prototype);",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db0367417b2b2512b83",
      "title": "Use Inheritance So You Don't Repeat Yourself",
      "description": [
        "There's a principle in programming called <code>Don't Repeat Yourself (DRY)</code>. The reason repeated code is a problem is because any change requires fixing code in multiple places. This usually means more work for programmers and more room for errors.",
        "Notice in the example below that the <code>describe</code> method is shared by <code>Bird</code> and <code>Dog</code>:",
        "<blockquote>Bird.prototype = {<br>&nbsp;&nbsp;constructor: Bird,<br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>&nbsp;&nbsp;}<br>};<br><br>Dog.prototype = {<br>&nbsp;&nbsp;constructor: Dog,<br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "The <code>describe</code> method is repeated in two places. The code can be edited to follow the <code>DRY</code> principle by creating a <code>supertype</code> (or parent) called <code>Animal</code>:",
        "<blockquote>function Animal() { };<br><br>Animal.prototype = {<br>&nbsp;&nbsp;constructor: Animal, <br>&nbsp;&nbsp;describe: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"My name is \" + this.name);<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "Since <code>Animal</code> includes the <code>describe</code> method, you can remove it from <code>Bird</code> and <code>Dog</code>:",
        "<blockquote>Bird.prototype = {<br>&nbsp;&nbsp;constructor: Bird<br>};<br><br>Dog.prototype = {<br>&nbsp;&nbsp;constructor: Dog<br>};</blockquote>",
        "<hr>",
        "The <code>eat</code> method is repeated in both <code>Cat</code> and <code>Bear</code>. Edit the code in the spirit of <code>DRY</code> by moving the <code>eat</code> method to the <code>Animal</code> <code>supertype</code>."
      ],
      "tests": [
        {
          "text": "<code>Animal.prototype</code> should have the <code>eat</code> property.",
          "testString": "assert(Animal.prototype.hasOwnProperty('eat'), '<code>Animal.prototype</code> should have the <code>eat</code> property.');"
        },
        {
          "text": "<code>Bear.prototype</code> should not have the <code>eat</code> property.",
          "testString": "assert(!(Bear.prototype.hasOwnProperty('eat')), '<code>Bear.prototype</code> should not have the <code>eat</code> property.');"
        },
        {
          "text": "<code>Cat.prototype</code> should not have the <code>eat</code> property.",
          "testString": "assert(!(Cat.prototype.hasOwnProperty('eat')), '<code>Cat.prototype</code> should not have the <code>eat</code> property.');"
        }
      ],
      "solutions": [
        "function Cat(name) {\n  this.name = name; \n}\n\nCat.prototype = {\n  constructor: Cat\n};\n\nfunction Bear(name) {\n  this.name = name; \n}\n\nBear.prototype = {\n  constructor: Bear\n};\n\nfunction Animal() { }\n\nAnimal.prototype = {\n  constructor: Animal,\n  eat: function() {\n    console.log(\"nom nom nom\");\n  }\n};"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Cat(name) {",
            "  this.name = name; ",
            "}",
            "",
            "Cat.prototype = {",
            "  constructor: Cat, ",
            "  eat: function() {",
            "    console.log(\"nom nom nom\");",
            "  }",
            "};",
            "",
            "function Bear(name) {",
            "  this.name = name; ",
            "}",
            "",
            "Bear.prototype = {",
            "  constructor: Bear, ",
            "  eat: function() {",
            "    console.log(\"nom nom nom\");",
            "  }",
            "};",
            "",
            "function Animal() { }",
            "",
            "Animal.prototype = {",
            "  constructor: Animal,",
            "  ",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db0367417b2b2512b84",
      "title": "Inherit Behaviors from a Supertype",
      "description": [
        "In the previous challenge, you created a <code>supertype</code> called <code>Animal</code> that defined behaviors shared by all animals:",
        "<blockquote>function Animal() { }<br>Animal.prototype.eat = function() {<br>&nbsp;&nbsp;console.log(\"nom nom nom\");<br>};</blockquote>",
        "This and the next challenge will cover how to reuse <code>Animal's</code> methods inside <code>Bird</code> and <code>Dog</code> without defining them again. It uses a technique called <code>inheritance</code>.",
        "This challenge covers the first step: make an instance of the <code>supertype</code> (or parent).",
        "You already know one way to create an instance of <code>Animal</code> using the <code>new</code> operator:",
        "<blockquote>let animal = new Animal();</blockquote>",
        "There are some disadvantages when using this syntax for <code>inheritance</code>, which are too complex for the scope of this challenge. Instead, here's an alternative approach without those disadvantages:",
        "<blockquote>let animal = Object.create(Animal.prototype);</blockquote>",
        "<code>Object.create(obj)</code> creates a new object, and sets <code>obj</code> as the new object's <code>prototype</code>. Recall that the <code>prototype</code> is like the \"recipe\" for creating an object. By setting the <code>prototype</code> of <code>animal</code> to be <code>Animal's</code> <code>prototype</code>, you are effectively giving the <code>animal</code> instance the same \"recipe\" as any other instance of <code>Animal</code>.",
        "<blockquote>animal.eat(); // prints \"nom nom nom\"<br>animal instanceof Animal; // => true</blockquote>",
        "<hr>",
        "Use <code>Object.create</code> to make two instances of <code>Animal</code> named <code>duck</code> and <code>beagle</code>."
      ],
      "tests": [
        {
          "text": "The <code>duck</code> variable should be defined.",
          "testString": "assert(typeof duck !== \"undefined\", 'The <code>duck</code> variable should be defined.');"
        },
        {
          "text": "The <code>beagle</code> variable should be defined.",
          "testString": "assert(typeof beagle !== \"undefined\", 'The <code>beagle</code> variable should be defined.');"
        },
        {
          "text": "<code>duck</code> should have a <code>prototype</code> of <code>Animal</code>.",
          "testString": "assert(duck instanceof Animal, '<code>duck</code> should have a <code>prototype</code> of <code>Animal</code>.');"
        },
        {
          "text": "<code>beagle</code> should have a <code>prototype</code> of <code>Animal</code>.",
          "testString": "assert(beagle instanceof Animal, '<code>beagle</code> should have a <code>prototype</code> of <code>Animal</code>.');"
        }
      ],
      "solutions": [
        "function Animal() { }\n\nAnimal.prototype = {\n  constructor: Animal, \n  eat: function() {\n    console.log(\"nom nom nom\");\n  }\n};\nlet duck = Object.create(Animal.prototype);\nlet beagle = Object.create(Animal.prototype);\n\nduck.eat();\nbeagle.eat();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Animal() { }",
            "",
            "Animal.prototype = {",
            "  constructor: Animal, ",
            "  eat: function() {",
            "    console.log(\"nom nom nom\");",
            "  }",
            "};",
            "",
            "// Add your code below this line",
            "",
            "let duck; // Change this line",
            "let beagle; // Change this line",
            "",
            "duck.eat(); // Should print \"nom nom nom\"",
            "beagle.eat(); // Should print \"nom nom nom\" "
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db1367417b2b2512b85",
      "title": "Set the Child's Prototype to an Instance of the Parent",
      "description": [
        "In the previous challenge you saw the first step for inheriting behavior from the <code>supertype</code> (or parent) <code>Animal</code>: making a new instance of <code>Animal</code>.",
        "This challenge covers the next step: set the <code>prototype</code> of the <code>subtype</code> (or child)&mdash;in this case, <code>Bird</code>&mdash;to be an instance of <code>Animal</code>.",
        "<blockquote>Bird.prototype = Object.create(Animal.prototype);</blockquote>",
        "Remember that the <code>prototype</code> is like the \"recipe\" for creating an object. In a way, the recipe for <code>Bird</code> now includes all the key \"ingredients\" from <code>Animal</code>.",
        "<blockquote>let duck = new Bird(\"Donald\");<br>duck.eat(); // prints \"nom nom nom\"</blockquote>",
        "<code>duck</code> inherits all of <code>Animal</code>'s properties, including the <code>eat</code> method.",
        "<hr>",
        "Modify the code so that instances of <code>Dog</code> inherit from <code>Animal</code>."
      ],
      "tests": [
        {
          "text": "<code>Dog.prototype</code> should be an instance of <code>Animal</code>.",
          "testString": "assert(Animal.prototype.isPrototypeOf(Dog.prototype), '<code>Dog.prototype</code> should be an instance of <code>Animal</code>.');"
        }
      ],
      "solutions": [
        "function Animal() { }\n\nAnimal.prototype = {\n  constructor: Animal,\n  eat: function() {\n    console.log(\"nom nom nom\");\n  }\n};\n\nfunction Dog() { }\nDog.prototype = Object.create(Animal.prototype);\n\nlet beagle = new Dog();\nbeagle.eat();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Animal() { }",
            "",
            "Animal.prototype = {",
            "  constructor: Animal,",
            "  eat: function() {",
            "    console.log(\"nom nom nom\");",
            "  }",
            "};",
            "",
            "function Dog() { }",
            "",
            "// Add your code below this line",
            "",
            "",
            "let beagle = new Dog();",
            "beagle.eat();  // Should print \"nom nom nom\""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db1367417b2b2512b86",
      "title": "Reset an Inherited Constructor Property",
      "description": [
        "When an object inherits its <code>prototype</code> from another object, it also inherits the <code>supertype</code>'s constructor property.",
        "Here's an example:",
        "<blockquote>function Bird() { }<br>Bird.prototype = Object.create(Animal.prototype);<br>let duck = new Bird();<br>duck.constructor // function Animal(){...}</blockquote>",
        "But <code>duck</code> and all instances of <code>Bird</code> should show that they were constructed by <code>Bird</code> and not <code>Animal</code>. To do so, you can manually set <code>Bird's</code> constructor property to the <code>Bird</code> object:",
        "<blockquote>Bird.prototype.constructor = Bird;<br>duck.constructor // function Bird(){...}</blockquote>",
        "<hr>",
        "Fix the code so <code>duck.constructor</code> and <code>beagle.constructor</code> return their respective constructors."
      ],
      "tests": [
        {
          "text": "<code>Bird.prototype</code> should be an instance of <code>Animal</code>.",
          "testString": "assert(Animal.prototype.isPrototypeOf(Bird.prototype), '<code>Bird.prototype</code> should be an instance of <code>Animal</code>.');"
        },
        {
          "text": "<code>duck.constructor</code> should return <code>Bird</code>.",
          "testString": "assert(duck.constructor === Bird, '<code>duck.constructor</code> should return <code>Bird</code>.');"
        },
        {
          "text": "<code>Dog.prototype</code> should be an instance of <code>Animal</code>.",
          "testString": "assert(Animal.prototype.isPrototypeOf(Dog.prototype), '<code>Dog.prototype</code> should be an instance of <code>Animal</code>.');"
        },
        {
          "text": "<code>beagle.constructor</code> should return <code>Dog</code>.",
          "testString": "assert(beagle.constructor === Dog, '<code>beagle.constructor</code> should return <code>Dog</code>.');"
        }
      ],
      "solutions": [
        "function Animal() { }\nfunction Bird() { }\nfunction Dog() { }\nBird.prototype = Object.create(Animal.prototype);\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\nBird.prototype.constructor = Bird;\nlet duck = new Bird();\nlet beagle = new Dog();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Animal() { }",
            "function Bird() { }",
            "function Dog() { }",
            "",
            "Bird.prototype = Object.create(Animal.prototype);",
            "Dog.prototype = Object.create(Animal.prototype);",
            "",
            "// Add your code below this line",
            "",
            "",
            "",
            "let duck = new Bird();",
            "let beagle = new Dog();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db1367417b2b2512b87",
      "title": "Add Methods After Inheritance",
      "description": [
        "A constructor function that inherits its <code>prototype</code> object from a <code>supertype</code> constructor function can still have its own methods in addition to inherited methods.",
        "For example, <code>Bird</code> is a constructor that inherits its <code>prototype</code> from <code>Animal</code>:",
        "<blockquote>function Animal() { }<br>Animal.prototype.eat = function() {<br>&nbsp;&nbsp;console.log(\"nom nom nom\");<br>};<br>function Bird() { }<br>Bird.prototype = Object.create(Animal.prototype);<br>Bird.prototype.constructor = Bird;</blockquote>",
        "In addition to what is inherited from <code>Animal</code>, you want to add behavior that is unique to <code>Bird</code> objects. Here, <code>Bird</code> will get a <code>fly()</code> function. Functions are added to <code>Bird's</code> <code>prototype</code> the same way as any constructor function:",
        "<blockquote>Bird.prototype.fly = function() {<br>&nbsp;&nbsp;console.log(\"I'm flying!\");<br>};</blockquote>",
        "Now instances of <code>Bird</code> will have both <code>eat()</code> and <code>fly()</code> methods:",
        "<blockquote>let duck = new Bird();<br>duck.eat(); // prints \"nom nom nom\"<br>duck.fly(); // prints \"I'm flying!\"</blockquote>",
        "<hr>",
        "Add all necessary code so the <code>Dog</code> object inherits from <code>Animal</code> and the <code>Dog's</code> <code>prototype</code> constructor is set to Dog. Then add a <code>bark()</code> method to the <code>Dog</code> object so that <code>beagle</code> can both <code>eat()</code> and <code>bark()</code>. The <code>bark()</code> method should print \"Woof!\" to the console."
      ],
      "tests": [
        {
          "text": "<code>Animal</code> should not respond to the <code>bark()</code> method.",
          "testString": "assert(typeof Animal.prototype.bark == \"undefined\", '<code>Animal</code> should not respond to the <code>bark()</code> method.');"
        },
        {
          "text": "<code>Dog</code> should inherit the <code>eat()</code> method from <code>Animal</code>.",
          "testString": "assert(typeof Dog.prototype.eat == \"function\", '<code>Dog</code> should inherit the <code>eat()</code> method from <code>Animal</code>.');"
        },
        {
          "text": "<code>Dog</code> should have the <code>bark()</code> method as an <code>own</code> property.",
          "testString": "assert(Dog.prototype.hasOwnProperty('bark'), '<code>Dog</code> should have the <code>bark()</code> method as an <code>own</code> property.');"
        },
        {
          "text": "<code>beagle</code> should be an <code>instanceof</code> <code>Animal</code>.",
          "testString": "assert(beagle instanceof Animal, '<code>beagle</code> should be an <code>instanceof</code> <code>Animal</code>.');"
        },
        {
          "text": "The constructor for <code>beagle</code> should be set to <code>Dog</code>.",
          "testString": "assert(beagle.constructor === Dog, 'The constructor for <code>beagle</code> should be set to <code>Dog</code>.');"
        }
      ],
      "solutions": [
        "function Animal() { }\nAnimal.prototype.eat = function() { console.log(\"nom nom nom\"); };\n\nfunction Dog() { }\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\nDog.prototype.bark = function () {\n  console.log('Woof!');\n};\nlet beagle = new Dog();\n\nbeagle.eat();\nbeagle.bark();"
      ],
      "hints": [
        "Objects inherit methods from other objects by cloning their prototype. The Object.create method will come in handy, and don't forget to reset the constructor property afterward!"
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Animal() { }",
            "Animal.prototype.eat = function() { console.log(\"nom nom nom\"); };",
            "",
            "function Dog() { }",
            "",
            "// Add your code below this line",
            "",
            "",
            "",
            "",
            "// Add your code above this line",
            "",
            "let beagle = new Dog();",
            "",
            "beagle.eat(); // Should print \"nom nom nom\"",
            "beagle.bark(); // Should print \"Woof!\""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db1367417b2b2512b88",
      "title": "Override Inherited Methods",
      "description": [
        "In previous lessons, you learned that an object can inherit its behavior (methods) from another object by cloning its <code>prototype</code> object:",
        "<blockquote>ChildObject.prototype = Object.create(ParentObject.prototype);</blockquote>",
        "Then the <code>ChildObject</code> received its own methods by chaining them onto its <code>prototype</code>:",
        "<blockquote>ChildObject.prototype.methodName = function() {...};</blockquote>",
        "It's possible to override an inherited method. It's done the same way - by adding a method to <code>ChildObject.prototype</code> using the same method name as the one to override.",
        "Here's an example of <code>Bird</code> overriding the <code>eat()</code> method inherited from <code>Animal</code>:",
        "<blockquote>function Animal() { }<br>Animal.prototype.eat = function() {<br>&nbsp;&nbsp;return \"nom nom nom\";<br>};<br>function Bird() { }<br><br>// Inherit all methods from Animal<br>Bird.prototype = Object.create(Animal.prototype);<br><br>// Bird.eat() overrides Animal.eat()<br>Bird.prototype.eat = function() {<br>&nbsp;&nbsp;return \"peck peck peck\";<br>};</blockquote>",
        "If you have an instance <code>let duck = new Bird();</code> and you call <code>duck.eat()</code>, this is how JavaScript looks for the method on <code>duck’s</code> <code>prototype</code> chain:",
        "1. duck => Is eat() defined here? No.",
        "2. Bird => Is eat() defined here? => Yes. Execute it and stop searching.",
        "3. Animal => eat() is also defined, but JavaScript stopped searching before reaching this level.",
        "4. Object => JavaScript stopped searching before reaching this level.",
        "<hr>",
        "Override the <code>fly()</code> method for <code>Penguin</code> so that it returns \"Alas, this is a flightless bird.\""
      ],
      "tests": [
        {
          "text": "<code>penguin.fly()</code> should return the string \"Alas, this is a flightless bird.\"",
          "testString": "assert(penguin.fly() === \"Alas, this is a flightless bird.\", '<code>penguin.fly()</code> should return the string \"Alas, this is a flightless bird.\"');"
        },
        {
          "text": "The <code>bird.fly()</code> method should return \"I am flying!\"",
          "testString": "assert((new Bird()).fly() === \"I am flying!\", 'The <code>bird.fly()</code> method should return \"I am flying!\"');"
        }
      ],
      "solutions": [
        "function Bird() { }\n\nBird.prototype.fly = function() { return \"I am flying!\"; };\n\nfunction Penguin() { }\nPenguin.prototype = Object.create(Bird.prototype);\nPenguin.prototype.constructor = Penguin;\nPenguin.prototype.fly = () => 'Alas, this is a flightless bird.';\nlet penguin = new Penguin();\nconsole.log(penguin.fly());"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Bird() { }",
            "",
            "Bird.prototype.fly = function() { return \"I am flying!\"; };",
            "",
            "function Penguin() { }",
            "Penguin.prototype = Object.create(Bird.prototype);",
            "Penguin.prototype.constructor = Penguin;",
            "",
            "// Add your code below this line",
            "",
            "",
            "",
            "// Add your code above this line",
            "",
            "let penguin = new Penguin();",
            "console.log(penguin.fly());"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db2367417b2b2512b89",
      "title": "Use a Mixin to Add Common Behavior Between Unrelated Objects",
      "description": [
        "As you have seen, behavior is shared through inheritance. However, there are cases when inheritance is not the best solution. Inheritance does not work well for unrelated objects like <code>Bird</code> and <code>Airplane</code>. They can both fly, but a <code>Bird</code> is not a type of <code>Airplane</code> and vice versa.",
        "For unrelated objects, it's better to use <code>mixins</code>. A <code>mixin</code> allows other objects to use a collection of functions.",
        "<blockquote>let flyMixin = function(obj) {<br>&nbsp;&nbsp;obj.fly = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Flying, wooosh!\");<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "The <code>flyMixin</code> takes any object and gives it the <code>fly</code> method.",
        "<blockquote>let bird = {<br>&nbsp;&nbsp;name: \"Donald\",<br>&nbsp;&nbsp;numLegs: 2<br>};<br><br>let plane = {<br>&nbsp;&nbsp;model: \"777\",<br>&nbsp;&nbsp;numPassengers: 524<br>};<br><br>flyMixin(bird);<br>flyMixin(plane);</blockquote>",
        "Here <code>bird</code> and <code>plane</code> are passed into <code>flyMixin</code>, which then assigns the <code>fly</code> function to each object. Now <code>bird</code> and <code>plane</code> can both fly:",
        "<blockquote>bird.fly(); // prints \"Flying, wooosh!\"<br>plane.fly(); // prints \"Flying, wooosh!\"</blockquote>",
        "Note how the <code>mixin</code> allows for the same <code>fly</code> method to be reused by unrelated objects <code>bird</code> and <code>plane</code>.",
        "<hr>",
        "Create a <code>mixin</code> named <code>glideMixin</code> that defines a method named <code>glide</code>. Then use the <code>glideMixin</code> to give both <code>bird</code> and <code>boat</code> the ability to glide."
      ],
      "tests": [
        {
          "text": "Your code should declare a <code>glideMixin</code> variable that is a function.",
          "testString": "assert(typeof glideMixin === \"function\", 'Your code should declare a <code>glideMixin</code> variable that is a function.');"
        },
        {
          "text": "Your code should use the <code>glideMixin</code> on the <code>bird</code> object to give it the <code>glide</code> method.",
          "testString": "assert(typeof bird.glide === \"function\", 'Your code should use the <code>glideMixin</code> on the <code>bird</code> object to give it the <code>glide</code> method.');"
        },
        {
          "text": "Your code should use the <code>glideMixin</code> on the <code>boat</code> object to give it the <code>glide</code> method.",
          "testString": "assert(typeof boat.glide === \"function\", 'Your code should use the <code>glideMixin</code> on the <code>boat</code> object to give it the <code>glide</code> method.');"
        }
      ],
      "solutions": [
        "let bird = {\n  name: \"Donald\",\n  numLegs: 2\n};\n\nlet boat = {\n  name: \"Warrior\",\n  type: \"race-boat\"\n};\nfunction glideMixin (obj) {\n  obj.glide = () => 'Gliding!';\n}\n\nglideMixin(bird);\nglideMixin(boat);"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let bird = {",
            "  name: \"Donald\",",
            "  numLegs: 2",
            "};",
            "",
            "let boat = {",
            "  name: \"Warrior\",",
            "  type: \"race-boat\"",
            "};",
            "",
            "// Add your code below this line",
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db2367417b2b2512b8a",
      "title": "Use Closure to Protect Properties Within an Object from Being Modified Externally",
      "description": [
        "In the previous challenge, <code>bird</code> had a public property <code>name</code>. It is considered public because it can be accessed and changed outside of <code>bird</code>'s definition.",
        "<blockquote>bird.name = \"Duffy\";</blockquote>",
        "Therefore, any part of your code can easily change the name of <code>bird</code> to any value. Think about things like passwords and bank accounts being easily changeable by any part of your codebase. That could cause a lot of issues.",
        "The simplest way to make properties private is by creating a variable within the constructor function. This changes the scope of that variable to be within the constructor function versus available globally. This way, the property can only be accessed and changed by methods also within the constructor function.",
        "<blockquote>function Bird() {<br>&nbsp;&nbsp;let hatchedEgg = 10; // private property<br><br>&nbsp;&nbsp;this.getHatchedEggCount = function() { // publicly available method that a bird object can use<br>&nbsp;&nbsp;&nbsp;&nbsp;return hatchedEgg;<br>&nbsp;&nbsp;};<br>}<br>let ducky = new Bird();<br>ducky.getHatchedEggCount(); // returns 10</blockquote>",
        "Here <code>getHachedEggCount</code> is a privileged method, because it has access to the private variable <code>hatchedEgg</code>. This is possible because <code>hatchedEgg</code> is declared in the same context as <code>getHachedEggCount</code>. In JavaScript, a function always has access to the context in which it was created. This is called <code>closure</code>.",
        "<hr>",
        "Change how <code>weight</code> is declared in the <code>Bird</code> function so it is a private variable. Then, create a method <code>getWeight</code> that returns the value of <code>weight</code>."
      ],
      "tests": [
        {
          "text": "The <code>weight</code> property should be a private variable.",
          "testString": "assert(!code.match(/this\\.weight/g), 'The <code>weight</code> property should be a private variable.');"
        },
        {
          "text": "Your code should create a method in <code>Bird</code> called <code>getWeight</code> that returns the <code>weight</code>.",
          "testString": "assert((new Bird()).getWeight() === 15, 'Your code should create a method in <code>Bird</code> called <code>getWeight</code> that returns the <code>weight</code>.');"
        }
      ],
      "solutions": [
        "function Bird() {\n  let weight = 15;\n  \n  this.getWeight = () => weight;\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Bird() {",
            "  this.weight = 15;",
            "  ",
            "  ",
            "}",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db2367417b2b2512b8b",
      "title": "Understand the Immediately Invoked Function Expression (IIFE)",
      "description": [
        "A common pattern in JavaScript is to execute a function as soon as it is declared:",
        "<blockquote>(function () {<br>&nbsp;&nbsp;console.log(\"Chirp, chirp!\");<br>})(); // this is an anonymous function expression that executes right away<br>// Outputs \"Chirp, chirp!\" immediately</blockquote>",
        "Note that the function has no name and is not stored in a variable. The two parentheses () at the end of the function expression cause it to be immediately executed or invoked. This pattern is known as an <code>immediately invoked function expression</code> or <code>IIFE</code>.",
        "<hr>",
        "Rewrite the function <code>makeNest</code> and remove its call so instead it's an anonymous <code>immediately invoked function expression</code> (<code>IIFE</code>)."
      ],
      "tests": [
        {
          "text": "The function should be anonymous.",
          "testString": "assert(/\\(\\s*?function\\s*?\\(\\s*?\\)\\s*?{/.test(code), 'The function should be anonymous.');"
        },
        {
          "text": "Your function should have parentheses at the end of the expression to call it immediately.",
          "testString": "assert(/}\\s*?\\)\\s*?\\(\\s*?\\)/.test(code), 'Your function should have parentheses at the end of the expression to call it immediately.');"
        }
      ],
      "solutions": [
        "(function () {\n  console.log(\"A cozy nest is ready\");\n})();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function makeNest() {",
            "  console.log(\"A cozy nest is ready\");",
            "}",
            "",
            "makeNest(); "
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db2367417b2b2512b8c",
      "title": "Use an IIFE to Create a Module",
      "description": [
        "An <code>immediately invoked function expression</code> (<code>IIFE</code>) is often used to group related functionality into a single object or <code>module</code>. For example, an earlier challenge defined two mixins:",
        "<blockquote>function glideMixin(obj) {<br>&nbsp;&nbsp;obj.glide = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Gliding on the water\");<br>&nbsp;&nbsp;};<br>}<br>function flyMixin(obj) {<br>&nbsp;&nbsp;obj.fly = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Flying, wooosh!\");<br>&nbsp;&nbsp;};<br>}</blockquote>",
        "We can group these <code>mixins</code> into a module as follows:",
        "<blockquote>let motionModule = (function () {<br>&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;glideMixin: function (obj) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.glide = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Gliding on the water\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;flyMixin: function(obj) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.fly = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Flying, wooosh!\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}) (); // The two parentheses cause the function to be immediately invoked</blockquote>",
        "Note that you have an <code>immediately invoked function expression</code> (<code>IIFE</code>) that returns an object <code>motionModule</code>. This returned object contains all of the <code>mixin</code> behaviors as properties of the object.",
        "The advantage of the <code>module</code> pattern is that all of the motion behaviors can be packaged into a single object that can then be used by other parts of your code. Here is an example using it:",
        "<blockquote>motionModule.glideMixin(duck);<br>duck.glide();</blockquote>",
        "<hr>",
        "Create a <code>module</code> named <code>funModule</code> to wrap the two <code>mixins</code> <code>isCuteMixin</code> and <code>singMixin</code>. <code>funModule</code> should return an object."
      ],
      "tests": [
        {
          "text": "<code>funModule</code> should be defined and return an object.",
          "testString": "assert(typeof funModule === \"object\", '<code>funModule</code> should be defined and return an object.');"
        },
        {
          "text": "<code>funModule.isCuteMixin</code> should access a function.",
          "testString": "assert(typeof funModule.isCuteMixin === \"function\", '<code>funModule.isCuteMixin</code> should access a function.');"
        },
        {
          "text": "<code>funModule.singMixin</code> should access a function.",
          "testString": "assert(typeof funModule.singMixin === \"function\", '<code>funModule.singMixin</code> should access a function.');"
        }
      ],
      "solutions": [
        "const funModule = (function () {\n  return {\n    isCuteMixin: obj => {\n      obj.isCute = () => true;\n    },\n    singMixin: obj => {\n      obj.sing = () => console.log(\"Singing to an awesome tune\");\n    }\n  };\n})();"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let isCuteMixin = function(obj) {",
            "  obj.isCute = function() {",
            "    return true;",
            "  };",
            "};",
            "let singMixin = function(obj) {",
            "  obj.sing = function() {",
            "    console.log(\"Singing to an awesome tune\");",
            "  };",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    }
  ]
}