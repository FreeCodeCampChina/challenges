{
  "name": "Regular Expressions",
  "order": 3,
  "time": "5 hours",
  "helpRoom": "Help",
  "challenges": [
    {
      "id": "587d7db3367417b2b2512b8e",
      "title": "Using the Test Method",
      "description": [
        "在编程语言中，正则表达式用于匹配指定的字符串。通过正则表达式创建模式（规则）可以帮你完成指定匹配。",
        "如果你想要在字符串 <code>\"The dog chased the cat\"</code> 中匹配到 <code>\"the\"</code> 这个单词，你可以使用如下正则表达式：<code>/the/</code>。注意，正则表达式中不需要引号。",
        "JavaScript中有多种使用正则表达式的方法。测试正则表达式的一种方法是使用 <code>.test()</code> 方法。<code>.test()</code> 方法会把你编写的正则表达式应用到一个字符串（即括号内的内容），如果你的模式成功匹配到字符，则返回 <code>true</code>，反之，返回 <code>false</code>。",
        "<blockquote>let testStr = \"freeCodeCamp\";<br>let testRegex = /Code/;<br>testRegex.test(testStr);<br>// Returns true</blockquote>",
        "<hr>",
        "使用 <code>.test()</code> 方法把正则表达式 <code>myRegex</code> 应用到字符串 <code>myString</code> 上面。"
      ],
      "tests": [
        {
          "text": "你应该使用 <code>.test()</code> 方法来测试正则表达式。",
          "testString": "assert(code.match(/myRegex.test\\(\\s*myString\\s*\\)/), '你应该使用 <code>.test()</code> 方法来测试正则表达式。');"
        },
        {
          "text": "你的返回结果应该为 <code>true</code>.",
          "testString": "assert(result === true, '你的返回结果应该为 <code>true</code>.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let myString = \"Hello, World!\";",
            "let myRegex = /Hello/;",
            "let result = myRegex; // Change this line"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db3367417b2b2512b8f",
      "title": "Match Literal Strings",
      "description": [
        "在上一个挑战中，你使用正则表达式 <code>/Hello/</code> 搜索到了字符串 <code>\"Hello\"</code>。那个字符串搜索字符串 <code>\"Hello\"</code> 的文字匹配。下面是另一个搜索字符串 <code>\"Kevin\"</code> 文字匹配的示例：",
        "<blockquote>let testStr = \"Hello, my name is Kevin.\";<br>let testRegex = /Kevin/;<br>testRegex.test(testStr);<br>// Returns true</blockquote>",
        "任何其他形式的 <code>\"Kevin\"</code> 都不会被匹配。例如，正则表达式 <code>/Kevin/</code> 不会匹配 <code>\"kevin\"</code> 或者 <code>\"KEVIN\"</code> 。",
        "<blockquote>let wrongRegex = /kevin/;<br>wrongRegex.test(testStr);<br>// Returns false</blockquote>",
        "未来的挑战将为你展示如何匹配其他形式的字符串",
        "<hr>",
        "完成正则表达式 <code>waldoRegex</code> ，在字符串 <code>waldoIsHiding</code> 中找到匹配文字 <code>\"Waldo\"</code> 。"
      ],
      "tests": [
        {
          "text": "你的正则表达式 <code>waldoRegex</code> 应该找到 <code>\"Waldo\"</code>",
          "testString": "assert(waldoRegex.test(waldoIsHiding), '你的正则表达式 <code>waldoRegex</code> 应该找到 <code>\"Waldo\"</code>');"
        },
        {
          "text": "你的正则表达式 <code>waldoRegex</code> 不应该搜索其他的任何内容。",
          "testString": "assert(!waldoRegex.test('Somewhere is hiding in this text.'), '你的正则表达式 <code>waldoRegex</code> 不应该搜索其他的任何内容。');"
        },
        {
          "text": "你应该使用你的正则表达式执行文字字符串匹配。",
          "testString": "assert(!/\\/.*\\/i/.test(code), '你应该使用你的正则表达式执行文字字符串匹配。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let waldoIsHiding = \"Somewhere Waldo is hiding in this text.\";",
            "let waldoRegex = /search/; // Change this line",
            "let result = waldoRegex.test(waldoIsHiding);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db4367417b2b2512b90",
      "title": "Match a Literal String with Different Possibilities",
      "description": [
        "使用正则表达式 <code>/coding/</code>，你可以在其他字符串中查找 <code>\"coding\"</code> 。",
        "这对于搜索单个字符串非常有用，但仅限于一种模式。您可以使用 <code>alternation</code> 或者 <code>OR</code> 操作符：<code>|</code> 。",
        "此操作符匹配在它之前或之后的模式。例如，如果您想匹配 <code>\"yes\"</code> 或 <code>\"no\"</code>，你需要的正则表达式是 <code>/yes|no/</code>。",
        "你还可以搜索不止两个模式。你可以通过添加更多的模式来实现这一功能，这些模式将包含更多的 <code>OR</code> 操作符来分隔它们，比如 <code>/yes|no|maybe/</code> 。",
        "<hr>",
        "完成正则表达式 <code>petRegex</code> 匹配 <code>\"dog\"</code> 、<code>\"cat\"</code> 、<code>\"bird\"</code> 或者 <code>\"fish\"</code> 。"
      ],
      "tests": [
        {
          "text": "对于字符串 <code>\"John has a pet dog.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>true</code> 。",
          "testString": "assert(petRegex.test('John has a pet dog.'), '对于字符串 <code>\"John has a pet dog.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>true</code> 。');"
        },
        {
          "text": "对于字符串 <code>\"Emma has a pet rock.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>false</code> 。",
          "testString": "assert(!petRegex.test('Emma has a pet rock.'), '对于字符串 <code>\"Emma has a pet rock.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>false</code> 。');"
        },
        {
          "text": "对于字符串 <code>\"Emma has a pet bird.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>true</code> 。",
          "testString": "assert(petRegex.test('Emma has a pet bird.'), '对于字符串 <code>\"Emma has a pet bird.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>true</code> 。');"
        },
        {
          "text": "对于字符串 <code>\"Liz has a pet cat.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>true</code> 。",
          "testString": "assert(petRegex.test('Liz has a pet cat.'), '对于字符串 <code>\"Liz has a pet cat.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>true</code> 。');"
        },
        {
          "text": "对于字符串 <code>\"Kara has a pet dolphin.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>false</code> 。",
          "testString": "assert(!petRegex.test('Kara has a pet dolphin.'), '对于字符串 <code>\"Kara has a pet dolphin.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>false</code> 。');"
        },
        {
          "text": "对于字符串 <code>\"Alice has a pet fish.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>true</code> 。",
          "testString": "assert(petRegex.test('Alice has a pet fish.'), '对于字符串 <code>\"Alice has a pet fish.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>true</code> 。');"
        },
        {
          "text": "对于字符串 <code>\"Jimmy has a pet computer.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>false</code> 。",
          "testString": "assert(!petRegex.test('Jimmy has a pet computer.'), '对于字符串 <code>\"Jimmy has a pet computer.\"</code>，你的正则表达式 <code>petRegex</code> 应该返回 <code>false</code> 。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let petString = \"James has a pet cat.\";",
            "let petRegex = /change/; // Change this line",
            "let result = petRegex.test(petString);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db4367417b2b2512b91",
      "title": "Ignore Case While Matching",
      "description": [
        "到目前为止，你已经查看了利用正则表达式来执行字符串的文字匹配。但是有时候，你可能也想匹配不同的情况。",
        "大小写（或者字母大小写）是大写字母和小写字母的区别。大写字母的例子有 <code>\"A\"</code> 、<code>\"B\"</code> 和 <code>\"C\"</code>。小写字母的例子有 <code>\"a\"</code> 、<code>\"b\"</code> 和 <code>\"c\"</code> 。",
        "你可以使用所谓的模式修正符来匹配这两种情况。有许多其他标志，不过这里主要关注忽略大小写的模式修正符 - <code>i</code> 模式修正符。你可以通过将它附加到正则表达式之后来使用它。这里给出使用该模式修正符的一个实例 <code>/ignorecase/i</code>。这个字符串可以匹配字符串 <code>\"ignorecase\"</code> 、<code>\"igNoreCase\"</code> 和 <code>\"IgnoreCase\"</code> 。",
        "<hr>",
        "编写正则表达式 <code>fccRegex</code> 以匹配 <code>\"freeCodeCamp\"</code>，忽略大小写。你的正则表达式不应与任何缩写或带有空格的变体匹配。"
      ],
      "tests": [
        {
          "text": "你的正则表达式应该匹配 <code>freeCodeCamp</code>",
          "testString": "assert(fccRegex.test('freeCodeCamp'), '你的正则表达式应该匹配 <code>freeCodeCamp</code>');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>FreeCodeCamp</code>",
          "testString": "assert(fccRegex.test('FreeCodeCamp'), '你的正则表达式应该匹配 <code>FreeCodeCamp</code>');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>FreecodeCamp</code>",
          "testString": "assert(fccRegex.test('FreecodeCamp'), '你的正则表达式应该匹配 <code>FreecodeCamp</code>');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>FreeCodecamp</code>",
          "testString": "assert(fccRegex.test('FreeCodecamp'), '你的正则表达式应该匹配 <code>FreeCodecamp</code>');"
        },
        {
          "text": "你的正则表达式不应该匹配 <code>Free Code Camp</code>",
          "testString": "assert(!fccRegex.test('Free Code Camp'), '你的正则表达式不应该匹配 <code>Free Code Camp</code>');"
        },
        {
          "text": "Your regex should match <code>FreeCOdeCamp</code>",
          "testString": "assert(fccRegex.test('FreeCOdeCamp'), 'Your regex should match <code>FreeCOdeCamp</code>');"
        },
        {
          "text": "你的正则表达式不应该匹配 <code>FCC</code>",
          "testString": "assert(!fccRegex.test('FCC'), '你的正则表达式不应该匹配 <code>FCC</code>');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>FrEeCoDeCamp</code>",
          "testString": "assert(fccRegex.test('FrEeCoDeCamp'), '你的正则表达式应该匹配 <code>FrEeCoDeCamp</code>');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>FrEeCodECamp</code>",
          "testString": "assert(fccRegex.test('FrEeCodECamp'), '你的正则表达式应该匹配 <code>FrEeCodECamp</code>');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>FReeCodeCAmp</code>",
          "testString": "assert(fccRegex.test('FReeCodeCAmp'), '你的正则表达式应该匹配 <code>FReeCodeCAmp</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let myString = \"freeCodeCamp\";",
            "let fccRegex = /change/; // Change this line",
            "let result = fccRegex.test(myString);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db4367417b2b2512b92",
      "title": "Extract Matches",
      "description": [
        "到目前为止，你只是检查了一个模式是否存在于字符串中。你还可以使用 <code>.match()</code> 方法来提取你找到的实际匹配项。",
        "要使用 <code>.match()</code> 方法，请将该方法应用到字符串上，并在括号内传入正则表达式。这里是一个案例：",
        "<blockquote>\"Hello, World!\".match(/Hello/);<br>// Returns [\"Hello\"]<br>let ourStr = \"Regular expressions\";<br>let ourRegex = /expressions/;<br>ourStr.match(ourRegex);<br>// Returns [\"expressions\"]</blockquote>",
        "<hr>",
        "利用 <code>.match()</code> 方法提取单词 <code>coding</code> 。"
      ],
      "tests": [
        {
          "text": "<code>结果</code> 应该包含单词 <code>coding</code>",
          "testString": "assert(result.join() === \"coding\", '<code>结果</code> 应该包含单词 <code>coding</code>');"
        },
        {
          "text": "你的正则表达式 <code>codingRegex</code> 应该搜索 <code>coding</code>",
          "testString": "assert(codingRegex.source === \"coding\", '你的正则表达式 <code>codingRegex</code> 应该搜索 <code>coding</code>');"
        },
        {
          "text": "你应该使用 <code>.match()</code> 方法。",
          "testString": "assert(code.match(/\\.match\\(.*\\)/), '你应该使用 <code>.match()</code> 方法。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let extractStr = \"Extract the word 'coding' from this string.\";",
            "let codingRegex = /change/; // Change this line",
            "let result = extractStr; // Change this line"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db4367417b2b2512b93",
      "title": "Find More Than the First Match",
      "description": [
        "到目前为止，您只能提取或搜索一次模式。",
        "<blockquote>let testStr = \"Repeat, Repeat, Repeat\";<br>let ourRegex = /Repeat/;<br>testStr.match(ourRegex);<br>// Returns [\"Repeat\"]</blockquote>",
        "若要多次搜索或提取模式，你可以使用 <code>g</code> 模式修正符。",
        "<blockquote>let repeatRegex = /Repeat/g;<br>testStr.match(repeatRegex);<br>// Returns [\"Repeat\", \"Repeat\", \"Repeat\"]</blockquote>",
        "<hr>",
        "使用正则表达式 <code>starRegex</code>，从字符串 <code>twinkleStar</code> 中找到并提取所有的 <code>\"Twinkle\"</code> 单词。",
        "<strong>注意</strong><br>在正则表达式上可以有多个模式修正符，比如 <code>/search/gi</code>"
      ],
      "tests": [
        {
          "text": "你的正则表达式 <code>starRegex</code> 应该使用全局模式修正符 <code>g</code>",
          "testString": "assert(starRegex.flags.match(/g/).length == 1, '你的正则表达式 <code>starRegex</code> 应该使用全局模式修正符 <code>g</code>');"
        },
        {
          "text": "你的正则表达式 <code>starRegex</code> 应该使用忽略大小写模式修正符 <code>i</code>",
          "testString": "assert(starRegex.flags.match(/i/).length == 1, '你的正则表达式 <code>starRegex</code> 应该使用忽略大小写模式修正符 <code>i</code>');"
        },
        {
          "text": "你的匹配应该匹配单词 <code>\"Twinkle\"</code> 的两个匹配项",
          "testString": "assert(result.sort().join() == twinkleStar.match(/twinkle/gi).sort().join(), '你的匹配应该匹配单词 <code>\"Twinkle\"</code> 的两个匹配项');"
        },
        {
          "text": "你的匹配 <code>结果</code> 应该包含两个元素。",
          "testString": "assert(result.length == 2, '你的匹配 <code>结果</code> 应该包含两个元素。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let twinkleStar = \"Twinkle, twinkle, little star\";",
            "let starRegex = /change/; // Change this line",
            "let result = twinkleStar; // Change this line"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db5367417b2b2512b94",
      "title": "Match Anything with Wildcard Period",
      "description": [
        "有时你不会（或不需要）知道模式中的确切字符。比如，考虑到要匹配到所有的单词，有一个拼写错误就会耗费很长时间。幸运的是，你可以使用通配符 <code>.</code> 来节约你的时间。",
        "通配符 <code>.</code> 将匹配任何一个字符。通配符也被称为 <code>dot</code> 和 <code>period</code>。你可以像使用正则表达式中任何其他字符一样使用通配符。例如，如果你想匹配 <code>\"hug\"</code> 、<code>\"huh\"</code> 、<code>\"hut\"</code> 和 <code>\"hum\"</code>，你可以使用正则表达式 <code>/hu./</code> 匹配所有的四个单词。",
        "<blockquote>let humStr = \"I'll hum a song\";<br>let hugStr = \"Bear hug\";<br>let huRegex = /hu./;<br>humStr.match(huRegex); // Returns [\"hum\"]<br>hugStr.match(huRegex); // Returns [\"hug\"]</blockquote>",
        "<hr>",
        "完成正则表达式 <code>unRegex</code> 以匹配字符串 <code>\"run\"</code> 、<code>\"sun\"</code> 、<code>\"fun\"</code> 、<code>\"pun\"</code> 、<code>\"nun\"</code> 和 <code>\"bun\"</code>。你的正则表达式中应该使用通配符。"
      ],
      "tests": [
        {
          "text": "你应该使用 <code>.test()</code> 方法。",
          "testString": "assert(code.match(/\\.test\\(.*\\)/), '你应该使用 <code>.test()</code> 方法。');"
        },
        {
          "text": "你应该在你的正则表达式 <code>unRegex</code> 中使用通配符",
          "testString": "assert(/\\./.test(unRegex.source), '你应该在你的正则表达式 <code>unRegex</code> 中使用通配符');"
        },
        {
          "text": "你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"Let us go on a run.\"</code> 中匹配到 <code>\"run\"</code> 单词",
          "testString": "assert(unRegex.test(\"Let us go on a run.\"), '你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"Let us go on a run.\"</code> 中匹配到 <code>\"run\"</code> 单词');"
        },
        {
          "text": "你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"The sun is out today.\"</code> 中匹配到 <code>\"sun\"</code> 单词",
          "testString": "assert(unRegex.test(\"The sun is out today.\"), '你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"The sun is out today.\"</code> 中匹配到 <code>\"sun\"</code> 单词');"
        },
        {
          "text": "你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"Coding is a lot of fun.\"</code> 中匹配到 <code>\"fun\"</code> 单词",
          "testString": "assert(unRegex.test(\"Coding is a lot of fun.\"), '你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"Coding is a lot of fun.\"</code> 中匹配到 <code>\"fun\"</code> 单词');"
        },
        {
          "text": "你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"Seven days without a pun makes one weak.\"</code> 中匹配到 <code>\"pun\"</code> 单词",
          "testString": "assert(unRegex.test(\"Seven days without a pun makes one weak.\"), '你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"Seven days without a pun makes one weak.\"</code> 中匹配到 <code>\"pun\"</code> 单词');"
        },
        {
          "text": "你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"One takes a vow to be a nun.\"</code> 中匹配到 <code>\"nun\"</code> 单词",
          "testString": "assert(unRegex.test(\"One takes a vow to be a nun.\"), '你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"One takes a vow to be a nun.\"</code> 中匹配到 <code>\"nun\"</code> 单词');"
        },
        {
          "text": "你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"She got fired from the hot dog stand for putting her hair in a bun.\"</code> 中匹配到 <code>\"bun\"</code> 单词",
          "testString": "assert(unRegex.test(\"She got fired from the hot dog stand for putting her hair in a bun.\"), '你的正则表达式 <code>unRegex</code> 应该在字符串 <code>\"She got fired from the hot dog stand for putting her hair in a bun.\"</code> 中匹配到 <code>\"bun\"</code> 单词');"
        },
        {
          "text": "你的正则表达式 <code>unRegex</code> 不应该匹配 <code>\"There is a bug in my code.\"</code>",
          "testString": "assert(!unRegex.test(\"There is a bug in my code.\"), '你的正则表达式 <code>unRegex</code> 不应该匹配 <code>\"There is a bug in my code.\"</code>');"
        },
        {
          "text": "你的正则表达式 <code>unRegex</code> 不应该匹配 <code>\"Catch me if you can.\"</code>",
          "testString": "assert(!unRegex.test(\"Can me if you can.\"), '你的正则表达式 <code>unRegex</code> 不应该匹配 <code>\"Catch me if you can.\"</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let exampleStr = \"Let's have fun with regular expressions!\";",
            "let unRegex = /change/; // Change this line",
            "let result = unRegex.test(exampleStr);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db5367417b2b2512b95",
      "title": "Match Single Character with Multiple Possibilities",
      "description": [
        "你学习了如何匹配文字模式（<code>/literal/</code>）和通配符（<code>/./</code>）。这是正则表达式的两种极端情况，一种是精确匹配，而另一种则是查找所有匹配。在这两种极端情况之间有一个平衡选项。",
        "你可以使用 <code>字符集</code> 搜索具有一定灵活性的文字模式。字符集允许你通过把它们放在方括号（<code>[</code> 和 <code>]</code>）之间的方式来定义一组你需要匹配的字符串。",
        "例如，你想要匹配 <code>\"bag\"</code> 、<code>\"big\"</code> 和 <code>\"bug\"</code>，但是不想匹配 <code>\"bog\"</code>。你可以创建正则表达式 <code>/b[aiu]g/</code> 来执行此操作。<code>[aiu]</code> 是只匹配字符 <code>\"a\"</code> 、<code>\"i\"</code> 或者 <code>\"u\"</code> 的字符集。",
        "<blockquote>let bigStr = \"big\";<br>let bagStr = \"bag\";<br>let bugStr = \"bug\";<br>let bogStr = \"bog\";<br>let bgRegex = /b[aiu]g/;<br>bigStr.match(bgRegex); // Returns [\"big\"]<br>bagStr.match(bgRegex); // Returns [\"bag\"]<br>bugStr.match(bgRegex); // Returns [\"bug\"]<br>bogStr.match(bgRegex); // Returns null</blockquote>",
        "<hr>",
        "使用元音字符集（<code>a</code> 、<code>e</code> 、<code>i</code> 、<code>o</code> 、<code>u</code>）在你的正则表达式 <code>vowelRegex</code> 中找到字符串 <code>quoteSample</code> 中的所有元音。",
        "<strong>注意</strong><br>一定要同时匹配大小写元音。"
      ],
      "tests": [
        {
          "text": "你应该找到所有25个元音。",
          "testString": "assert(result.length == 25, '你应该找到所有25个元音。');"
        },
        {
          "text": "你的正则表达式 <code>vowelRegex</code> 应该使用字符集。",
          "testString": "assert(/\\[.*\\]/.test(vowelRegex.source), '你的正则表达式 <code>vowelRegex</code> 应该使用字符集。');"
        },
        {
          "text": "你的正则表达式 <code>vowelRegex</code> 应该使用全局模式修正符。",
          "testString": "assert(vowelRegex.flags.match(/g/).length == 1, '你的正则表达式 <code>vowelRegex</code> 应该使用全局模式修正符。');"
        },
        {
          "text": "你的正则表达式 <code>vowelRegex</code> 应该使用忽略大小写模式修正符。",
          "testString": "assert(vowelRegex.flags.match(/i/).length == 1, '你的正则表达式 <code>vowelRegex</code> 应该使用忽略大小写模式修正符。');"
        },
        {
          "text": "你的正则表达式不应该匹配任何辅音。",
          "testString": "assert(!/[b-df-hj-np-tv-z]/gi.test(result.join()), '你的正则表达式不应该匹配任何辅音。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let quoteSample = \"Beware of bugs in the above code; I have only proved it correct, not tried it.\";",
            "let vowelRegex = /change/; // Change this line",
            "let result = vowelRegex; // Change this line"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db5367417b2b2512b96",
      "title": "Match Letters of the Alphabet",
      "description": [
        "你了解了如何使用 <code>字符集</code> 来指定要匹配的一组字符串，但是当你需要匹配大量字符（例如，字母表中的每个字母）时。幸运的是，有一个内置的特性使这个功能变得简短。",
        "在 <code>字符集</code> 中，你可以使用 <code>连字符</code>（<code>-</code>）来定义要匹配的字符范围。",
        "例如，要匹配小写字母 <code>a</code> 到 <code>e</code>，你可以使用 <code>[a-e]</code>。",
        "<blockquote>let catStr = \"cat\";<br>let batStr = \"bat\";<br>let matStr = \"mat\";<br>let bgRegex = /[a-e]at/;<br>catStr.match(bgRegex); // Returns [\"cat\"]<br>batStr.match(bgRegex); // Returns [\"bat\"]<br>matStr.match(bgRegex); // Returns null</blockquote>",
        "<hr>",
        "匹配字符串 <code>quoteSample</code> 中的所有字母。",
        "<strong>注意</strong><br>一定要同时匹配大小写 <strong>字母<strong>."
      ],
      "tests": [
        {
          "text": "你的正则表达式 <code>alphabetRegex</code> 应该匹配 35 项。",
          "testString": "assert(result.length == 35, '你的正则表达式 <code>alphabetRegex</code> 应该匹配 35 项。');"
        },
        {
          "text": "你的正则表达式 <code>alphabetRegex</code> 应该使用全局模式修正符。",
          "testString": "assert(alphabetRegex.flags.match(/g/).length == 1, '你的正则表达式 <code>alphabetRegex</code> 应该使用全局模式修正符。');"
        },
        {
          "text": "你的正则表达式 <code>alphabetRegex</code> 应该使用忽略大小写模式修正符。",
          "testString": "assert(alphabetRegex.flags.match(/i/).length == 1, '你的正则表达式 <code>alphabetRegex</code> 应该使用忽略大小写模式修正符。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let quoteSample = \"The quick brown fox jumps over the lazy dog.\";",
            "let alphabetRegex = /change/; // Change this line",
            "let result = alphabetRegex; // Change this line"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db5367417b2b2512b97",
      "title": "Match Numbers and Letters of the Alphabet",
      "description": [
        "使用连字符（<code>-</code>）匹配字符范围并不仅限于字母。它还可以匹配一系列数字。",
        "例如，<code>/[0-5]/</code> 匹配 <code>0</code> 和 <code>5</code> 之间的任意数字，包含 <code>0</code> 和 <code>5</code> 。",
        "此外，还可以在单个字符集中组合一系列字母和数字。",
        "<blockquote>let jennyStr = \"Jenny8675309\";<br>let myRegex = /[a-z0-9]/ig;<br>// matches all letters and numbers in jennyStr<br>jennyStr.match(myRegex);</blockquote>",
        "<hr>",
        "创建一个正则表达式，使其可以匹配 <code>h</code> 和 <code>s</code> 之间的一系列字母，以及 <code>2</code> and <code>6</code> 之间的一系列数字。请记住在正则表达式中包含恰当的模式修正符。"
      ],
      "tests": [
        {
          "text": "你的正则表达式 <code>myRegex</code> 应该匹配 17 项。",
          "testString": "assert(result.length == 17, '你的正则表达式 <code>myRegex</code> 应该匹配 17 项。');"
        },
        {
          "text": "你的正则表达式 <code>myRegex</code> 应该使用全局模式修正符。",
          "testString": "assert(myRegex.flags.match(/g/).length == 1, '你的正则表达式 <code>myRegex</code> 应该使用全局模式修正符。');"
        },
        {
          "text": "你的正则表达式 <code>myRegex</code> 应该使用忽略大小写模式修正符。",
          "testString": "assert(myRegex.flags.match(/i/).length == 1, '你的正则表达式 <code>myRegex</code> 应该使用忽略大小写模式修正符。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let quoteSample = \"Blueberry 3.141592653s are delicious.\";",
            "let myRegex = /change/; // Change this line",
            "let result = myRegex; // Change this line"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db6367417b2b2512b98",
      "title": "Match Single Characters Not Specified",
      "description": [
        "到目前为止，你已创建了一个你想要匹配的字符集合，但你也可以创建一个你不想匹配的字符集合。这些类型的字符集称为 <code>否定字符集</code>。",
        "要创建 <code>否定字符集</code>，你需要在开始括号后面和不想匹配的字符前面放置 <code>插入字符</code>（即 <code>^</code>）。",
        "例如，<code>/[^aeiou]/gi</code> 匹配所有非元音字符。注意，字符 <code>.</code> 、<code>!</code> 、<code>[</code> 、<code>@</code> 、<code>/</code> 和空白字符也会被匹配，该否定字符集仅排除元音字符。",
        "<hr>",
        "创建一个匹配所有非数字或元音字符的正则表达式。请记住在正则表达式中包含恰当的模式修正符。"
      ],
      "tests": [
        {
          "text": "你的正则表达式 <code>myRegex</code> 应该匹配 9 项。",
          "testString": "assert(result.length == 9, '你的正则表达式 <code>myRegex</code> 应该匹配 9 项。');"
        },
        {
          "text": "你的正则表达式 <code>myRegex</code> 应该使用全局模式修正符。",
          "testString": "assert(myRegex.flags.match(/g/).length == 1, '你的正则表达式 <code>myRegex</code> 应该使用全局模式修正符。');"
        },
        {
          "text": "你的正则表达式 <code>myRegex</code> 应该使用忽略大小写模式修正符。",
          "testString": "assert(myRegex.flags.match(/i/).length == 1, '你的正则表达式 <code>myRegex</code> 应该使用忽略大小写模式修正符。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let quoteSample = \"3 blind mice.\";",
            "let myRegex = /change/; // Change this line",
            "let result = myRegex; // Change this line"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db6367417b2b2512b99",
      "title": "Match Characters that Occur One or More Times",
      "description": [
        "有时，你需要匹配出现一次或者连续多次的的字符（或字符组）。这意味着它至少出现一次，并且可能重复出现。",
        "你可以使用 <code>+</code> 符号来检查情况是否如此。记住，字符或模式必须必须连续出现。也就是说，字符必须一个接一个的重复出现。",
        "例如， <code>/a+/g</code> 会在 <code>\"abc\"</code> 中找到一个匹配项，并且返回 <code>[\"a\"]</code>。因为 <code>+</code> 的存在，它也会在 <code>\"aabc\"</code> 中找到一个匹配项，然后返回 <code>[\"aa\"]</code>。",
        "如果它是检查字符串 <code>\"abab\"</code>，它将找到两个匹配项并且返回 <code>[\"a\", \"a\"]</code> ，因为 <code>a</code> 字符不连续，在它们之间有一个 <code>b</code> 字符。最后，因为在字符串 <code>\"bcd\"</code> 中没有 <code>\"a\"</code> ，因此找不到匹配项。",
        "<hr>",
        "你希望在字符串 <code>\"Mississippi\"</code> 中找到出现一次或多次的字母 <code>s</code> 的匹配项。编写一个使用 <code>+</code> 符号的正则表达式。"
      ],
      "tests": [
        {
          "text": "你的正则表达式 <code>myRegex</code> 应该使用 <code>+</code> 符号来匹配一个或多个 <code>s</code> 字符。",
          "testString": "assert(/\\+/.test(myRegex.source), '你的正则表达式 <code>myRegex</code> 应该使用 <code>+</code> 符号来匹配一个或多个 <code>s</code> 字符。');"
        },
        {
          "text": "你的正则表达式 <code>myRegex</code> 应该匹配两项。",
          "testString": "assert(result.length == 2, '你的正则表达式 <code>myRegex</code> 应该匹配两项。');"
        },
        {
          "text": "<code>结果</code> 变量应该是一个包含两个 <code>\"ss\"</code> 匹配项的数组",
          "testString": "assert(result[0] == 'ss' && result[1] == 'ss', '<code>结果</code> 变量应该是一个包含两个 <code>\"ss\"</code> 匹配项的数组');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let difficultSpelling = \"Mississippi\";",
            "let myRegex = /change/; // Change this line",
            "let result = difficultSpelling.match(myRegex);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db6367417b2b2512b9a",
      "title": "Match Characters that Occur Zero or More Times",
      "description": [
        "上一次的挑战中使用了加号 <code>+</code> 来查找出现一次或多次的字符。还有一个选项可以匹配出现零次或多次的字符。",
        "执行该操作的字符是 <code>asterisk</code> 或 <code>star</code>：<code>*</code> 。",
        "<blockquote>let soccerWord = \"gooooooooal!\";<br>let gPhrase = \"gut feeling\";<br>let oPhrase = \"over the moon\";<br>let goRegex = /go*/;<br>soccerWord.match(goRegex); // Returns [\"goooooooo\"]<br>gPhrase.match(goRegex); // Returns [\"g\"]<br>oPhrase.match(goRegex); // Returns null</blockquote>",
        "<hr>",
        "创建一个正则表达式 <code>chewieRegex</code> ，使用 <code>*</code> 符号在 <code>chewieQuote</code> 中匹配大小写的 <code>\"a\"</code> 字符。你的正则表达式不需要模式修正符，也不应该匹配任何其他引号。"
      ],
      "tests": [
        {
          "text": "你的正则表达式 <code>chewieRegex</code> 应该使用 <code>*</code> 符号匹配零个或多个 <code>a</code> 字符。",
          "testString": "assert(/\\*/.test(chewieRegex.source), '你的正则表达式 <code>chewieRegex</code> 应该使用 <code>*</code> 符号匹配零个或多个 <code>a</code> 字符。');"
        },
        {
          "text": "你的正则表达式 <code>chewieRegex</code> 应该匹配 16 个字符。",
          "testString": "assert(result[0].length === 16, '你的正则表达式 <code>chewieRegex</code> 应该匹配 16 个字符。');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>\"Aaaaaaaaaaaaaaaa\"</code> 。",
          "testString": "assert(result[0] === 'Aaaaaaaaaaaaaaaa', '你的正则表达式应该匹配 <code>\"Aaaaaaaaaaaaaaaa\"</code> 。');"
        },
        {
          "text": "你的正则表达式在 <code>\"He made a fair move. Screaming about it can&#39t help you.\"</code> 中不应该匹配任何字符。",
          "testString": "assert(!\"He made a fair move. Screaming about it can\\'t help you.\".match(chewieRegex), '你的正则表达式在 <code>\"He made a fair move. Screaming about it can&#39t help you.\"</code> 中不应该匹配任何字符。');"
        },
        {
          "text": "你的正则表达式在 <code>\"Let him have it. It&#39s not wise to upset a Wookiee.\"</code> 中不应该匹配任何字符。",
          "testString": "assert(!\"Let him have it. It\\'s not wise to upset a Wookiee.\".match(chewieRegex), '你的正则表达式在 <code>\"Let him have it. It&#39s not wise to upset a Wookiee.\"</code> 中不应该匹配任何字符。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let chewieQuote = \"Aaaaaaaaaaaaaaaarrrgh!\";",
            "let chewieRegex = /change/; // Change this line",
            "let result = chewieQuote.match(chewieRegex);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db6367417b2b2512b9b",
      "title": "Find Characters with Lazy Matching",
      "description": [
        "在正则表达式中，<code>贪婪</code> 匹配会查找符合正则表达式模式的字符串的最长可能部分，并将其作为匹配项返回。另一种方案称为 <code>懒惰</code> 匹配，他查找满足正则表达式的字符串的最小可能部分。",
        "你可以将正则表达式 <code>/t[a-z]*i/</code> 应用于字符串 <code>\"titanic\"</code>。这个正则表达式基本上是一个以 <code>t</code> 开始，以 <code>i</code> 结束，并且中间有一些字母的模式。",
        "正则表达式默认是 <code>贪婪</code> 匹配，因此匹配返回为 <code>[\"titani\"]</code>。它找到适合该模式的最大子字符串。",
        "但是，你可以使用 <code>?</code> 字符来将其变成 <code>懒惰</code> 匹配。调整后的正则表达式 <code>/t[a-z]*?i/</code> 匹配字符串 <code>\"titanic\"</code> 返回 <code>[\"ti\"]</code> 。",
        "<hr>",
        "修复正则表达式 <code>/&lt;.*&gt;/</code> 返回HTML标签 <code>&lt;h1&gt;</code> ，而不是文本 <code>\"&lt;h1&gt;Winter is coming&lt;/h1&gt;\"</code>。请记住在正则表达式中使用通配符 <code>.</code> 来匹配任意字符。"
      ],
      "tests": [
        {
          "text": "<code>结果</code> 变量应该是一个包含 <code>&lt;h1&gt;</code> 的数组。",
          "testString": "assert(result[0] == '<h1>', '<code>结果</code> 变量应该是一个包含 <code>&lt;h1&gt;</code> 的数组。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let text = \"<h1>Winter is coming</h1>\";",
            "let myRegex = /<.*>/; // Change this line",
            "let result = text.match(myRegex);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db7367417b2b2512b9c",
      "title": "Find One or More Criminals in a Hunt",
      "description": [
        "是时候暂停和测试你的新正则表达式写作技巧了。 一群罪犯逃出监狱逃跑，但你不知道有多少人。但是，你知道他们和其他人在一起时会保持紧密联系。你有责任立刻找到所有的罪犯。",
        "这里有一个示例来回顾如何做到这一点：",
        "正则表达式 <code>/z+/</code> 当字母 <code>z</code> 它出现一次或连续多次时会匹配。它会在以下所有字符串中找到匹配：",
        "<blockquote>\"z\"<br>\"zzzzzz\"<br>\"ABCzzzz\"<br>\"zzzzABC\"<br>\"abczzzzzzzzzzzzzzzzzzzzzabc\"</blockquote>",
        "但是它不会在以下字符串中找到匹配，因为它们中没有字母 <code>z</code>：",
        "<blockquote>\"\"<br>\"ABC\"<br>\"abcabc\"</blockquote>",
        "<hr>",
        "编写一个 <code>贪婪</code> 正则表达式，在一组其他人中查找一个或多个罪犯。罪犯由大写字母<code>C</code>表示。"
      ],
      "tests": [
        {
          "text": "你的正则表达式应该匹配 <code>\"C\"</code> 中的 <em>一个</em> 罪犯（\"<code>C</code>\"）",
          "testString": "assert('C'.match(reCriminals) && 'C'.match(reCriminals)[0] == 'C', '你的正则表达式应该匹配 <code>\"C\"</code> 中的 <em>一个</em> 罪犯（\"<code>C</code>\"）');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>\"CC\"</code> 中的 <em>两个</em> 罪犯（\"<code>CC</code>\"）",
          "testString": "assert('CC'.match(reCriminals) && 'CC'.match(reCriminals)[0] == 'CC', '你的正则表达式应该匹配 <code>\"CC\"</code> 中的 <em>两个</em> 罪犯（\"<code>CC</code>\"）');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>\"P1P5P4CCCP2P6P3\"</code> 中的 <em>三个</em> 罪犯（\"<code>CCC</code>\"）",
          "testString": "assert('P1P5P4CCCP2P6P3'.match(reCriminals) && 'P1P5P4CCCP2P6P3'.match(reCriminals)[0] == 'CCC', '你的正则表达式应该匹配 <code>\"P1P5P4CCCP2P6P3\"</code> 中的 <em>三个</em> 罪犯（\"<code>CCC</code>\"）');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>\"P6P2P7P4P5CCCCCP3P1\"</code> 中的 <em>五个</em> 罪犯（\"<code>CCCCC</code>\"）",
          "testString": "assert('P6P2P7P4P5CCCCCP3P1'.match(reCriminals) && 'P6P2P7P4P5CCCCCP3P1'.match(reCriminals)[0] == 'CCCCC', '你的正则表达式应该匹配 <code>\"P6P2P7P4P5CCCCCP3P1\"</code> 中的 <em>五个</em> 罪犯（\"<code>CCCCC</code>\"）');"
        },
        {
          "text": "你的正则表达式在 <code>\"\"</code> 中不应该匹配到任何罪犯",
          "testString": "assert(!reCriminals.test(''), '你的正则表达式在 <code>\"\"</code> 中不应该匹配到任何罪犯');"
        },
        {
          "text": "你的正则表达式在 <code>\"P1P2P3\"</code> 中不应该匹配到任何罪犯",
          "testString": "assert(!reCriminals.test('P1P2P3'), '你的正则表达式在 <code>\"P1P2P3\"</code> 中不应该匹配到任何罪犯');"
        },
        {
          "text": "你的正则表达式应该匹配 <code>\"P2P1P5P4CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCP3\"</code> 中的 <em>五十个</em> 罪犯（\"<code>CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</code>\"）。",
          "testString": "assert('P2P1P5P4CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCP3'.match(reCriminals) && 'P2P1P5P4CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCP3'.match(reCriminals)[0] == \"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\", '你的正则表达式应该匹配 <code>\"P2P1P5P4CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCP3\"</code> 中的 <em>五十个</em> 罪犯（\"<code>CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</code>\"）。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// example crowd gathering",
            "let crowd = 'P1P2P3P4P5P6CCCP7P8P9';",
            "",
            "let reCriminals = /./; // Change this line",
            "",
            "let matchedCriminals = crowd.match(reCriminals);",
            "console.log(matchedCriminals);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db7367417b2b2512b9d",
      "title": "Match Beginning String Patterns",
      "description": [
        "先前的挑战表明，正则表达式可以用于查找许多匹配项。它们还用于搜索字符串中特定位置的模式。",
        "在之前的挑战中，你使用 <code>字符集</code> 中的 <code>插入</code> 符号（<code>^</code>）来创建一个 <code>否定字符集</code>，形如 <code>[^thingsThatWillNotBeMatched]</code>。在 <code>字符集</code> 之外，<code>插入</code> 符号用于字符串的开头搜索模式。",
        "<blockquote>let firstString = \"Ricky is first and can be found.\";<br>let firstRegex = /^Ricky/;<br>firstRegex.test(firstString);<br>// Returns true<br>let notFirst = \"You can't find Ricky now.\";<br>firstRegex.test(notFirst);<br>// Returns false</blockquote>",
        "<hr>",
        "使用正则表达式中的 <code>插入</code> 符号仅在字符串 <code>rickyAndCal</code> 的开头找到 <code>\"Cal\"</code>。"
      ],
      "tests": [
        {
          "text": "你的正则表达式应该搜索有一个大写字母的 <code>\"Cal\"</code> 。",
          "testString": "assert(calRegex.source == \"^Cal\", '你的正则表达式应该搜索有一个大写字母的 <code>\"Cal\"</code> 。');"
        },
        {
          "text": "你的正则表达式不应该使用任何模式修正符。",
          "testString": "assert(calRegex.flags == \"\", '你的正则表达式不应该使用任何模式修正符。');"
        },
        {
          "text": "你的正则表达式应该匹配字符串开头的 <code>\"Cal\"</code> 。",
          "testString": "assert(calRegex.test(\"Cal and Ricky both like racing.\"), '你的正则表达式应该匹配字符串开头的 <code>\"Cal\"</code> 。');"
        },
        {
          "text": "你的正则表达式不应该匹配字符串中间的 <code>\"Cal\"</code> 。",
          "testString": "assert(!calRegex.test(\"Ricky and Cal both like racing.\"), '你的正则表达式不应该匹配字符串中间的 <code>\"Cal\"</code> 。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let rickyAndCal = \"Cal and Ricky both like racing.\";",
            "let calRegex = /change/; // Change this line",
            "let result = calRegex.test(rickyAndCal);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db7367417b2b2512b9e",
      "title": "Match Ending String Patterns",
      "description": [
        "在上一个挑战中，你学习了使用 <code>^</code> 符号来搜索字符串开头的模式。还有一种方法可以搜索字符串末尾的模式。",
        "你可以使用正则表达式末尾的 <code>美元</code> 符号 <code>$</code> 来搜索字符串的结尾。",
        "<blockquote>let theEnding = \"This is a never ending story\";<br>let storyRegex = /story$/;<br>storyRegex.test(theEnding);<br>// Returns true<br>let noEnding = \"Sometimes a story will have to end\";<br>storyRegex.test(noEnding);<br>// Returns false<br></blockquote>",
        "<hr>",
        "使用锚字符（<code>$</code>）在字符串 <code>caboose</code> 的末尾匹配 <code>\"caboose\"</code> 。"
      ],
      "tests": [
        {
          "text": "你应该在正则表达式使用美元符号 <code>$</code> 来搜索 <code>\"caboose\"</code> 。",
          "testString": "assert(lastRegex.source == \"caboose$\", '你应该在正则表达式使用美元符号 <code>$</code> 来搜索 <code>\"caboose\"</code> 。');"
        },
        {
          "text": "你的正则表达式不应该使用任何模式修正符。",
          "testString": "assert(lastRegex.flags == \"\", '你的正则表达式不应该使用任何模式修正符。');"
        },
        {
          "text": "你应该在字符串 <code>\"The last car on a train is the caboose\"</code> 的末尾匹配 <code>\"caboose\"</code> 。",
          "testString": "assert(lastRegex.test(\"The last car on a train is the caboose\"), '你应该在字符串 <code>\"The last car on a train is the caboose\"</code> 的末尾匹配 <code>\"caboose\"</code> 。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let caboose = \"The last car on a train is the caboose\";",
            "let lastRegex = /change/; // Change this line",
            "let result = lastRegex.test(caboose);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db7367417b2b2512b9f",
      "title": "Match All Letters and Numbers",
      "description": [
        "Using character classes, you were able to search for all letters of the alphabet with <code>[a-z]</code>. This kind of character class is common enough that there is a shortcut for it, although it includes a few extra characters as well.",
        "The closest character class in JavaScript to match the alphabet is <code>\\w</code>. This shortcut is equal to <code>[A-Za-z0-9_]</code>. This character class matches upper and lowercase letters plus numbers. Note, this character class also includes the underscore character (<code>_</code>).",
        "<blockquote>let longHand = /[A-Za-z0-9_]+/;<br>let shortHand = /\\w+/;<br>let numbers = \"42\";<br>let varNames = \"important_var\";<br>longHand.test(numbers); // Returns true<br>shortHand.test(numbers); // Returns true<br>longHand.test(varNames); // Returns true<br>shortHand.test(varNames); // Returns true</blockquote>",
        "These shortcut character classes are also known as <code>shorthand character classes</code>.",
        "<hr>",
        "Use the shorthand character class <code>\\w</code> to count the number of alphanumeric characters in various quotes and strings."
      ],
      "tests": [
        {
          "text": "Your regex should use the global flag.",
          "testString": "assert(alphabetRegexV2.global, 'Your regex should use the global flag.');"
        },
        {
          "text": "Your regex should find 31 alphanumeric characters in <code>\"The five boxing wizards jump quickly.\"</code>",
          "testString": "assert(\"The five boxing wizards jump quickly.\".match(alphabetRegexV2).length === 31, 'Your regex should find 31 alphanumeric characters in <code>\"The five boxing wizards jump quickly.\"</code>');"
        },
        {
          "text": "Your regex should find 32 alphanumeric characters in <code>\"Pack my box with five dozen liquor jugs.\"</code>",
          "testString": "assert(\"Pack my box with five dozen liquor jugs.\".match(alphabetRegexV2).length === 32, 'Your regex should find 32 alphanumeric characters in <code>\"Pack my box with five dozen liquor jugs.\"</code>');"
        },
        {
          "text": "Your regex should find 30 alphanumeric characters in <code>\"How vexingly quick daft zebras jump!\"</code>",
          "testString": "assert(\"How vexingly quick daft zebras jump!\".match(alphabetRegexV2).length === 30, 'Your regex should find 30 alphanumeric characters in <code>\"How vexingly quick daft zebras jump!\"</code>');"
        },
        {
          "text": "Your regex should find 36 alphanumeric characters in <code>\"123 456 7890 ABC def GHI jkl MNO pqr STU vwx YZ.\"</code>",
          "testString": "assert(\"123 456 7890 ABC def GHI jkl MNO pqr STU vwx YZ.\".match(alphabetRegexV2).length === 36, 'Your regex should find 36 alphanumeric characters in <code>\"123 456 7890 ABC def GHI jkl MNO pqr STU vwx YZ.\"</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let quoteSample = \"The five boxing wizards jump quickly.\";",
            "let alphabetRegexV2 = /change/; // Change this line",
            "let result = quoteSample.match(alphabetRegexV2).length;"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db8367417b2b2512ba0",
      "title": "Match Everything But Letters and Numbers",
      "description": [
        "You've learned that you can use a shortcut to match alphanumerics <code>[A-Za-z0-9_]</code> using <code>\\w</code>. A natural pattern you might want to search for is the opposite of alphanumerics.",
        "You can search for the opposite of the <code>\\w</code> with <code>\\W</code>. Note, the opposite pattern uses a capital letter. This shortcut is the same as <code>[^A-Za-z0-9_]</code>.",
        "<blockquote>let shortHand = /\\W/;<br>let numbers = \"42%\";<br>let sentence = \"Coding!\";<br>numbers.match(shortHand); // Returns [\"%\"]<br>sentence.match(shortHand); // Returns [\"!\"]<br></blockquote>",
        "<hr>",
        "Use the shorthand character class <code>\\W</code> to count the number of non-alphanumeric characters in various quotes and strings."
      ],
      "tests": [
        {
          "text": "Your regex should use the global flag.",
          "testString": "assert(nonAlphabetRegex.global, 'Your regex should use the global flag.');"
        },
        {
          "text": "Your regex should find 6 non-alphanumeric characters in <code>\"The five boxing wizards jump quickly.\"</code>.",
          "testString": "assert(\"The five boxing wizards jump quickly.\".match(nonAlphabetRegex).length == 6, 'Your regex should find 6 non-alphanumeric characters in <code>\"The five boxing wizards jump quickly.\"</code>.');"
        },
        {
          "text": "Your regex should find 8 non-alphanumeric characters in <code>\"Pack my box with five dozen liquor jugs.\"</code>",
          "testString": "assert(\"Pack my box with five dozen liquor jugs.\".match(nonAlphabetRegex).length == 8, 'Your regex should find 8 non-alphanumeric characters in <code>\"Pack my box with five dozen liquor jugs.\"</code>');"
        },
        {
          "text": "Your regex should find 6 non-alphanumeric characters in <code>\"How vexingly quick daft zebras jump!\"</code>",
          "testString": "assert(\"How vexingly quick daft zebras jump!\".match(nonAlphabetRegex).length == 6, 'Your regex should find 6 non-alphanumeric characters in <code>\"How vexingly quick daft zebras jump!\"</code>');"
        },
        {
          "text": "Your regex should find 12 non-alphanumeric characters in <code>\"123 456 7890 ABC def GHI jkl MNO pqr STU vwx YZ.\"</code>",
          "testString": "assert(\"123 456 7890 ABC def GHI jkl MNO pqr STU vwx YZ.\".match(nonAlphabetRegex).length == 12, 'Your regex should find 12 non-alphanumeric characters in <code>\"123 456 7890 ABC def GHI jkl MNO pqr STU vwx YZ.\"</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let quoteSample = \"The five boxing wizards jump quickly.\";",
            "let nonAlphabetRegex = /change/; // Change this line",
            "let result = quoteSample.match(nonAlphabetRegex).length;"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "5d712346c441eddfaeb5bdef",
      "title": "Match All Numbers",
      "description": [
        "You've learned shortcuts for common string patterns like alphanumerics. Another common pattern is looking for just digits or numbers.",
        "The shortcut to look for digit characters is <code>\\d</code>, with a lowercase <code>d</code>. This is equal to the character class <code>[0-9]</code>, which looks for a single character of any number between zero and nine.",
        "<hr>",
        "Use the shorthand character class <code>\\d</code> to count how many digits are in movie titles. Written out numbers (\"six\" instead of 6) do not count."
      ],
      "tests": [
        {
          "text": "Your regex should use the shortcut character to match digit characters",
          "testString": "assert(/\\\\d/.test(numRegex.source), 'Your regex should use the shortcut character to match digit characters');"
        },
        {
          "text": "Your regex should use the global flag.",
          "testString": "assert(numRegex.global, 'Your regex should use the global flag.');"
        },
        {
          "text": "Your regex should find 1 digit in <code>\"9\"</code>.",
          "testString": "assert(\"9\".match(numRegex).length == 1, 'Your regex should find 1 digit in <code>\"9\"</code>.');"
        },
        {
          "text": "Your regex should find 2 digits in <code>\"Catch 22\"</code>.",
          "testString": "assert(\"Catch 22\".match(numRegex).length == 2, 'Your regex should find 2 digits in <code>\"Catch 22\"</code>.');"
        },
        {
          "text": "Your regex should find 3 digits in <code>\"101 Dalmatians\"</code>.",
          "testString": "assert(\"101 Dalmatians\".match(numRegex).length == 3, 'Your regex should find 3 digits in <code>\"101 Dalmatians\"</code>.');"
        },
        {
          "text": "Your regex should find no digits in <code>\"One, Two, Three\"</code>.",
          "testString": "assert(\"One, Two, Three\".match(numRegex) == null, 'Your regex should find no digits in <code>\"One, Two, Three\"</code>.');"
        },
        {
          "text": "Your regex should find 2 digits in <code>\"21 Jump Street\"</code>.",
          "testString": "assert(\"21 Jump Street\".match(numRegex).length == 2, 'Your regex should find 2 digits in <code>\"21 Jump Street\"</code>.');"
        },
        {
          "text": "Your regex should find 4 digits in <code>\"2001: A Space Odyssey\"</code>.",
          "testString": "assert(\"2001: A Space Odyssey\".match(numRegex).length == 4, 'Your regex should find 4 digits in <code>\"2001: A Space Odyssey\"</code>.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let numString = \"Your sandwich will be $5.00\";",
            "let numRegex = /change/; // Change this line",
            "let result = numString.match(numRegex).length;"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db8367417b2b2512ba1",
      "title": "Match All Non-Numbers",
      "description": [
        "The last challenge showed how to search for digits using the shortcut <code>\\d</code> with a lowercase <code>d</code>. You can also search for non-digits using a similar shortcut that uses an uppercase <code>D</code> instead.",
        "The shortcut to look for non-digit characters is <code>\\D</code>. This is equal to the character class <code>[^0-9]</code>, which looks for a single character that is not a number between zero and nine.",
        "<hr>",
        "Use the shorthand character class for non-digits <code>\\D</code> to count how many non-digits are in movie titles."
      ],
      "tests": [
        {
          "text": "Your regex should use the shortcut character to match non-digit characters",
          "testString": "assert(/\\\\D/.test(noNumRegex.source), 'Your regex should use the shortcut character to match non-digit characters');"
        },
        {
          "text": "Your regex should use the global flag.",
          "testString": "assert(noNumRegex.global, 'Your regex should use the global flag.');"
        },
        {
          "text": "Your regex should find no non-digits in <code>\"9\"</code>.",
          "testString": "assert(\"9\".match(noNumRegex) == null, 'Your regex should find no non-digits in <code>\"9\"</code>.');"
        },
        {
          "text": "Your regex should find 6 non-digits in <code>\"Catch 22\"</code>.",
          "testString": "assert(\"Catch 22\".match(noNumRegex).length == 6, 'Your regex should find 6 non-digits in <code>\"Catch 22\"</code>.');"
        },
        {
          "text": "Your regex should find 11 non-digits in <code>\"101 Dalmatians\"</code>.",
          "testString": "assert(\"101 Dalmatians\".match(noNumRegex).length == 11, 'Your regex should find 11 non-digits in <code>\"101 Dalmatians\"</code>.');"
        },
        {
          "text": "Your regex should find 15 non-digits in <code>\"One, Two, Three\"</code>.",
          "testString": "assert(\"One, Two, Three\".match(noNumRegex).length == 15, 'Your regex should find 15 non-digits in <code>\"One, Two, Three\"</code>.');"
        },
        {
          "text": "Your regex should find 12 non-digits in <code>\"21 Jump Street\"</code>.",
          "testString": "assert(\"21 Jump Street\".match(noNumRegex).length == 12, 'Your regex should find 12 non-digits in <code>\"21 Jump Street\"</code>.');"
        },
        {
          "text": "Your regex should find 17 non-digits in <code>\"2001: A Space Odyssey\"</code>.",
          "testString": "assert(\"2001: A Space Odyssey\".match(noNumRegex).length == 17, 'Your regex should find 17 non-digits in <code>\"2001: A Space Odyssey\"</code>.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let numString = \"Your sandwich will be $5.00\";",
            "let noNumRegex = /change/; // Change this line",
            "let result = numString.match(noNumRegex).length;"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db8367417b2b2512ba2",
      "title": "Restrict Possible Usernames",
      "description": [
        "Usernames are used everywhere on the internet. They are what give users a unique identity on their favorite sites.",
        "You need to check all the usernames in a database. Here are some simple rules that users have to follow when creating their username.",
        "1) The only numbers in the username have to be at the end. There can be zero or more of them at the end.",
        "2) Username letters can be lowercase and uppercase.",
        "3) Usernames have to be at least two characters long. A two-letter username can only use alphabet letter characters.",
        "<hr>",
        "Change the regex <code>userCheck</code> to fit the constraints listed above."
      ],
      "tests": [
        {
          "text": "Your regex should match <code>JACK</code>",
          "testString": "assert(userCheck.test(\"JACK\"), 'Your regex should match <code>JACK</code>');"
        },
        {
          "text": "Your regex should not match <code>J</code>",
          "testString": "assert(!userCheck.test(\"J\"), 'Your regex should not match <code>J</code>');"
        },
        {
          "text": "Your regex should match <code>Oceans11</code>",
          "testString": "assert(userCheck.test(\"Oceans11\"), 'Your regex should match <code>Oceans11</code>');"
        },
        {
          "text": "Your regex should match <code>RegexGuru</code>",
          "testString": "assert(userCheck.test(\"RegexGuru\"), 'Your regex should match <code>RegexGuru</code>');"
        },
        {
          "text": "Your regex should not match <code>007</code>",
          "testString": "assert(!userCheck.test(\"007\"), 'Your regex should not match <code>007</code>');"
        },
        {
          "text": "Your regex should not match <code>9</code>",
          "testString": "assert(!userCheck.test(\"9\"), 'Your regex should not match <code>9</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let username = \"JackOfAllTrades\";",
            "let userCheck = /change/; // Change this line",
            "let result = userCheck.test(username);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db8367417b2b2512ba3",
      "title": "Match Whitespace",
      "description": [
        "The challenges so far have covered matching letters of the alphabet and numbers. You can also match the whitespace or spaces between letters.",
        "You can search for whitespace using <code>\\s</code>, which is a lowercase <code>s</code>. This pattern not only matches whitespace, but also carriage return, tab, form feed, and new line characters. You can think of it as similar to the character class <code>[ \\r\\t\\f\\n\\v]</code>.",
        "<blockquote>let whiteSpace = \"Whitespace. Whitespace everywhere!\"<br>let spaceRegex = /\\s/g;<br>whiteSpace.match(spaceRegex);<br>// Returns [\" \", \" \"]<br></blockquote>",
        "<hr>",
        "Change the regex <code>countWhiteSpace</code> to look for multiple whitespace characters in a string."
      ],
      "tests": [
        {
          "text": "Your regex should use the global flag.",
          "testString": "assert(countWhiteSpace.global, 'Your regex should use the global flag.');"
        },
        {
          "text": "Your regex should find eight spaces in <code>\"Men are from Mars and women are from Venus.\"</code>",
          "testString": "assert(\"Men are from Mars and women are from Venus.\".match(countWhiteSpace).length == 8, 'Your regex should find eight spaces in <code>\"Men are from Mars and women are from Venus.\"</code>');"
        },
        {
          "text": "Your regex should find three spaces in <code>\"Space: the final frontier.\"</code>",
          "testString": "assert(\"Space: the final frontier.\".match(countWhiteSpace).length == 3, 'Your regex should find three spaces in <code>\"Space: the final frontier.\"</code>');"
        },
        {
          "text": "Your regex should find no spaces in <code>\"MindYourPersonalSpace\"</code>",
          "testString": "assert(\"MindYourPersonalSpace\".match(countWhiteSpace) == null, 'Your regex should find no spaces in <code>\"MindYourPersonalSpace\"</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let sample = \"Whitespace is important in separating words\";",
            "let countWhiteSpace = /change/; // Change this line",
            "let result = sample.match(countWhiteSpace);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db9367417b2b2512ba4",
      "title": "Match Non-Whitespace Characters",
      "description": [
        "You learned about searching for whitespace using <code>\\s</code>, with a lowercase <code>s</code>. You can also search for everything except whitespace.",
        "Search for non-whitespace using <code>\\S</code>, which is an uppercase <code>s</code>. This pattern will not match whitespace, carriage return, tab, form feed, and new line characters. You can think of it being similar to the character class <code>[^ \\r\\t\\f\\n\\v]</code>.",
        "<blockquote>let whiteSpace = \"Whitespace. Whitespace everywhere!\"<br>let nonSpaceRegex = /\\S/g;<br>whiteSpace.match(nonSpaceRegex).length; // Returns 32</blockquote>",
        "<hr>",
        "Change the regex <code>countNonWhiteSpace</code> to look for multiple non-whitespace characters in a string."
      ],
      "tests": [
        {
          "text": "Your regex should use the global flag.",
          "testString": "assert(countNonWhiteSpace.global, 'Your regex should use the global flag.');"
        },
        {
          "text": "Your regex should find 35 non-spaces in <code>\"Men are from Mars and women are from Venus.\"</code>",
          "testString": "assert(\"Men are from Mars and women are from Venus.\".match(countNonWhiteSpace).length == 35, 'Your regex should find 35 non-spaces in <code>\"Men are from Mars and women are from Venus.\"</code>');"
        },
        {
          "text": "Your regex should find 23 non-spaces in <code>\"Space: the final frontier.\"</code>",
          "testString": "assert(\"Space: the final frontier.\".match(countNonWhiteSpace).length == 23, 'Your regex should find 23 non-spaces in <code>\"Space: the final frontier.\"</code>');"
        },
        {
          "text": "Your regex should find 21 non-spaces in <code>\"MindYourPersonalSpace\"</code>",
          "testString": "assert(\"MindYourPersonalSpace\".match(countNonWhiteSpace).length == 21, 'Your regex should find 21 non-spaces in <code>\"MindYourPersonalSpace\"</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let sample = \"Whitespace is important in separating words\";",
            "let countNonWhiteSpace = /change/; // Change this line",
            "let result = sample.match(countNonWhiteSpace);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db9367417b2b2512ba5",
      "title": "Specify Upper and Lower Number of Matches",
      "description": [
        "Recall that you use the plus sign <code>+</code> to look for one or more characters and the asterisk <code>*</code> to look for zero or more characters. These are convenient but sometimes you want to match a certain range of patterns.",
        "You can specify the lower and upper number of patterns with <code>quantity specifiers</code>. Quantity specifiers are used with curly brackets (<code>{</code> and <code>}</code>). You put two numbers between the curly brackets - for the lower and upper number of patterns.",
        "For example, to match only the letter <code>a</code> appearing between <code>3</code> and <code>5</code> times in the string <code>\"ah\"</code>, your regex would be <code>/a{3,5}h/</code>.",
        "<blockquote>let A4 = \"aaaah\";<br>let A2 = \"aah\";<br>let multipleA = /a{3,5}h/;<br>multipleA.test(A4); // Returns true<br>multipleA.test(A2); // Returns false</blockquote>",
        "<hr>",
        "Change the regex <code>ohRegex</code> to match only <code>3</code> to <code>6</code> letter <code>h</code>'s in the word <code>\"Oh no\"</code>."
      ],
      "tests": [
        {
          "text": "Your regex should use curly brackets.",
          "testString": "assert(ohRegex.source.match(/{.*?}/).length > 0, 'Your regex should use curly brackets.');"
        },
        {
          "text": "Your regex should not match <code>\"Ohh no\"</code>",
          "testString": "assert(!ohRegex.test(\"Ohh no\"), 'Your regex should not match <code>\"Ohh no\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"Ohhh no\"</code>",
          "testString": "assert(ohRegex.test(\"Ohhh no\"), 'Your regex should match <code>\"Ohhh no\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"Ohhhh no\"</code>",
          "testString": "assert(ohRegex.test(\"Ohhhh no\"), 'Your regex should match <code>\"Ohhhh no\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"Ohhhhh no\"</code>",
          "testString": "assert(ohRegex.test(\"Ohhhhh no\"), 'Your regex should match <code>\"Ohhhhh no\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"Ohhhhhh no\"</code>",
          "testString": "assert(ohRegex.test(\"Ohhhhhh no\"), 'Your regex should match <code>\"Ohhhhhh no\"</code>');"
        },
        {
          "text": "Your regex should not match <code>\"Ohhhhhhh no\"</code>",
          "testString": "assert(!ohRegex.test(\"Ohhhhhhh no\"), 'Your regex should not match <code>\"Ohhhhhhh no\"</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let ohStr = \"Ohhh no\";",
            "let ohRegex = /change/; // Change this line",
            "let result = ohRegex.test(ohStr);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db9367417b2b2512ba6",
      "title": "Specify Only the Lower Number of Matches",
      "description": [
        "You can specify the lower and upper number of patterns with <code>quantity specifiers</code> using curly brackets. Sometimes you only want to specify the lower number of patterns with no upper limit.",
        "To only specify the lower number of patterns, keep the first number followed by a comma.",
        "For example, to match only the string <code>\"hah\"</code> with the letter <code>a</code> appearing at least <code>3</code> times, your regex would be <code>/ha{3,}h/</code>.",
        "<blockquote>let A4 = \"haaaah\";<br>let A2 = \"haah\";<br>let A100 = \"h\" + \"a\".repeat(100) + \"h\";<br>let multipleA = /ha{3,}h/;<br>multipleA.test(A4); // Returns true<br>multipleA.test(A2); // Returns false<br>multipleA.test(A100); // Returns true</blockquote>",
        "<hr>",
        "Change the regex <code>haRegex</code> to match the word <code>\"Hazzah\"</code> only when it has four or more letter <code>z</code>'s."
      ],
      "tests": [
        {
          "text": "Your regex should use curly brackets.",
          "testString": "assert(haRegex.source.match(/{.*?}/).length > 0, 'Your regex should use curly brackets.');"
        },
        {
          "text": "Your regex should not match <code>\"Hazzah\"</code>",
          "testString": "assert(!haRegex.test(\"Hazzah\"), 'Your regex should not match <code>\"Hazzah\"</code>');"
        },
        {
          "text": "Your regex should not match <code>\"Hazzzah\"</code>",
          "testString": "assert(!haRegex.test(\"Hazzzah\"), 'Your regex should not match <code>\"Hazzzah\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"Hazzzzah\"</code>",
          "testString": "assert(haRegex.test(\"Hazzzzah\"), 'Your regex should match <code>\"Hazzzzah\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"Hazzzzzah\"</code>",
          "testString": "assert(haRegex.test(\"Hazzzzzah\"), 'Your regex should match <code>\"Hazzzzzah\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"Hazzzzzzah\"</code>",
          "testString": "assert(haRegex.test(\"Hazzzzzzah\"), 'Your regex should match <code>\"Hazzzzzzah\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"Hazzah\"</code> with 30 <code>z</code>\\'s in it.",
          "testString": "assert(haRegex.test(\"Ha\" + \"z\".repeat(30) + \"ah\"), 'Your regex should match <code>\"Hazzah\"</code> with 30 <code>z</code>\\'s in it.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let haStr = \"Hazzzzah\";",
            "let haRegex = /change/; // Change this line",
            "let result = haRegex.test(haStr);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7db9367417b2b2512ba7",
      "title": "Specify Exact Number of Matches",
      "description": [
        "You can specify the lower and upper number of patterns with <code>quantity specifiers</code> using curly brackets. Sometimes you only want a specific number of matches.",
        "To specify a certain number of patterns, just have that one number between the curly brackets.",
        "For example, to match only the word <code>\"hah\"</code> with the letter <code>a</code> <code>3</code> times, your regex would be <code>/ha{3}h/</code>.",
        "<blockquote>let A4 = \"haaaah\";<br>let A3 = \"haaah\";<br>let A100 = \"h\" + \"a\".repeat(100) + \"h\";<br>let multipleHA = /a{3}h/;<br>multipleHA.test(A4); // Returns false<br>multipleHA.test(A3); // Returns true<br>multipleHA.test(A100); // Returns false</blockquote>",
        "<hr>",
        "Change the regex <code>timRegex</code> to match the word <code>\"Timber\"</code> only when it has four letter <code>m</code>'s."
      ],
      "tests": [
        {
          "text": "Your regex should use curly brackets.",
          "testString": "assert(timRegex.source.match(/{.*?}/).length > 0, 'Your regex should use curly brackets.');"
        },
        {
          "text": "Your regex should not match <code>\"Timber\"</code>",
          "testString": "assert(!timRegex.test(\"Timber\"), 'Your regex should not match <code>\"Timber\"</code>');"
        },
        {
          "text": "Your regex should not match <code>\"Timmber\"</code>",
          "testString": "assert(!timRegex.test(\"Timmber\"), 'Your regex should not match <code>\"Timmber\"</code>');"
        },
        {
          "text": "Your regex should not match <code>\"Timmmber\"</code>",
          "testString": "assert(!timRegex.test(\"Timmmber\"), 'Your regex should not match <code>\"Timmmber\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"Timmmmber\"</code>",
          "testString": "assert(timRegex.test(\"Timmmmber\"), 'Your regex should match <code>\"Timmmmber\"</code>');"
        },
        {
          "text": "Your regex should not match <code>\"Timber\"</code> with 30 <code>m</code>\\'s in it.",
          "testString": "assert(!timRegex.test(\"Ti\" + \"m\".repeat(30) + \"ber\"), 'Your regex should not match <code>\"Timber\"</code> with 30 <code>m</code>\\'s in it.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let timStr = \"Timmmmber\";",
            "let timRegex = /change/; // Change this line",
            "let result = timRegex.test(timStr);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dba367417b2b2512ba8",
      "title": "Check for All or None",
      "description": [
        "Sometimes the patterns you want to search for may have parts of it that may or may not exist. However, it may be important to check for them nonetheless.",
        "You can specify the possible existence of an element with a question mark, <code>?</code>. This checks for zero or one of the preceding element. You can think of this symbol as saying the previous element is optional.",
        "For example, there are slight differences in American and British English and you can use the question mark to match both spellings.",
        "<blockquote>let american = \"color\";<br>let british = \"colour\";<br>let rainbowRegex= /colou?r/;<br>rainbowRegex.test(american); // Returns true<br>rainbowRegex.test(british); // Returns true</blockquote>",
        "<hr>",
        "Change the regex <code>favRegex</code> to match both the American English (favorite) and the British English (favourite) version of the word."
      ],
      "tests": [
        {
          "text": "Your regex should use the optional symbol, <code>?</code>.",
          "testString": "assert(favRegex.source.match(/\\?/).length > 0, 'Your regex should use the optional symbol, <code>?</code>.');"
        },
        {
          "text": "Your regex should match <code>\"favorite\"</code>",
          "testString": "assert(favRegex.test(\"favorite\"), 'Your regex should match <code>\"favorite\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"favourite\"</code>",
          "testString": "assert(favRegex.test(\"favourite\"), 'Your regex should match <code>\"favourite\"</code>');"
        },
        {
          "text": "Your regex should not match <code>\"fav\"</code>",
          "testString": "assert(!favRegex.test(\"fav\"), 'Your regex should not match <code>\"fav\"</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let favWord = \"favorite\";",
            "let favRegex = /change/; // Change this line",
            "let result = favRegex.test(favWord);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dba367417b2b2512ba9",
      "title": "Positive and Negative Lookahead",
      "description": [
        "<code>Lookaheads</code> are patterns that tell JavaScript to look-ahead in your string to check for patterns further along. This can be useful when you want to search for multiple patterns over the same string.",
        "There are two kinds of <code>lookaheads</code>: <code>positive lookahead</code> and <code>negative lookahead</code>.",
        "A <code>positive lookahead</code> will look to make sure the element in the search pattern is there, but won't actually match it. A positive lookahead is used as <code>(?=...)</code> where the <code>...</code> is the required part that is not matched.",
        "On the other hand, a <code>negative lookahead</code> will look to make sure the element in the search pattern is not there. A negative lookahead is used as <code>(?!...)</code> where the <code>...</code> is the pattern that you do not want to be there. The rest of the pattern is returned if the negative lookahead part is not present.",
        "Lookaheads are a bit confusing but some examples will help.",
        "<blockquote>let quit = \"qu\";<br>let noquit = \"qt\";<br>let quRegex= /q(?=u)/;<br>let qRegex = /q(?!u)/;<br>quit.match(quRegex); // Returns [\"q\"]<br>noquit.match(qRegex); // Returns [\"q\"]</blockquote>",
        "A more practical use of <code>lookaheads</code> is to check two or more patterns in one string. Here is a (naively) simple password checker that looks for between 3 and 6 characters and at least one number:",
        "<blockquote>let password = \"abc123\";<br>let checkPass = /(?=\\w{3,6})(?=\\D*\\d)/;<br>checkPass.test(password); // Returns true</blockquote>",
        "<hr>",
        "Use <code>lookaheads</code> in the <code>pwRegex</code> to match passwords that are greater than 5 characters long and have two consecutive digits."
      ],
      "tests": [
        {
          "text": "Your regex should use two positive <code>lookaheads</code>.",
          "testString": "assert(pwRegex.source.match(/\\(\\?=.*?\\)\\(\\?=.*?\\)/) !== null, 'Your regex should use two positive <code>lookaheads</code>.');"
        },
        {
          "text": "Your regex should not match <code>\"astronaut\"</code>",
          "testString": "assert(!pwRegex.test(\"astronaut\"), 'Your regex should not match <code>\"astronaut\"</code>');"
        },
        {
          "text": "Your regex should not match <code>\"airplanes\"</code>",
          "testString": "assert(!pwRegex.test(\"airplanes\"), 'Your regex should not match <code>\"airplanes\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"bana12\"</code>",
          "testString": "assert(pwRegex.test(\"bana12\"), 'Your regex should match <code>\"bana12\"</code>');"
        },
        {
          "text": "Your regex should match <code>\"abc123\"</code>",
          "testString": "assert(pwRegex.test(\"abc123\"), 'Your regex should match <code>\"abc123\"</code>');"
        },
        {
          "text": "Your regex should not match <code>\"123\"</code>",
          "testString": "assert(!pwRegex.test(\"123\"), 'Your regex should not match <code>\"123\"</code>');"
        },
        {
          "text": "Your regex should not match <code>\"1234\"</code>",
          "testString": "assert(!pwRegex.test(\"1234\"), 'Your regex should not match <code>\"1234\"</code>');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let sampleWord = \"astronaut\";",
            "let pwRegex = /change/; // Change this line",
            "let result = pwRegex.test(sampleWord);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dbb367417b2b2512baa",
      "title": "Reuse Patterns Using Capture Groups",
      "description": [
        "Some patterns you search for will occur multiple times in a string. It is wasteful to manually repeat that regex. There is a better way to specify when you have multiple repeat substrings in your string.",
        "You can search for repeat substrings using <code>capture groups</code>. Parentheses, <code>(</code> and <code>)</code>, are used to find repeat substrings. You put the regex of the pattern that will repeat in between the parentheses.",
        "To specify where that repeat string will appear, you use a backslash (<code>\\</code>) and then a number. This number starts at 1 and increases with each additional capture group you use. An example would be <code>\\1</code> to match the first group.",
        "The example below matches any word that occurs twice separated by a space:",
        "<blockquote>let repeatStr = \"regex regex\";<br>let repeatRegex = /(\\w+)\\s\\1/;<br>repeatRegex.test(repeatStr); // Returns true<br>repeatStr.match(repeatRegex); // Returns [\"regex regex\", \"regex\"]</blockquote>",
        "Using the <code>.match()</code> method on a string will return an array with the string it matches, along with its capture group.",
        "<hr>",
        "Use <code>capture groups</code> in <code>reRegex</code> to match numbers that are repeated only three times in a string, each separated by a space."
      ],
      "tests": [
        {
          "text": "Your regex should use the shorthand character class for digits.",
          "testString": "assert(reRegex.source.match(/\\\\d/), 'Your regex should use the shorthand character class for digits.');"
        },
        {
          "text": "Your regex should reuse the capture group twice.",
          "testString": "assert(reRegex.source.match(/\\\\\\d/g).length === 2, 'Your regex should reuse the capture group twice.');"
        },
        {
          "text": "Your regex should have two spaces separating the three numbers.",
          "testString": "assert(reRegex.source.match(/\\\\s/g).length === 2, 'Your regex should have two spaces separating the three numbers.');"
        },
        {
          "text": "Your regex should match <code>\"42 42 42\"</code>.",
          "testString": "assert(reRegex.test(\"42 42 42\"), 'Your regex should match <code>\"42 42 42\"</code>.');"
        },
        {
          "text": "Your regex should match <code>\"100 100 100\"</code>.",
          "testString": "assert(reRegex.test(\"100 100 100\"), 'Your regex should match <code>\"100 100 100\"</code>.');"
        },
        {
          "text": "Your regex should not match <code>\"42 42 42 42\"</code>.",
          "testString": "assert.equal((\"42 42 42 42\").match(reRegex.source), null, 'Your regex should not match <code>\"42 42 42 42\"</code>.');"
        },
        {
          "text": "Your regex should not match <code>\"42 42\"</code>.",
          "testString": "assert.equal((\"42 42\").match(reRegex.source), null, 'Your regex should not match <code>\"42 42\"</code>.');"
        },
        {
          "text": "Your regex should not match <code>\"101 102 103\"</code>.",
          "testString": "assert(!reRegex.test(\"101 102 103\"), 'Your regex should not match <code>\"101 102 103\"</code>.');"
        },
        {
          "text": "Your regex should not match <code>\"1 2 3\"</code>.",
          "testString": "assert(!reRegex.test(\"1 2 3\"), 'Your regex should not match <code>\"1 2 3\"</code>.');"
        },
        {
          "text": "Your regex should match <code>\"10 10 10\"</code>.",
          "testString": "assert(reRegex.test(\"10 10 10\"), 'Your regex should match <code>\"10 10 10\"</code>.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let repeatNum = \"42 42 42\";",
            "let reRegex = /change/; // Change this line",
            "let result = reRegex.test(repeatNum);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dbb367417b2b2512bab",
      "title": "Use Capture Groups to Search and Replace",
      "description": [
        "Searching is useful. However, you can make searching even more powerful when it also changes (or replaces) the text you match.",
        "You can search and replace text in a string using <code>.replace()</code> on a string. The inputs for <code>.replace()</code> is first the regex pattern you want to search for. The second parameter is the string to replace the match or a function to do something.",
        "<blockquote>let wrongText = \"The sky is silver.\";<br>let silverRegex = /silver/;<br>wrongText.replace(silverRegex, \"blue\");<br>// Returns \"The sky is blue.\"</blockquote>",
        "You can also access capture groups in the replacement string with dollar signs (<code>$</code>).",
        "<blockquote>\"Code Camp\".replace(/(\\w+)\\s(\\w+)/, '$2 $1');<br>// Returns \"Camp Code\"</blockquote>",
        "<hr>",
        "Write a regex so that it will search for the string <code>\"good\"</code>. Then update the <code>replaceText</code> variable to replace <code>\"good\"</code> with <code>\"okey-dokey\"</code>."
      ],
      "tests": [
        {
          "text": "You should use <code>.replace()</code> to search and replace.",
          "testString": "assert(code.match(/\\.replace\\(.*\\)/), 'You should use <code>.replace()</code> to search and replace.');"
        },
        {
          "text": "Your regex should change <code>\"This sandwich is good.\"</code> to <code>\"This sandwich is okey-dokey.\"</code>",
          "testString": "assert(result == \"This sandwich is okey-dokey.\" && replaceText === \"okey-dokey\", 'Your regex should change <code>\"This sandwich is good.\"</code> to <code>\"This sandwich is okey-dokey.\"</code>');"
        },
        {
          "text": "You should not change the last line.",
          "testString": "assert(code.match(/result\\s*=\\s*huhText\\.replace\\(.*?\\)/), 'You should not change the last line.');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let huhText = \"This sandwich is good.\";",
            "let fixRegex = /change/; // Change this line",
            "let replaceText = \"\"; // Change this line",
            "let result = huhText.replace(fixRegex, replaceText);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7dbb367417b2b2512bac",
      "title": "Remove Whitespace from Start and End",
      "description": [
        "Sometimes whitespace characters around strings are not wanted but are there. Typical processing of strings is to remove the whitespace at the start and end of it.",
        "<hr>",
        "Write a regex and use the appropriate string methods to remove whitespace at the beginning and end of strings.",
        "<strong>Note</strong><br>The <code>.trim()</code> method would work here, but you'll need to complete this challenge using regular expressions."
      ],
      "tests": [
        {
          "text": "<code>结果</code> should equal to <code>\"Hello, World!\"</code>",
          "testString": "assert(result == \"Hello, World!\", '<code>结果</code> should equal to <code>\"Hello, World!\"</code>');"
        },
        {
          "text": "You should not use the <code>.trim()</code> method.",
          "testString": "assert(!code.match(/\\.trim\\(.*?\\)/), 'You should not use the <code>.trim()</code> method.');"
        },
        {
          "text": "The <code>结果</code> variable should not be set equal to a string.",
          "testString": "assert(!code.match(/result\\s*=\\s*\".*?\"/), 'The <code>结果</code> variable should not be set equal to a string.');"
        }
      ],
      "solutions": [],
      "hints": [
        "You can use .replace() to remove the matched items by replacing them with an empty string."
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "translations": {},
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let hello = \"   Hello, World!  \";",
            "let wsRegex = /change/; // Change this line",
            "let result = hello; // Change this line"
          ],
          "head": [],
          "tail": []
        }
      }
    }
  ]
}